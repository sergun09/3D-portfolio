import {
  AlwaysCompare,
  BackSide,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  ClampToEdgeWrapping,
  Color,
  ColorManagement,
  CubeCamera,
  CubeReflectionMapping,
  CubeRefractionMapping,
  CubeTexture,
  DataArrayTexture,
  DepthTexture,
  DynamicDrawUsage,
  EqualCompare,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  Euler,
  EventDispatcher,
  Float32BufferAttribute,
  FloatType,
  FramebufferTexture,
  Frustum,
  GreaterCompare,
  GreaterEqualCompare,
  HalfFloatType,
  InstancedBufferAttribute,
  InstancedInterleavedBuffer,
  IntType,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  LessCompare,
  LessEqualCompare,
  LineBasicMaterial,
  LineDashedMaterial,
  LinearFilter,
  LinearMipMapLinearFilter,
  LinearMipmapLinearFilter,
  LinearSRGBColorSpace,
  Material,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshLambertMaterial,
  MeshMatcapMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  MirroredRepeatWrapping,
  NeverCompare,
  NoBlending,
  NoColorSpace,
  NoToneMapping,
  NormalBlending,
  NotEqualCompare,
  Object3D,
  ObjectSpaceNormalMap,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PointsMaterial,
  RGFormat,
  RenderTarget,
  RepeatWrapping,
  SRGBTransfer,
  Scene,
  ShadowMaterial,
  SpriteMaterial,
  StaticDrawUsage,
  TangentSpaceNormalMap,
  Texture,
  UVMapping,
  UnsignedIntType,
  VSMShadowMap,
  Vector2,
  Vector3,
  Vector4,
  WebGLCoordinateSystem,
  WebGLCubeRenderTarget,
  WebGPUCoordinateSystem
} from "./chunk-SLX53DQC.js";
import "./chunk-HKJ2B2AA.js";

// node_modules/three/build/three.webgpu.js
var refreshUniforms = [
  "alphaMap",
  "alphaTest",
  "anisotropy",
  "anisotropyMap",
  "anisotropyRotation",
  "aoMap",
  "attenuationColor",
  "attenuationDistance",
  "bumpMap",
  "clearcoat",
  "clearcoatMap",
  "clearcoatNormalMap",
  "clearcoatNormalScale",
  "clearcoatRoughness",
  "color",
  "dispersion",
  "displacementMap",
  "emissive",
  "emissiveMap",
  "envMap",
  "gradientMap",
  "ior",
  "iridescence",
  "iridescenceIOR",
  "iridescenceMap",
  "iridescenceThicknessMap",
  "lightMap",
  "map",
  "matcap",
  "metalness",
  "metalnessMap",
  "normalMap",
  "normalScale",
  "opacity",
  "roughness",
  "roughnessMap",
  "sheen",
  "sheenColor",
  "sheenColorMap",
  "sheenRoughnessMap",
  "shininess",
  "specular",
  "specularColor",
  "specularColorMap",
  "specularIntensity",
  "specularIntensityMap",
  "specularMap",
  "thickness",
  "transmission",
  "transmissionMap"
];
var NodeMaterialObserver = class {
  constructor(builder) {
    this.renderObjects = /* @__PURE__ */ new WeakMap();
    this.hasNode = this.containsNode(builder);
    this.hasAnimation = builder.object.isSkinnedMesh === true;
    this.refreshUniforms = refreshUniforms;
    this.renderId = 0;
  }
  firstInitialization(renderObject) {
    const hasInitialized = this.renderObjects.has(renderObject);
    if (hasInitialized === false) {
      this.getRenderObjectData(renderObject);
      return true;
    }
    return false;
  }
  getRenderObjectData(renderObject) {
    let data = this.renderObjects.get(renderObject);
    if (data === void 0) {
      const { geometry, material, object } = renderObject;
      data = {
        material: this.getMaterialData(material),
        geometry: {
          attributes: this.getAttributesData(geometry.attributes),
          indexVersion: geometry.index ? geometry.index.version : null,
          drawRange: { start: geometry.drawRange.start, count: geometry.drawRange.count }
        },
        worldMatrix: object.matrixWorld.clone()
      };
      if (object.center) {
        data.center = object.center.clone();
      }
      if (object.morphTargetInfluences) {
        data.morphTargetInfluences = object.morphTargetInfluences.slice();
      }
      if (renderObject.bundle !== null) {
        data.version = renderObject.bundle.version;
      }
      if (data.material.transmission > 0) {
        const { width, height } = renderObject.context;
        data.bufferWidth = width;
        data.bufferHeight = height;
      }
      this.renderObjects.set(renderObject, data);
    }
    return data;
  }
  getAttributesData(attributes) {
    const attributesData = {};
    for (const name in attributes) {
      const attribute3 = attributes[name];
      attributesData[name] = {
        version: attribute3.version
      };
    }
    return attributesData;
  }
  containsNode(builder) {
    const material = builder.material;
    for (const property3 in material) {
      if (material[property3] && material[property3].isNode)
        return true;
    }
    if (builder.renderer.nodes.modelViewMatrix !== null || builder.renderer.nodes.modelNormalViewMatrix !== null)
      return true;
    return false;
  }
  getMaterialData(material) {
    const data = {};
    for (const property3 of this.refreshUniforms) {
      const value = material[property3];
      if (value === null || value === void 0) continue;
      if (typeof value === "object" && value.clone !== void 0) {
        if (value.isTexture === true) {
          data[property3] = { id: value.id, version: value.version };
        } else {
          data[property3] = value.clone();
        }
      } else {
        data[property3] = value;
      }
    }
    return data;
  }
  equals(renderObject) {
    const { object, material, geometry } = renderObject;
    const renderObjectData = this.getRenderObjectData(renderObject);
    if (renderObjectData.worldMatrix.equals(object.matrixWorld) !== true) {
      renderObjectData.worldMatrix.copy(object.matrixWorld);
      return false;
    }
    const materialData = renderObjectData.material;
    for (const property3 in materialData) {
      const value = materialData[property3];
      const mtlValue = material[property3];
      if (value.equals !== void 0) {
        if (value.equals(mtlValue) === false) {
          value.copy(mtlValue);
          return false;
        }
      } else if (mtlValue.isTexture === true) {
        if (value.id !== mtlValue.id || value.version !== mtlValue.version) {
          value.id = mtlValue.id;
          value.version = mtlValue.version;
          return false;
        }
      } else if (value !== mtlValue) {
        materialData[property3] = mtlValue;
        return false;
      }
    }
    if (materialData.transmission > 0) {
      const { width, height } = renderObject.context;
      if (renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height) {
        renderObjectData.bufferWidth = width;
        renderObjectData.bufferHeight = height;
        return false;
      }
    }
    const storedGeometryData = renderObjectData.geometry;
    const attributes = geometry.attributes;
    const storedAttributes = storedGeometryData.attributes;
    const storedAttributeNames = Object.keys(storedAttributes);
    const currentAttributeNames = Object.keys(attributes);
    if (storedAttributeNames.length !== currentAttributeNames.length) {
      renderObjectData.geometry.attributes = this.getAttributesData(attributes);
      return false;
    }
    for (const name of storedAttributeNames) {
      const storedAttributeData = storedAttributes[name];
      const attribute3 = attributes[name];
      if (attribute3 === void 0) {
        delete storedAttributes[name];
        return false;
      }
      if (storedAttributeData.version !== attribute3.version) {
        storedAttributeData.version = attribute3.version;
        return false;
      }
    }
    const index = geometry.index;
    const storedIndexVersion = storedGeometryData.indexVersion;
    const currentIndexVersion = index ? index.version : null;
    if (storedIndexVersion !== currentIndexVersion) {
      storedGeometryData.indexVersion = currentIndexVersion;
      return false;
    }
    if (storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count) {
      storedGeometryData.drawRange.start = geometry.drawRange.start;
      storedGeometryData.drawRange.count = geometry.drawRange.count;
      return false;
    }
    if (renderObjectData.morphTargetInfluences) {
      let morphChanged = false;
      for (let i = 0; i < renderObjectData.morphTargetInfluences.length; i++) {
        if (renderObjectData.morphTargetInfluences[i] !== object.morphTargetInfluences[i]) {
          morphChanged = true;
        }
      }
      if (morphChanged) return true;
    }
    if (renderObjectData.center) {
      if (renderObjectData.center.equals(object.center) === false) {
        renderObjectData.center.copy(object.center);
        return true;
      }
    }
    if (renderObject.bundle !== null) {
      renderObjectData.version = renderObject.bundle.version;
    }
    return true;
  }
  needsRefresh(renderObject, nodeFrame) {
    if (this.hasNode || this.hasAnimation || this.firstInitialization(renderObject))
      return true;
    const { renderId } = nodeFrame;
    if (this.renderId !== renderId) {
      this.renderId = renderId;
      return true;
    }
    const isStatic = renderObject.object.static === true;
    const isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData(renderObject).version === renderObject.bundle.version;
    if (isStatic || isBundle)
      return false;
    const notEqual3 = this.equals(renderObject) !== true;
    return notEqual3;
  }
};
function cyrb53(value, seed = 0) {
  let h12 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
  if (value instanceof Array) {
    for (let i = 0, val; i < value.length; i++) {
      val = value[i];
      h12 = Math.imul(h12 ^ val, 2654435761);
      h2 = Math.imul(h2 ^ val, 1597334677);
    }
  } else {
    for (let i = 0, ch; i < value.length; i++) {
      ch = value.charCodeAt(i);
      h12 = Math.imul(h12 ^ ch, 2654435761);
      h2 = Math.imul(h2 ^ ch, 1597334677);
    }
  }
  h12 = Math.imul(h12 ^ h12 >>> 16, 2246822507);
  h12 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
  h2 ^= Math.imul(h12 ^ h12 >>> 13, 3266489909);
  return 4294967296 * (2097151 & h2) + (h12 >>> 0);
}
var hashString = (str) => cyrb53(str);
var hashArray = (array) => cyrb53(array);
var hash$1 = (...params) => cyrb53(params);
function getCacheKey$1(object, force = false) {
  const values = [];
  if (object.isNode === true) {
    values.push(object.id);
    object = object.getSelf();
  }
  for (const { property: property3, childNode } of getNodeChildren(object)) {
    values.push(values, cyrb53(property3.slice(0, -4)), childNode.getCacheKey(force));
  }
  return cyrb53(values);
}
function* getNodeChildren(node, toJSON = false) {
  for (const property3 in node) {
    if (property3.startsWith("_") === true) continue;
    const object = node[property3];
    if (Array.isArray(object) === true) {
      for (let i = 0; i < object.length; i++) {
        const child = object[i];
        if (child && (child.isNode === true || toJSON && typeof child.toJSON === "function")) {
          yield { property: property3, index: i, childNode: child };
        }
      }
    } else if (object && object.isNode === true) {
      yield { property: property3, childNode: object };
    } else if (typeof object === "object") {
      for (const subProperty in object) {
        const child = object[subProperty];
        if (child && (child.isNode === true || toJSON && typeof child.toJSON === "function")) {
          yield { property: property3, index: subProperty, childNode: child };
        }
      }
    }
  }
}
var typeFromLength = /* @__PURE__ */ new Map([
  [1, "float"],
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]);
function getTypeFromLength(length3) {
  return typeFromLength.get(length3);
}
function getLengthFromType(type) {
  if (/float|int|uint/.test(type)) return 1;
  if (/vec2/.test(type)) return 2;
  if (/vec3/.test(type)) return 3;
  if (/vec4/.test(type)) return 4;
  if (/mat3/.test(type)) return 9;
  if (/mat4/.test(type)) return 16;
  console.error("THREE.TSL: Unsupported type:", type);
}
function getValueType(value) {
  if (value === void 0 || value === null) return null;
  const typeOf = typeof value;
  if (value.isNode === true) {
    return "node";
  } else if (typeOf === "number") {
    return "float";
  } else if (typeOf === "boolean") {
    return "bool";
  } else if (typeOf === "string") {
    return "string";
  } else if (typeOf === "function") {
    return "shader";
  } else if (value.isVector2 === true) {
    return "vec2";
  } else if (value.isVector3 === true) {
    return "vec3";
  } else if (value.isVector4 === true) {
    return "vec4";
  } else if (value.isMatrix3 === true) {
    return "mat3";
  } else if (value.isMatrix4 === true) {
    return "mat4";
  } else if (value.isColor === true) {
    return "color";
  } else if (value instanceof ArrayBuffer) {
    return "ArrayBuffer";
  }
  return null;
}
function getValueFromType(type, ...params) {
  const last4 = type ? type.slice(-4) : void 0;
  if (params.length === 1) {
    if (last4 === "vec2") params = [params[0], params[0]];
    else if (last4 === "vec3") params = [params[0], params[0], params[0]];
    else if (last4 === "vec4") params = [params[0], params[0], params[0], params[0]];
  }
  if (type === "color") {
    return new Color(...params);
  } else if (last4 === "vec2") {
    return new Vector2(...params);
  } else if (last4 === "vec3") {
    return new Vector3(...params);
  } else if (last4 === "vec4") {
    return new Vector4(...params);
  } else if (last4 === "mat3") {
    return new Matrix3(...params);
  } else if (last4 === "mat4") {
    return new Matrix4(...params);
  } else if (type === "bool") {
    return params[0] || false;
  } else if (type === "float" || type === "int" || type === "uint") {
    return params[0] || 0;
  } else if (type === "string") {
    return params[0] || "";
  } else if (type === "ArrayBuffer") {
    return base64ToArrayBuffer(params[0]);
  }
  return null;
}
function arrayBufferToBase64(arrayBuffer3) {
  let chars = "";
  const array = new Uint8Array(arrayBuffer3);
  for (let i = 0; i < array.length; i++) {
    chars += String.fromCharCode(array[i]);
  }
  return btoa(chars);
}
function base64ToArrayBuffer(base64) {
  return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0)).buffer;
}
var NodeUtils = Object.freeze({
  __proto__: null,
  arrayBufferToBase64,
  base64ToArrayBuffer,
  getCacheKey: getCacheKey$1,
  getLengthFromType,
  getNodeChildren,
  getTypeFromLength,
  getValueFromType,
  getValueType,
  hash: hash$1,
  hashArray,
  hashString
});
var NodeShaderStage = {
  VERTEX: "vertex",
  FRAGMENT: "fragment"
};
var NodeUpdateType = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
};
var NodeType = {
  BOOLEAN: "bool",
  INTEGER: "int",
  FLOAT: "float",
  VECTOR2: "vec2",
  VECTOR3: "vec3",
  VECTOR4: "vec4",
  MATRIX2: "mat2",
  MATRIX3: "mat3",
  MATRIX4: "mat4"
};
var NodeAccess = {
  READ_ONLY: "readOnly",
  WRITE_ONLY: "writeOnly",
  READ_WRITE: "readWrite"
};
var defaultShaderStages = ["fragment", "vertex"];
var defaultBuildStages = ["setup", "analyze", "generate"];
var shaderStages = [...defaultShaderStages, "compute"];
var vectorComponents = ["x", "y", "z", "w"];
var _nodeId = 0;
var Node = class extends EventDispatcher {
  static get type() {
    return "Node";
  }
  constructor(nodeType = null) {
    super();
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType.NONE;
    this.updateBeforeType = NodeUpdateType.NONE;
    this.updateAfterType = NodeUpdateType.NONE;
    this.uuid = MathUtils.generateUUID();
    this.version = 0;
    this._cacheKey = null;
    this._cacheKeyVersion = 0;
    this.global = false;
    this.isNode = true;
    Object.defineProperty(this, "id", { value: _nodeId++ });
  }
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
    }
  }
  get type() {
    return this.constructor.type;
  }
  onUpdate(callback, updateType) {
    this.updateType = updateType;
    this.update = callback.bind(this.getSelf());
    return this;
  }
  onFrameUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.FRAME);
  }
  onRenderUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.RENDER);
  }
  onObjectUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.OBJECT);
  }
  onReference(callback) {
    this.updateReference = callback.bind(this.getSelf());
    return this;
  }
  getSelf() {
    return this.self || this;
  }
  updateReference() {
    return this;
  }
  isGlobal() {
    return this.global;
  }
  *getChildren() {
    for (const { childNode } of getNodeChildren(this)) {
      yield childNode;
    }
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  traverse(callback) {
    callback(this);
    for (const childNode of this.getChildren()) {
      childNode.traverse(callback);
    }
  }
  getCacheKey(force = false) {
    force = force || this.version !== this._cacheKeyVersion;
    if (force === true || this._cacheKey === null) {
      this._cacheKey = getCacheKey$1(this, force);
      this._cacheKeyVersion = this.version;
    }
    return this._cacheKey;
  }
  getScope() {
    return this;
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  getUpdateAfterType() {
    return this.updateAfterType;
  }
  getElementType(builder) {
    const type = this.getNodeType(builder);
    const elementType = builder.getElementType(type);
    return elementType;
  }
  getNodeType(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    if (nodeProperties.outputNode) {
      return nodeProperties.outputNode.getNodeType(builder);
    }
    return this.nodeType;
  }
  getShared(builder) {
    const hash3 = this.getHash(builder);
    const nodeFromHash = builder.getNodeFromHash(hash3);
    return nodeFromHash || this;
  }
  setup(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    let index = 0;
    for (const childNode of this.getChildren()) {
      nodeProperties["node" + index++] = childNode;
    }
    return null;
  }
  analyze(builder) {
    const usageCount = builder.increaseUsage(this);
    if (usageCount === 1) {
      const nodeProperties = builder.getNodeProperties(this);
      for (const childNode of Object.values(nodeProperties)) {
        if (childNode && childNode.isNode === true) {
          childNode.build(builder);
        }
      }
    }
  }
  generate(builder, output3) {
    const { outputNode } = builder.getNodeProperties(this);
    if (outputNode && outputNode.isNode === true) {
      return outputNode.build(builder, output3);
    }
  }
  updateBefore() {
    console.warn("Abstract function.");
  }
  updateAfter() {
    console.warn("Abstract function.");
  }
  update() {
    console.warn("Abstract function.");
  }
  build(builder, output3 = null) {
    const refNode = this.getShared(builder);
    if (this !== refNode) {
      return refNode.build(builder, output3);
    }
    builder.addNode(this);
    builder.addChain(this);
    let result = null;
    const buildStage = builder.getBuildStage();
    if (buildStage === "setup") {
      this.updateReference(builder);
      const properties = builder.getNodeProperties(this);
      if (properties.initialized !== true) {
        const stackNodesBeforeSetup = builder.stack.nodes.length;
        properties.initialized = true;
        properties.outputNode = this.setup(builder);
        if (properties.outputNode !== null && builder.stack.nodes.length !== stackNodesBeforeSetup) ;
        for (const childNode of Object.values(properties)) {
          if (childNode && childNode.isNode === true) {
            childNode.build(builder);
          }
        }
      }
    } else if (buildStage === "analyze") {
      this.analyze(builder);
    } else if (buildStage === "generate") {
      const isGenerateOnce = this.generate.length === 1;
      if (isGenerateOnce) {
        const type = this.getNodeType(builder);
        const nodeData = builder.getDataFromNode(this);
        result = nodeData.snippet;
        if (result === void 0) {
          result = this.generate(builder) || "";
          nodeData.snippet = result;
        } else if (nodeData.flowCodes !== void 0 && builder.context.nodeBlock !== void 0) {
          builder.addFlowCodeHierarchy(this, builder.context.nodeBlock);
        }
        result = builder.format(result, type, output3);
      } else {
        result = this.generate(builder, output3) || "";
      }
    }
    builder.removeChain(this);
    builder.addSequentialNode(this);
    return result;
  }
  getSerializeChildren() {
    return getNodeChildren(this);
  }
  serialize(json) {
    const nodeChildren = this.getSerializeChildren();
    const inputNodes = {};
    for (const { property: property3, index, childNode } of nodeChildren) {
      if (index !== void 0) {
        if (inputNodes[property3] === void 0) {
          inputNodes[property3] = Number.isInteger(index) ? [] : {};
        }
        inputNodes[property3][index] = childNode.toJSON(json.meta).uuid;
      } else {
        inputNodes[property3] = childNode.toJSON(json.meta).uuid;
      }
    }
    if (Object.keys(inputNodes).length > 0) {
      json.inputNodes = inputNodes;
    }
  }
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property3 in json.inputNodes) {
        if (Array.isArray(json.inputNodes[property3])) {
          const inputArray = [];
          for (const uuid of json.inputNodes[property3]) {
            inputArray.push(nodes[uuid]);
          }
          this[property3] = inputArray;
        } else if (typeof json.inputNodes[property3] === "object") {
          const inputObject = {};
          for (const subProperty in json.inputNodes[property3]) {
            const uuid = json.inputNodes[property3][subProperty];
            inputObject[subProperty] = nodes[uuid];
          }
          this[property3] = inputObject;
        } else {
          const uuid = json.inputNodes[property3];
          this[property3] = nodes[uuid];
        }
      }
    }
  }
  toJSON(meta) {
    const { uuid, type } = this;
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    let data = meta.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type,
        meta,
        metadata: {
          version: 4.6,
          type: "Node",
          generator: "Node.toJSON"
        }
      };
      if (isRoot !== true) meta.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache3) {
      const values = [];
      for (const key in cache3) {
        const data2 = cache3[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
      if (nodes.length > 0) data.nodes = nodes;
    }
    return data;
  }
};
var ArrayElementNode = class extends Node {
  static get type() {
    return "ArrayElementNode";
  }
  // @TODO: If extending from TempNode it breaks webgpu_compute
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
    this.isArrayElementNode = true;
  }
  getNodeType(builder) {
    return this.node.getElementType(builder);
  }
  generate(builder) {
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(builder, "uint");
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
};
var ConvertNode = class extends Node {
  static get type() {
    return "ConvertNode";
  }
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  getNodeType(builder) {
    const requestType = this.node.getNodeType(builder);
    let convertTo = null;
    for (const overloadingType of this.convertTo.split("|")) {
      if (convertTo === null || builder.getTypeLength(requestType) === builder.getTypeLength(overloadingType)) {
        convertTo = overloadingType;
      }
    }
    return convertTo;
  }
  serialize(data) {
    super.serialize(data);
    data.convertTo = this.convertTo;
  }
  deserialize(data) {
    super.deserialize(data);
    this.convertTo = data.convertTo;
  }
  generate(builder, output3) {
    const node = this.node;
    const type = this.getNodeType(builder);
    const snippet = node.build(builder, type);
    return builder.format(snippet, type, output3);
  }
};
var TempNode = class extends Node {
  static get type() {
    return "TempNode";
  }
  constructor(type) {
    super(type);
    this.isTempNode = true;
  }
  hasDependencies(builder) {
    return builder.getDataFromNode(this).usageCount > 1;
  }
  build(builder, output3) {
    const buildStage = builder.getBuildStage();
    if (buildStage === "generate") {
      const type = builder.getVectorType(this.getNodeType(builder, output3));
      const nodeData = builder.getDataFromNode(this);
      if (nodeData.propertyName !== void 0) {
        return builder.format(nodeData.propertyName, type, output3);
      } else if (type !== "void" && output3 !== "void" && this.hasDependencies(builder)) {
        const snippet = super.build(builder, type);
        const nodeVar = builder.getVarFromNode(this, null, type);
        const propertyName = builder.getPropertyName(nodeVar);
        builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
        return builder.format(nodeData.propertyName, type, output3);
      }
    }
    return super.build(builder, output3);
  }
};
var JoinNode = class extends TempNode {
  static get type() {
    return "JoinNode";
  }
  constructor(nodes = [], nodeType = null) {
    super(nodeType);
    this.nodes = nodes;
  }
  getNodeType(builder) {
    if (this.nodeType !== null) {
      return builder.getVectorType(this.nodeType);
    }
    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));
  }
  generate(builder, output3) {
    const type = this.getNodeType(builder);
    const nodes = this.nodes;
    const primitiveType = builder.getComponentType(type);
    const snippetValues = [];
    for (const input of nodes) {
      let inputSnippet = input.build(builder);
      const inputPrimitiveType = builder.getComponentType(input.getNodeType(builder));
      if (inputPrimitiveType !== primitiveType) {
        inputSnippet = builder.format(inputSnippet, inputPrimitiveType, primitiveType);
      }
      snippetValues.push(inputSnippet);
    }
    const snippet = `${builder.getType(type)}( ${snippetValues.join(", ")} )`;
    return builder.format(snippet, type, output3);
  }
};
var stringVectorComponents = vectorComponents.join("");
var SplitNode = class extends Node {
  static get type() {
    return "SplitNode";
  }
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
    this.isSplitNode = true;
  }
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c of this.components) {
      vectorLength = Math.max(vectorComponents.indexOf(c) + 1, vectorLength);
    }
    return vectorLength;
  }
  getComponentType(builder) {
    return builder.getComponentType(this.node.getNodeType(builder));
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.components.length, this.getComponentType(builder));
  }
  generate(builder, output3) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    let snippet = null;
    if (nodeTypeLength > 1) {
      let type = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type = builder.getTypeFromLength(this.getVectorLength(), this.getComponentType(builder));
      }
      const nodeSnippet = node.build(builder, type);
      if (this.components.length === nodeTypeLength && this.components === stringVectorComponents.slice(0, this.components.length)) {
        snippet = builder.format(nodeSnippet, type, output3);
      } else {
        snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output3);
      }
    } else {
      snippet = node.build(builder, output3);
    }
    return snippet;
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
};
var SetNode = class extends TempNode {
  static get type() {
    return "SetNode";
  }
  constructor(sourceNode, components, targetNode) {
    super();
    this.sourceNode = sourceNode;
    this.components = components;
    this.targetNode = targetNode;
  }
  getNodeType(builder) {
    return this.sourceNode.getNodeType(builder);
  }
  generate(builder) {
    const { sourceNode, components, targetNode } = this;
    const sourceType = this.getNodeType(builder);
    const targetType = builder.getTypeFromLength(components.length, targetNode.getNodeType(builder));
    const targetSnippet = targetNode.build(builder, targetType);
    const sourceSnippet = sourceNode.build(builder, sourceType);
    const length3 = builder.getTypeLength(sourceType);
    const snippetValues = [];
    for (let i = 0; i < length3; i++) {
      const component = vectorComponents[i];
      if (component === components[0]) {
        snippetValues.push(targetSnippet);
        i += components.length - 1;
      } else {
        snippetValues.push(sourceSnippet + "." + component);
      }
    }
    return `${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`;
  }
};
var FlipNode = class extends TempNode {
  static get type() {
    return "FlipNode";
  }
  constructor(sourceNode, components) {
    super();
    this.sourceNode = sourceNode;
    this.components = components;
  }
  getNodeType(builder) {
    return this.sourceNode.getNodeType(builder);
  }
  generate(builder) {
    const { components, sourceNode } = this;
    const sourceType = this.getNodeType(builder);
    const sourceSnippet = sourceNode.build(builder);
    const sourceCache = builder.getVarFromNode(this);
    const sourceProperty = builder.getPropertyName(sourceCache);
    builder.addLineFlowCode(sourceProperty + " = " + sourceSnippet, this);
    const length3 = builder.getTypeLength(sourceType);
    const snippetValues = [];
    let componentIndex = 0;
    for (let i = 0; i < length3; i++) {
      const component = vectorComponents[i];
      if (component === components[componentIndex]) {
        snippetValues.push("1.0 - " + (sourceProperty + "." + component));
        componentIndex++;
      } else {
        snippetValues.push(sourceProperty + "." + component);
      }
    }
    return `${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`;
  }
};
var InputNode = class extends Node {
  static get type() {
    return "InputNode";
  }
  constructor(value, nodeType = null) {
    super(nodeType);
    this.isInputNode = true;
    this.value = value;
    this.precision = null;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  setPrecision(precision) {
    this.precision = precision;
    return this;
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value;
    if (this.value && this.value.toArray) data.value = this.value.toArray();
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
    if (data.valueType === "ArrayBuffer") data.value = arrayBufferToBase64(data.value);
    data.precision = this.precision;
  }
  deserialize(data) {
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = Array.isArray(data.value) ? getValueFromType(data.valueType, ...data.value) : data.value;
    this.precision = data.precision || null;
    if (this.value && this.value.fromArray) this.value = this.value.fromArray(data.value);
  }
  generate() {
    console.warn("Abstract function.");
  }
};
var ConstNode = class extends InputNode {
  static get type() {
    return "ConstNode";
  }
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isConstNode = true;
  }
  generateConst(builder) {
    return builder.generateConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output3) {
    const type = this.getNodeType(builder);
    return builder.format(this.generateConst(builder), type, output3);
  }
};
var currentStack = null;
var NodeElements = /* @__PURE__ */ new Map();
function addMethodChaining(name, nodeElement) {
  if (NodeElements.has(name)) {
    console.warn(`Redefinition of method chaining ${name}`);
    return;
  }
  if (typeof nodeElement !== "function") throw new Error(`Node element ${name} is not a function`);
  NodeElements.set(name, nodeElement);
}
var parseSwizzle = (props) => props.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
var parseSwizzleAndSort = (props) => parseSwizzle(props).split("").sort().join("");
var shaderNodeHandler = {
  setup(NodeClosure, params) {
    const inputs = params.shift();
    return NodeClosure(nodeObjects(inputs), ...params);
  },
  get(node, prop, nodeObj) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (node.isStackNode !== true && prop === "assign") {
        return (...params) => {
          currentStack.assign(nodeObj, ...params);
          return nodeObj;
        };
      } else if (NodeElements.has(prop)) {
        const nodeElement = NodeElements.get(prop);
        return node.isStackNode ? (...params) => nodeObj.add(nodeElement(...params)) : (...params) => nodeElement(nodeObj, ...params);
      } else if (prop === "self") {
        return node;
      } else if (prop.endsWith("Assign") && NodeElements.has(prop.slice(0, prop.length - "Assign".length))) {
        const nodeElement = NodeElements.get(prop.slice(0, prop.length - "Assign".length));
        return node.isStackNode ? (...params) => nodeObj.assign(params[0], nodeElement(...params)) : (...params) => nodeObj.assign(nodeElement(nodeObj, ...params));
      } else if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
        prop = parseSwizzle(prop);
        return nodeObject(new SplitNode(nodeObj, prop));
      } else if (/^set[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {
        prop = parseSwizzleAndSort(prop.slice(3).toLowerCase());
        return (value) => nodeObject(new SetNode(node, prop, value));
      } else if (/^flip[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {
        prop = parseSwizzleAndSort(prop.slice(4).toLowerCase());
        return () => nodeObject(new FlipNode(nodeObject(node), prop));
      } else if (prop === "width" || prop === "height" || prop === "depth") {
        if (prop === "width") prop = "x";
        else if (prop === "height") prop = "y";
        else if (prop === "depth") prop = "z";
        return nodeObject(new SplitNode(node, prop));
      } else if (/^\d+$/.test(prop) === true) {
        return nodeObject(new ArrayElementNode(nodeObj, new ConstNode(Number(prop), "uint")));
      }
    }
    return Reflect.get(node, prop, nodeObj);
  },
  set(node, prop, value, nodeObj) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true || prop === "width" || prop === "height" || prop === "depth" || /^\d+$/.test(prop) === true) {
        nodeObj[prop].assign(value);
        return true;
      }
    }
    return Reflect.set(node, prop, value, nodeObj);
  }
};
var nodeObjectsCacheMap = /* @__PURE__ */ new WeakMap();
var nodeBuilderFunctionsCacheMap = /* @__PURE__ */ new WeakMap();
var ShaderNodeObject = function(obj, altType = null) {
  const type = getValueType(obj);
  if (type === "node") {
    let nodeObject3 = nodeObjectsCacheMap.get(obj);
    if (nodeObject3 === void 0) {
      nodeObject3 = new Proxy(obj, shaderNodeHandler);
      nodeObjectsCacheMap.set(obj, nodeObject3);
      nodeObjectsCacheMap.set(nodeObject3, nodeObject3);
    }
    return nodeObject3;
  } else if (altType === null && (type === "float" || type === "boolean") || type && type !== "shader" && type !== "string") {
    return nodeObject(getConstNode(obj, altType));
  } else if (type === "shader") {
    return Fn(obj);
  }
  return obj;
};
var ShaderNodeObjects = function(objects, altType = null) {
  for (const name in objects) {
    objects[name] = nodeObject(objects[name], altType);
  }
  return objects;
};
var ShaderNodeArray = function(array, altType = null) {
  const len = array.length;
  for (let i = 0; i < len; i++) {
    array[i] = nodeObject(array[i], altType);
  }
  return array;
};
var ShaderNodeProxy = function(NodeClass, scope = null, factor = null, settings = null) {
  const assignNode = (node) => nodeObject(settings !== null ? Object.assign(node, settings) : node);
  if (scope === null) {
    return (...params) => {
      return assignNode(new NodeClass(...nodeArray(params)));
    };
  } else if (factor !== null) {
    factor = nodeObject(factor);
    return (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(params), factor));
    };
  } else {
    return (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(params)));
    };
  }
};
var ShaderNodeImmutable = function(NodeClass, ...params) {
  return nodeObject(new NodeClass(...nodeArray(params)));
};
var ShaderCallNodeInternal = class extends Node {
  constructor(shaderNode, inputNodes) {
    super();
    this.shaderNode = shaderNode;
    this.inputNodes = inputNodes;
  }
  getNodeType(builder) {
    return this.shaderNode.nodeType || this.getOutputNode(builder).getNodeType(builder);
  }
  call(builder) {
    const { shaderNode, inputNodes } = this;
    const properties = builder.getNodeProperties(shaderNode);
    if (properties.onceOutput) return properties.onceOutput;
    let result = null;
    if (shaderNode.layout) {
      let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get(builder.constructor);
      if (functionNodesCacheMap === void 0) {
        functionNodesCacheMap = /* @__PURE__ */ new WeakMap();
        nodeBuilderFunctionsCacheMap.set(builder.constructor, functionNodesCacheMap);
      }
      let functionNode = functionNodesCacheMap.get(shaderNode);
      if (functionNode === void 0) {
        functionNode = nodeObject(builder.buildFunctionNode(shaderNode));
        functionNodesCacheMap.set(shaderNode, functionNode);
      }
      if (builder.currentFunctionNode !== null) {
        builder.currentFunctionNode.includes.push(functionNode);
      }
      result = nodeObject(functionNode.call(inputNodes));
    } else {
      const jsFunc = shaderNode.jsFunc;
      const outputNode = inputNodes !== null ? jsFunc(inputNodes, builder) : jsFunc(builder);
      result = nodeObject(outputNode);
    }
    if (shaderNode.once) {
      properties.onceOutput = result;
    }
    return result;
  }
  getOutputNode(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.outputNode === null) {
      properties.outputNode = this.setupOutput(builder);
    }
    return properties.outputNode;
  }
  setup(builder) {
    return this.getOutputNode(builder);
  }
  setupOutput(builder) {
    builder.addStack();
    builder.stack.outputNode = this.call(builder);
    return builder.removeStack();
  }
  generate(builder, output3) {
    const outputNode = this.getOutputNode(builder);
    return outputNode.build(builder, output3);
  }
};
var ShaderNodeInternal = class extends Node {
  constructor(jsFunc, nodeType) {
    super(nodeType);
    this.jsFunc = jsFunc;
    this.layout = null;
    this.global = true;
    this.once = false;
  }
  setLayout(layout) {
    this.layout = layout;
    return this;
  }
  call(inputs = null) {
    nodeObjects(inputs);
    return nodeObject(new ShaderCallNodeInternal(this, inputs));
  }
  setup() {
    return this.call();
  }
};
var bools = [false, true];
var uints = [0, 1, 2, 3];
var ints = [-1, -2];
var floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
var boolsCacheMap = /* @__PURE__ */ new Map();
for (const bool3 of bools) boolsCacheMap.set(bool3, new ConstNode(bool3));
var uintsCacheMap = /* @__PURE__ */ new Map();
for (const uint3 of uints) uintsCacheMap.set(uint3, new ConstNode(uint3, "uint"));
var intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode(el.value, "int")));
for (const int3 of ints) intsCacheMap.set(int3, new ConstNode(int3, "int"));
var floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode(el.value)));
for (const float3 of floats) floatsCacheMap.set(float3, new ConstNode(float3));
for (const float3 of floats) floatsCacheMap.set(-float3, new ConstNode(-float3));
var cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };
var constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
var getConstNode = (value, type) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode(value, type);
  }
};
var safeGetNodeType = (node) => {
  try {
    return node.getNodeType();
  } catch (_) {
    return void 0;
  }
};
var ConvertType = function(type, cacheMap = null) {
  return (...params) => {
    if (params.length === 0 || !["bool", "float", "int", "uint"].includes(type) && params.every((param) => typeof param !== "object")) {
      params = [getValueFromType(type, ...params)];
    }
    if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
      return nodeObject(cacheMap.get(params[0]));
    }
    if (params.length === 1) {
      const node = getConstNode(params[0], type);
      if (safeGetNodeType(node) === type) return nodeObject(node);
      return nodeObject(new ConvertNode(node, type));
    }
    const nodes = params.map((param) => getConstNode(param));
    return nodeObject(new JoinNode(nodes, type));
  };
};
var defined = (v) => typeof v === "object" && v !== null ? v.value : v;
var getConstNodeType = (value) => value !== void 0 && value !== null ? value.nodeType || value.convertTo || (typeof value === "string" ? value : null) : null;
function ShaderNode(jsFunc, nodeType) {
  return new Proxy(new ShaderNodeInternal(jsFunc, nodeType), shaderNodeHandler);
}
var nodeObject = (val, altType = null) => (
  /* new */
  ShaderNodeObject(val, altType)
);
var nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);
var nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);
var nodeProxy = (...params) => new ShaderNodeProxy(...params);
var nodeImmutable = (...params) => new ShaderNodeImmutable(...params);
var Fn = (jsFunc, nodeType) => {
  const shaderNode = new ShaderNode(jsFunc, nodeType);
  const fn = (...params) => {
    let inputs;
    nodeObjects(params);
    if (params[0] && params[0].isNode) {
      inputs = [...params];
    } else {
      inputs = params[0];
    }
    return shaderNode.call(inputs);
  };
  fn.shaderNode = shaderNode;
  fn.setLayout = (layout) => {
    shaderNode.setLayout(layout);
    return fn;
  };
  fn.once = () => {
    shaderNode.once = true;
    return fn;
  };
  return fn;
};
var tslFn = (...params) => {
  console.warn("TSL.ShaderNode: tslFn() has been renamed to Fn().");
  return Fn(...params);
};
addMethodChaining("toGlobal", (node) => {
  node.global = true;
  return node;
});
var setCurrentStack = (stack3) => {
  currentStack = stack3;
};
var getCurrentStack = () => currentStack;
var If = (...params) => currentStack.If(...params);
function append(node) {
  if (currentStack) currentStack.add(node);
  return node;
}
addMethodChaining("append", append);
var color = new ConvertType("color");
var float = new ConvertType("float", cacheMaps.float);
var int = new ConvertType("int", cacheMaps.ints);
var uint = new ConvertType("uint", cacheMaps.uint);
var bool = new ConvertType("bool", cacheMaps.bool);
var vec2 = new ConvertType("vec2");
var ivec2 = new ConvertType("ivec2");
var uvec2 = new ConvertType("uvec2");
var bvec2 = new ConvertType("bvec2");
var vec3 = new ConvertType("vec3");
var ivec3 = new ConvertType("ivec3");
var uvec3 = new ConvertType("uvec3");
var bvec3 = new ConvertType("bvec3");
var vec4 = new ConvertType("vec4");
var ivec4 = new ConvertType("ivec4");
var uvec4 = new ConvertType("uvec4");
var bvec4 = new ConvertType("bvec4");
var mat2 = new ConvertType("mat2");
var mat3 = new ConvertType("mat3");
var mat4 = new ConvertType("mat4");
var string = (value = "") => nodeObject(new ConstNode(value, "string"));
var arrayBuffer = (value) => nodeObject(new ConstNode(value, "ArrayBuffer"));
addMethodChaining("toColor", color);
addMethodChaining("toFloat", float);
addMethodChaining("toInt", int);
addMethodChaining("toUint", uint);
addMethodChaining("toBool", bool);
addMethodChaining("toVec2", vec2);
addMethodChaining("toIVec2", ivec2);
addMethodChaining("toUVec2", uvec2);
addMethodChaining("toBVec2", bvec2);
addMethodChaining("toVec3", vec3);
addMethodChaining("toIVec3", ivec3);
addMethodChaining("toUVec3", uvec3);
addMethodChaining("toBVec3", bvec3);
addMethodChaining("toVec4", vec4);
addMethodChaining("toIVec4", ivec4);
addMethodChaining("toUVec4", uvec4);
addMethodChaining("toBVec4", bvec4);
addMethodChaining("toMat2", mat2);
addMethodChaining("toMat3", mat3);
addMethodChaining("toMat4", mat4);
var element = nodeProxy(ArrayElementNode);
var convert = (node, types) => nodeObject(new ConvertNode(nodeObject(node), types));
var split = (node, channels) => nodeObject(new SplitNode(nodeObject(node), channels));
addMethodChaining("element", element);
addMethodChaining("convert", convert);
var UniformGroupNode = class extends Node {
  static get type() {
    return "UniformGroupNode";
  }
  constructor(name, shared = false, order = 1) {
    super("string");
    this.name = name;
    this.version = 0;
    this.shared = shared;
    this.order = order;
    this.isUniformGroup = true;
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  serialize(data) {
    super.serialize(data);
    data.name = this.name;
    data.version = this.version;
    data.shared = this.shared;
  }
  deserialize(data) {
    super.deserialize(data);
    this.name = data.name;
    this.version = data.version;
    this.shared = data.shared;
  }
};
var uniformGroup = (name) => new UniformGroupNode(name);
var sharedUniformGroup = (name, order = 0) => new UniformGroupNode(name, true, order);
var frameGroup = sharedUniformGroup("frame");
var renderGroup = sharedUniformGroup("render");
var objectGroup = uniformGroup("object");
var UniformNode = class extends InputNode {
  static get type() {
    return "UniformNode";
  }
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isUniformNode = true;
    this.name = "";
    this.groupNode = objectGroup;
  }
  label(name) {
    this.name = name;
    return this;
  }
  setGroup(group) {
    this.groupNode = group;
    return this;
  }
  getGroup() {
    return this.groupNode;
  }
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  onUpdate(callback, updateType) {
    const self2 = this.getSelf();
    callback = callback.bind(self2);
    return super.onUpdate((frame) => {
      const value = callback(frame, self2);
      if (value !== void 0) {
        this.value = value;
      }
    }, updateType);
  }
  generate(builder, output3) {
    const type = this.getNodeType(builder);
    const hash3 = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash3);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash3);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.label);
    const propertyName = builder.getPropertyName(nodeUniform);
    if (builder.context.label !== void 0) delete builder.context.label;
    return builder.format(propertyName, type, output3);
  }
};
var uniform = (arg1, arg2) => {
  const nodeType = getConstNodeType(arg2 || arg1);
  const value = arg1 && arg1.isNode === true ? arg1.node && arg1.node.value || arg1.value : arg1;
  return nodeObject(new UniformNode(value, nodeType));
};
var PropertyNode = class extends Node {
  static get type() {
    return "PropertyNode";
  }
  constructor(nodeType, name = null, varying3 = false) {
    super(nodeType);
    this.name = name;
    this.varying = varying3;
    this.isPropertyNode = true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  isGlobal() {
    return true;
  }
  generate(builder) {
    let nodeVar;
    if (this.varying === true) {
      nodeVar = builder.getVaryingFromNode(this, this.name);
      nodeVar.needsInterpolation = true;
    } else {
      nodeVar = builder.getVarFromNode(this, this.name);
    }
    return builder.getPropertyName(nodeVar);
  }
};
var property = (type, name) => nodeObject(new PropertyNode(type, name));
var varyingProperty = (type, name) => nodeObject(new PropertyNode(type, name, true));
var diffuseColor = nodeImmutable(PropertyNode, "vec4", "DiffuseColor");
var emissive = nodeImmutable(PropertyNode, "vec3", "EmissiveColor");
var roughness = nodeImmutable(PropertyNode, "float", "Roughness");
var metalness = nodeImmutable(PropertyNode, "float", "Metalness");
var clearcoat = nodeImmutable(PropertyNode, "float", "Clearcoat");
var clearcoatRoughness = nodeImmutable(PropertyNode, "float", "ClearcoatRoughness");
var sheen = nodeImmutable(PropertyNode, "vec3", "Sheen");
var sheenRoughness = nodeImmutable(PropertyNode, "float", "SheenRoughness");
var iridescence = nodeImmutable(PropertyNode, "float", "Iridescence");
var iridescenceIOR = nodeImmutable(PropertyNode, "float", "IridescenceIOR");
var iridescenceThickness = nodeImmutable(PropertyNode, "float", "IridescenceThickness");
var alphaT = nodeImmutable(PropertyNode, "float", "AlphaT");
var anisotropy = nodeImmutable(PropertyNode, "float", "Anisotropy");
var anisotropyT = nodeImmutable(PropertyNode, "vec3", "AnisotropyT");
var anisotropyB = nodeImmutable(PropertyNode, "vec3", "AnisotropyB");
var specularColor = nodeImmutable(PropertyNode, "color", "SpecularColor");
var specularF90 = nodeImmutable(PropertyNode, "float", "SpecularF90");
var shininess = nodeImmutable(PropertyNode, "float", "Shininess");
var output = nodeImmutable(PropertyNode, "vec4", "Output");
var dashSize = nodeImmutable(PropertyNode, "float", "dashSize");
var gapSize = nodeImmutable(PropertyNode, "float", "gapSize");
var pointWidth = nodeImmutable(PropertyNode, "float", "pointWidth");
var ior = nodeImmutable(PropertyNode, "float", "IOR");
var transmission = nodeImmutable(PropertyNode, "float", "Transmission");
var thickness = nodeImmutable(PropertyNode, "float", "Thickness");
var attenuationDistance = nodeImmutable(PropertyNode, "float", "AttenuationDistance");
var attenuationColor = nodeImmutable(PropertyNode, "color", "AttenuationColor");
var dispersion = nodeImmutable(PropertyNode, "float", "Dispersion");
var AssignNode = class extends TempNode {
  static get type() {
    return "AssignNode";
  }
  constructor(targetNode, sourceNode) {
    super();
    this.targetNode = targetNode;
    this.sourceNode = sourceNode;
  }
  hasDependencies() {
    return false;
  }
  getNodeType(builder, output3) {
    return output3 !== "void" ? this.targetNode.getNodeType(builder) : "void";
  }
  needsSplitAssign(builder) {
    const { targetNode } = this;
    if (builder.isAvailable("swizzleAssign") === false && targetNode.isSplitNode && targetNode.components.length > 1) {
      const targetLength = builder.getTypeLength(targetNode.node.getNodeType(builder));
      const assignDiferentVector = vectorComponents.join("").slice(0, targetLength) !== targetNode.components;
      return assignDiferentVector;
    }
    return false;
  }
  generate(builder, output3) {
    const { targetNode, sourceNode } = this;
    const needsSplitAssign = this.needsSplitAssign(builder);
    const targetType = targetNode.getNodeType(builder);
    const target = targetNode.context({ assign: true }).build(builder);
    const source = sourceNode.build(builder, targetType);
    const sourceType = sourceNode.getNodeType(builder);
    const nodeData = builder.getDataFromNode(this);
    let snippet;
    if (nodeData.initialized === true) {
      if (output3 !== "void") {
        snippet = target;
      }
    } else if (needsSplitAssign) {
      const sourceVar = builder.getVarFromNode(this, null, targetType);
      const sourceProperty = builder.getPropertyName(sourceVar);
      builder.addLineFlowCode(`${sourceProperty} = ${source}`, this);
      const targetRoot = targetNode.node.context({ assign: true }).build(builder);
      for (let i = 0; i < targetNode.components.length; i++) {
        const component = targetNode.components[i];
        builder.addLineFlowCode(`${targetRoot}.${component} = ${sourceProperty}[ ${i} ]`, this);
      }
      if (output3 !== "void") {
        snippet = target;
      }
    } else {
      snippet = `${target} = ${source}`;
      if (output3 === "void" || sourceType === "void") {
        builder.addLineFlowCode(snippet, this);
        if (output3 !== "void") {
          snippet = target;
        }
      }
    }
    nodeData.initialized = true;
    return builder.format(snippet, targetType, output3);
  }
};
var assign = nodeProxy(AssignNode);
addMethodChaining("assign", assign);
var FunctionCallNode = class extends TempNode {
  static get type() {
    return "FunctionCallNode";
  }
  constructor(functionNode = null, parameters = {}) {
    super();
    this.functionNode = functionNode;
    this.parameters = parameters;
  }
  setParameters(parameters) {
    this.parameters = parameters;
    return this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(builder) {
    return this.functionNode.getNodeType(builder);
  }
  generate(builder) {
    const params = [];
    const functionNode = this.functionNode;
    const inputs = functionNode.getInputs(builder);
    const parameters = this.parameters;
    const generateInput = (node, inputNode) => {
      const type = inputNode.type;
      const pointer = type === "pointer";
      let output3;
      if (pointer) output3 = "&" + node.build(builder);
      else output3 = node.build(builder, type);
      return output3;
    };
    if (Array.isArray(parameters)) {
      for (let i = 0; i < parameters.length; i++) {
        params.push(generateInput(parameters[i], inputs[i]));
      }
    } else {
      for (const inputNode of inputs) {
        const node = parameters[inputNode.name];
        if (node !== void 0) {
          params.push(generateInput(node, inputNode));
        } else {
          throw new Error(`FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.`);
        }
      }
    }
    const functionName = functionNode.build(builder, "property");
    return `${functionName}( ${params.join(", ")} )`;
  }
};
var call = (func, ...params) => {
  params = params.length > 1 || params[0] && params[0].isNode === true ? nodeArray(params) : nodeObjects(params[0]);
  return nodeObject(new FunctionCallNode(nodeObject(func), params));
};
addMethodChaining("call", call);
var OperatorNode = class _OperatorNode extends TempNode {
  static get type() {
    return "OperatorNode";
  }
  constructor(op, aNode, bNode, ...params) {
    super();
    if (params.length > 0) {
      let finalOp = new _OperatorNode(op, aNode, bNode);
      for (let i = 0; i < params.length - 1; i++) {
        finalOp = new _OperatorNode(op, finalOp, params[i]);
      }
      aNode = finalOp;
      bNode = params[params.length - 1];
    }
    this.op = op;
    this.aNode = aNode;
    this.bNode = bNode;
  }
  getNodeType(builder, output3) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = typeof bNode !== "undefined" ? bNode.getNodeType(builder) : null;
    if (typeA === "void" || typeB === "void") {
      return "void";
    } else if (op === "%") {
      return typeA;
    } else if (op === "~" || op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return builder.getIntegerType(typeA);
    } else if (op === "!" || op === "==" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = output3 ? builder.getTypeLength(output3) : Math.max(builder.getTypeLength(typeA), builder.getTypeLength(typeB));
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (typeA === "float" && builder.isMatrix(typeB)) {
        return typeB;
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        return builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        return builder.getVectorFromMatrix(typeB);
      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output3) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const type = this.getNodeType(builder, output3);
    let typeA = null;
    let typeB = null;
    if (type !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = typeof bNode !== "undefined" ? bNode.getNodeType(builder) : null;
      if (op === "<" || op === ">" || op === "<=" || op === ">=" || op === "==") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else if (typeA !== typeB) {
          typeA = typeB = "float";
        }
      } else if (op === ">>" || op === "<<") {
        typeA = type;
        typeB = builder.changeComponentType(typeB, "uint");
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        typeB = builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        typeA = builder.getVectorFromMatrix(typeB);
      } else {
        typeA = typeB = type;
      }
    } else {
      typeA = typeB = type;
    }
    const a = aNode.build(builder, typeA);
    const b = typeof bNode !== "undefined" ? bNode.build(builder, typeB) : null;
    const outputLength = builder.getTypeLength(output3);
    const fnOpSnippet = builder.getFunctionOperator(op);
    if (output3 !== "void") {
      if (op === "<" && outputLength > 1) {
        if (builder.useComparisonMethod) {
          return builder.format(`${builder.getMethod("lessThan", output3)}( ${a}, ${b} )`, type, output3);
        } else {
          return builder.format(`( ${a} < ${b} )`, type, output3);
        }
      } else if (op === "<=" && outputLength > 1) {
        if (builder.useComparisonMethod) {
          return builder.format(`${builder.getMethod("lessThanEqual", output3)}( ${a}, ${b} )`, type, output3);
        } else {
          return builder.format(`( ${a} <= ${b} )`, type, output3);
        }
      } else if (op === ">" && outputLength > 1) {
        if (builder.useComparisonMethod) {
          return builder.format(`${builder.getMethod("greaterThan", output3)}( ${a}, ${b} )`, type, output3);
        } else {
          return builder.format(`( ${a} > ${b} )`, type, output3);
        }
      } else if (op === ">=" && outputLength > 1) {
        if (builder.useComparisonMethod) {
          return builder.format(`${builder.getMethod("greaterThanEqual", output3)}( ${a}, ${b} )`, type, output3);
        } else {
          return builder.format(`( ${a} >= ${b} )`, type, output3);
        }
      } else if (op === "!" || op === "~") {
        return builder.format(`(${op}${a})`, typeA, output3);
      } else if (fnOpSnippet) {
        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output3);
      } else {
        return builder.format(`( ${a} ${op} ${b} )`, type, output3);
      }
    } else if (typeA !== "void") {
      if (fnOpSnippet) {
        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output3);
      } else {
        return builder.format(`${a} ${op} ${b}`, type, output3);
      }
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
};
var add = nodeProxy(OperatorNode, "+");
var sub = nodeProxy(OperatorNode, "-");
var mul = nodeProxy(OperatorNode, "*");
var div = nodeProxy(OperatorNode, "/");
var modInt = nodeProxy(OperatorNode, "%");
var equal = nodeProxy(OperatorNode, "==");
var notEqual = nodeProxy(OperatorNode, "!=");
var lessThan = nodeProxy(OperatorNode, "<");
var greaterThan = nodeProxy(OperatorNode, ">");
var lessThanEqual = nodeProxy(OperatorNode, "<=");
var greaterThanEqual = nodeProxy(OperatorNode, ">=");
var and = nodeProxy(OperatorNode, "&&");
var or = nodeProxy(OperatorNode, "||");
var not = nodeProxy(OperatorNode, "!");
var xor = nodeProxy(OperatorNode, "^^");
var bitAnd = nodeProxy(OperatorNode, "&");
var bitNot = nodeProxy(OperatorNode, "~");
var bitOr = nodeProxy(OperatorNode, "|");
var bitXor = nodeProxy(OperatorNode, "^");
var shiftLeft = nodeProxy(OperatorNode, "<<");
var shiftRight = nodeProxy(OperatorNode, ">>");
addMethodChaining("add", add);
addMethodChaining("sub", sub);
addMethodChaining("mul", mul);
addMethodChaining("div", div);
addMethodChaining("modInt", modInt);
addMethodChaining("equal", equal);
addMethodChaining("notEqual", notEqual);
addMethodChaining("lessThan", lessThan);
addMethodChaining("greaterThan", greaterThan);
addMethodChaining("lessThanEqual", lessThanEqual);
addMethodChaining("greaterThanEqual", greaterThanEqual);
addMethodChaining("and", and);
addMethodChaining("or", or);
addMethodChaining("not", not);
addMethodChaining("xor", xor);
addMethodChaining("bitAnd", bitAnd);
addMethodChaining("bitNot", bitNot);
addMethodChaining("bitOr", bitOr);
addMethodChaining("bitXor", bitXor);
addMethodChaining("shiftLeft", shiftLeft);
addMethodChaining("shiftRight", shiftRight);
var remainder = (...params) => {
  console.warn("TSL.OperatorNode: .remainder() has been renamed to .modInt().");
  return modInt(...params);
};
addMethodChaining("remainder", remainder);
var MathNode = class _MathNode extends TempNode {
  static get type() {
    return "MathNode";
  }
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
  }
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  getNodeType(builder) {
    const method = this.method;
    if (method === _MathNode.LENGTH || method === _MathNode.DISTANCE || method === _MathNode.DOT) {
      return "float";
    } else if (method === _MathNode.CROSS) {
      return "vec3";
    } else if (method === _MathNode.ALL) {
      return "bool";
    } else if (method === _MathNode.EQUALS) {
      return builder.changeComponentType(this.aNode.getNodeType(builder), "bool");
    } else if (method === _MathNode.MOD) {
      return this.aNode.getNodeType(builder);
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output3) {
    const method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.aNode;
    const b = this.bNode;
    const c = this.cNode;
    const isWebGL = builder.renderer.isWebGLRenderer === true;
    if (method === _MathNode.TRANSFORM_DIRECTION) {
      let tA = a;
      let tB = b;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = vec4(vec3(tB), 0);
      } else {
        tA = vec4(vec3(tA), 0);
      }
      const mulNode = mul(tA, tB).xyz;
      return normalize(mulNode).build(builder, output3);
    } else if (method === _MathNode.NEGATE) {
      return builder.format("( - " + a.build(builder, inputType) + " )", type, output3);
    } else if (method === _MathNode.ONE_MINUS) {
      return sub(1, a).build(builder, output3);
    } else if (method === _MathNode.RECIPROCAL) {
      return div(1, a).build(builder, output3);
    } else if (method === _MathNode.DIFFERENCE) {
      return abs(sub(a, b)).build(builder, output3);
    } else {
      const params = [];
      if (method === _MathNode.CROSS || method === _MathNode.MOD) {
        params.push(
          a.build(builder, type),
          b.build(builder, type)
        );
      } else if (isWebGL && method === _MathNode.STEP) {
        params.push(
          a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? "float" : inputType),
          b.build(builder, inputType)
        );
      } else if (isWebGL && (method === _MathNode.MIN || method === _MathNode.MAX) || method === _MathNode.MOD) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else if (method === _MathNode.REFRACT) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, "float")
        );
      } else if (method === _MathNode.MIX) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else {
        params.push(a.build(builder, inputType));
        if (b !== null) params.push(b.build(builder, inputType));
        if (c !== null) params.push(c.build(builder, inputType));
      }
      return builder.format(`${builder.getMethod(method, type)}( ${params.join(", ")} )`, type, output3);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
MathNode.ALL = "all";
MathNode.ANY = "any";
MathNode.EQUALS = "equals";
MathNode.RADIANS = "radians";
MathNode.DEGREES = "degrees";
MathNode.EXP = "exp";
MathNode.EXP2 = "exp2";
MathNode.LOG = "log";
MathNode.LOG2 = "log2";
MathNode.SQRT = "sqrt";
MathNode.INVERSE_SQRT = "inversesqrt";
MathNode.FLOOR = "floor";
MathNode.CEIL = "ceil";
MathNode.NORMALIZE = "normalize";
MathNode.FRACT = "fract";
MathNode.SIN = "sin";
MathNode.COS = "cos";
MathNode.TAN = "tan";
MathNode.ASIN = "asin";
MathNode.ACOS = "acos";
MathNode.ATAN = "atan";
MathNode.ABS = "abs";
MathNode.SIGN = "sign";
MathNode.LENGTH = "length";
MathNode.NEGATE = "negate";
MathNode.ONE_MINUS = "oneMinus";
MathNode.DFDX = "dFdx";
MathNode.DFDY = "dFdy";
MathNode.ROUND = "round";
MathNode.RECIPROCAL = "reciprocal";
MathNode.TRUNC = "trunc";
MathNode.FWIDTH = "fwidth";
MathNode.BITCAST = "bitcast";
MathNode.TRANSPOSE = "transpose";
MathNode.ATAN2 = "atan2";
MathNode.MIN = "min";
MathNode.MAX = "max";
MathNode.MOD = "mod";
MathNode.STEP = "step";
MathNode.REFLECT = "reflect";
MathNode.DISTANCE = "distance";
MathNode.DIFFERENCE = "difference";
MathNode.DOT = "dot";
MathNode.CROSS = "cross";
MathNode.POW = "pow";
MathNode.TRANSFORM_DIRECTION = "transformDirection";
MathNode.MIX = "mix";
MathNode.CLAMP = "clamp";
MathNode.REFRACT = "refract";
MathNode.SMOOTHSTEP = "smoothstep";
MathNode.FACEFORWARD = "faceforward";
var EPSILON = float(1e-6);
var INFINITY = float(1e6);
var PI = float(Math.PI);
var PI2 = float(Math.PI * 2);
var all = nodeProxy(MathNode, MathNode.ALL);
var any = nodeProxy(MathNode, MathNode.ANY);
var equals = nodeProxy(MathNode, MathNode.EQUALS);
var radians = nodeProxy(MathNode, MathNode.RADIANS);
var degrees = nodeProxy(MathNode, MathNode.DEGREES);
var exp = nodeProxy(MathNode, MathNode.EXP);
var exp2 = nodeProxy(MathNode, MathNode.EXP2);
var log = nodeProxy(MathNode, MathNode.LOG);
var log2 = nodeProxy(MathNode, MathNode.LOG2);
var sqrt = nodeProxy(MathNode, MathNode.SQRT);
var inverseSqrt = nodeProxy(MathNode, MathNode.INVERSE_SQRT);
var floor = nodeProxy(MathNode, MathNode.FLOOR);
var ceil = nodeProxy(MathNode, MathNode.CEIL);
var normalize = nodeProxy(MathNode, MathNode.NORMALIZE);
var fract = nodeProxy(MathNode, MathNode.FRACT);
var sin = nodeProxy(MathNode, MathNode.SIN);
var cos = nodeProxy(MathNode, MathNode.COS);
var tan = nodeProxy(MathNode, MathNode.TAN);
var asin = nodeProxy(MathNode, MathNode.ASIN);
var acos = nodeProxy(MathNode, MathNode.ACOS);
var atan = nodeProxy(MathNode, MathNode.ATAN);
var abs = nodeProxy(MathNode, MathNode.ABS);
var sign = nodeProxy(MathNode, MathNode.SIGN);
var length = nodeProxy(MathNode, MathNode.LENGTH);
var negate = nodeProxy(MathNode, MathNode.NEGATE);
var oneMinus = nodeProxy(MathNode, MathNode.ONE_MINUS);
var dFdx = nodeProxy(MathNode, MathNode.DFDX);
var dFdy = nodeProxy(MathNode, MathNode.DFDY);
var round = nodeProxy(MathNode, MathNode.ROUND);
var reciprocal = nodeProxy(MathNode, MathNode.RECIPROCAL);
var trunc = nodeProxy(MathNode, MathNode.TRUNC);
var fwidth = nodeProxy(MathNode, MathNode.FWIDTH);
var bitcast = nodeProxy(MathNode, MathNode.BITCAST);
var transpose = nodeProxy(MathNode, MathNode.TRANSPOSE);
var atan2 = nodeProxy(MathNode, MathNode.ATAN2);
var min$1 = nodeProxy(MathNode, MathNode.MIN);
var max$1 = nodeProxy(MathNode, MathNode.MAX);
var mod = nodeProxy(MathNode, MathNode.MOD);
var step = nodeProxy(MathNode, MathNode.STEP);
var reflect = nodeProxy(MathNode, MathNode.REFLECT);
var distance = nodeProxy(MathNode, MathNode.DISTANCE);
var difference = nodeProxy(MathNode, MathNode.DIFFERENCE);
var dot = nodeProxy(MathNode, MathNode.DOT);
var cross = nodeProxy(MathNode, MathNode.CROSS);
var pow = nodeProxy(MathNode, MathNode.POW);
var pow2 = nodeProxy(MathNode, MathNode.POW, 2);
var pow3 = nodeProxy(MathNode, MathNode.POW, 3);
var pow4 = nodeProxy(MathNode, MathNode.POW, 4);
var transformDirection = nodeProxy(MathNode, MathNode.TRANSFORM_DIRECTION);
var cbrt = (a) => mul(sign(a), pow(abs(a), 1 / 3));
var lengthSq = (a) => dot(a, a);
var mix = nodeProxy(MathNode, MathNode.MIX);
var clamp = (value, low = 0, high = 1) => nodeObject(new MathNode(MathNode.CLAMP, nodeObject(value), nodeObject(low), nodeObject(high)));
var saturate = (value) => clamp(value);
var refract = nodeProxy(MathNode, MathNode.REFRACT);
var smoothstep = nodeProxy(MathNode, MathNode.SMOOTHSTEP);
var faceForward = nodeProxy(MathNode, MathNode.FACEFORWARD);
var rand = Fn(([uv3]) => {
  const a = 12.9898, b = 78.233, c = 43758.5453;
  const dt = dot(uv3.xy, vec2(a, b)), sn = mod(dt, PI);
  return fract(sin(sn).mul(c));
});
var mixElement = (t, e1, e2) => mix(e1, e2, t);
var smoothstepElement = (x, low, high) => smoothstep(low, high, x);
addMethodChaining("all", all);
addMethodChaining("any", any);
addMethodChaining("equals", equals);
addMethodChaining("radians", radians);
addMethodChaining("degrees", degrees);
addMethodChaining("exp", exp);
addMethodChaining("exp2", exp2);
addMethodChaining("log", log);
addMethodChaining("log2", log2);
addMethodChaining("sqrt", sqrt);
addMethodChaining("inverseSqrt", inverseSqrt);
addMethodChaining("floor", floor);
addMethodChaining("ceil", ceil);
addMethodChaining("normalize", normalize);
addMethodChaining("fract", fract);
addMethodChaining("sin", sin);
addMethodChaining("cos", cos);
addMethodChaining("tan", tan);
addMethodChaining("asin", asin);
addMethodChaining("acos", acos);
addMethodChaining("atan", atan);
addMethodChaining("abs", abs);
addMethodChaining("sign", sign);
addMethodChaining("length", length);
addMethodChaining("lengthSq", lengthSq);
addMethodChaining("negate", negate);
addMethodChaining("oneMinus", oneMinus);
addMethodChaining("dFdx", dFdx);
addMethodChaining("dFdy", dFdy);
addMethodChaining("round", round);
addMethodChaining("reciprocal", reciprocal);
addMethodChaining("trunc", trunc);
addMethodChaining("fwidth", fwidth);
addMethodChaining("atan2", atan2);
addMethodChaining("min", min$1);
addMethodChaining("max", max$1);
addMethodChaining("mod", mod);
addMethodChaining("step", step);
addMethodChaining("reflect", reflect);
addMethodChaining("distance", distance);
addMethodChaining("dot", dot);
addMethodChaining("cross", cross);
addMethodChaining("pow", pow);
addMethodChaining("pow2", pow2);
addMethodChaining("pow3", pow3);
addMethodChaining("pow4", pow4);
addMethodChaining("transformDirection", transformDirection);
addMethodChaining("mix", mixElement);
addMethodChaining("clamp", clamp);
addMethodChaining("refract", refract);
addMethodChaining("smoothstep", smoothstepElement);
addMethodChaining("faceForward", faceForward);
addMethodChaining("difference", difference);
addMethodChaining("saturate", saturate);
addMethodChaining("cbrt", cbrt);
addMethodChaining("transpose", transpose);
addMethodChaining("rand", rand);
var ConditionalNode = class extends Node {
  static get type() {
    return "ConditionalNode";
  }
  constructor(condNode, ifNode, elseNode = null) {
    super();
    this.condNode = condNode;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  getNodeType(builder) {
    const ifType = this.ifNode.getNodeType(builder);
    if (this.elseNode !== null) {
      const elseType = this.elseNode.getNodeType(builder);
      if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
        return elseType;
      }
    }
    return ifType;
  }
  setup(builder) {
    const condNode = this.condNode.cache();
    const ifNode = this.ifNode.cache();
    const elseNode = this.elseNode ? this.elseNode.cache() : null;
    const currentNodeBlock = builder.context.nodeBlock;
    builder.getDataFromNode(ifNode).parentNodeBlock = currentNodeBlock;
    if (elseNode !== null) builder.getDataFromNode(elseNode).parentNodeBlock = currentNodeBlock;
    const properties = builder.getNodeProperties(this);
    properties.condNode = condNode;
    properties.ifNode = ifNode.context({ nodeBlock: ifNode });
    properties.elseNode = elseNode ? elseNode.context({ nodeBlock: elseNode }) : null;
  }
  generate(builder, output3) {
    const type = this.getNodeType(builder);
    const nodeData = builder.getDataFromNode(this);
    if (nodeData.nodeProperty !== void 0) {
      return nodeData.nodeProperty;
    }
    const { condNode, ifNode, elseNode } = builder.getNodeProperties(this);
    const needsOutput = output3 !== "void";
    const nodeProperty = needsOutput ? property(type).build(builder) : "";
    nodeData.nodeProperty = nodeProperty;
    const nodeSnippet = condNode.build(builder, "bool");
    builder.addFlowCode(`
${builder.tab}if ( ${nodeSnippet} ) {

`).addFlowTab();
    let ifSnippet = ifNode.build(builder, type);
    if (ifSnippet) {
      if (needsOutput) {
        ifSnippet = nodeProperty + " = " + ifSnippet + ";";
      } else {
        ifSnippet = "return " + ifSnippet + ";";
      }
    }
    builder.removeFlowTab().addFlowCode(builder.tab + "	" + ifSnippet + "\n\n" + builder.tab + "}");
    if (elseNode !== null) {
      builder.addFlowCode(" else {\n\n").addFlowTab();
      let elseSnippet = elseNode.build(builder, type);
      if (elseSnippet) {
        if (needsOutput) {
          elseSnippet = nodeProperty + " = " + elseSnippet + ";";
        } else {
          elseSnippet = "return " + elseSnippet + ";";
        }
      }
      builder.removeFlowTab().addFlowCode(builder.tab + "	" + elseSnippet + "\n\n" + builder.tab + "}\n\n");
    } else {
      builder.addFlowCode("\n\n");
    }
    return builder.format(nodeProperty, type, output3);
  }
};
var select = nodeProxy(ConditionalNode);
addMethodChaining("select", select);
var cond = (...params) => {
  console.warn("TSL.ConditionalNode: cond() has been renamed to select().");
  return select(...params);
};
addMethodChaining("cond", cond);
var ContextNode = class extends Node {
  static get type() {
    return "ContextNode";
  }
  constructor(node, value = {}) {
    super();
    this.isContextNode = true;
    this.node = node;
    this.value = value;
  }
  getScope() {
    return this.node.getScope();
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  analyze(builder) {
    this.node.build(builder);
  }
  setup(builder) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.value });
    const node = this.node.build(builder);
    builder.setContext(previousContext);
    return node;
  }
  generate(builder, output3) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.value });
    const snippet = this.node.build(builder, output3);
    builder.setContext(previousContext);
    return snippet;
  }
};
var context = nodeProxy(ContextNode);
var label = (node, name) => context(node, { label: name });
addMethodChaining("context", context);
addMethodChaining("label", label);
var VarNode = class extends Node {
  static get type() {
    return "VarNode";
  }
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
    this.global = true;
    this.isVarNode = true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const { node, name } = this;
    const nodeVar = builder.getVarFromNode(this, name, builder.getVectorType(this.getNodeType(builder)));
    const propertyName = builder.getPropertyName(nodeVar);
    const snippet = node.build(builder, nodeVar.type);
    builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
    return propertyName;
  }
};
var createVar = nodeProxy(VarNode);
addMethodChaining("toVar", (...params) => createVar(...params).append());
var temp = (node) => {
  console.warn('TSL: "temp" is deprecated. Use ".toVar()" instead.');
  return createVar(node);
};
addMethodChaining("temp", temp);
var VaryingNode = class extends Node {
  static get type() {
    return "VaryingNode";
  }
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
    this.isVaryingNode = true;
  }
  isGlobal() {
    return true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  setupVarying(builder) {
    const properties = builder.getNodeProperties(this);
    let varying3 = properties.varying;
    if (varying3 === void 0) {
      const name = this.name;
      const type = this.getNodeType(builder);
      properties.varying = varying3 = builder.getVaryingFromNode(this, name, type);
      properties.node = this.node;
    }
    varying3.needsInterpolation || (varying3.needsInterpolation = builder.shaderStage === "fragment");
    return varying3;
  }
  setup(builder) {
    this.setupVarying(builder);
  }
  analyze(builder) {
    this.setupVarying(builder);
    return this.node.analyze(builder);
  }
  generate(builder) {
    const properties = builder.getNodeProperties(this);
    const varying3 = this.setupVarying(builder);
    if (properties.propertyName === void 0) {
      const type = this.getNodeType(builder);
      const propertyName = builder.getPropertyName(varying3, NodeShaderStage.VERTEX);
      builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node, type, propertyName);
      properties.propertyName = propertyName;
    }
    return builder.getPropertyName(varying3);
  }
};
var varying = nodeProxy(VaryingNode);
addMethodChaining("varying", varying);
var sRGBTransferEOTF = Fn(([color3]) => {
  const a = color3.mul(0.9478672986).add(0.0521327014).pow(2.4);
  const b = color3.mul(0.0773993808);
  const factor = color3.lessThanEqual(0.04045);
  const rgbResult = mix(a, b, factor);
  return rgbResult;
}).setLayout({
  name: "sRGBTransferEOTF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
});
var sRGBTransferOETF = Fn(([color3]) => {
  const a = color3.pow(0.41666).mul(1.055).sub(0.055);
  const b = color3.mul(12.92);
  const factor = color3.lessThanEqual(31308e-7);
  const rgbResult = mix(a, b, factor);
  return rgbResult;
}).setLayout({
  name: "sRGBTransferOETF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
});
var WORKING_COLOR_SPACE = "WorkingColorSpace";
var OUTPUT_COLOR_SPACE = "OutputColorSpace";
var ColorSpaceNode = class extends TempNode {
  static get type() {
    return "ColorSpaceNode";
  }
  constructor(colorNode, source, target) {
    super("vec4");
    this.colorNode = colorNode;
    this.source = source;
    this.target = target;
  }
  resolveColorSpace(builder, colorSpace) {
    if (colorSpace === WORKING_COLOR_SPACE) {
      return ColorManagement.workingColorSpace;
    } else if (colorSpace === OUTPUT_COLOR_SPACE) {
      return builder.context.outputColorSpace || builder.renderer.outputColorSpace;
    }
    return colorSpace;
  }
  setup(builder) {
    const { colorNode } = this;
    const source = this.resolveColorSpace(builder, this.source);
    const target = this.resolveColorSpace(builder, this.target);
    let outputNode = colorNode;
    if (ColorManagement.enabled === false || source === target || !source || !target) {
      return outputNode;
    }
    if (ColorManagement.getTransfer(source) === SRGBTransfer) {
      outputNode = vec4(sRGBTransferEOTF(outputNode.rgb), outputNode.a);
    }
    if (ColorManagement.getPrimaries(source) !== ColorManagement.getPrimaries(target)) {
      outputNode = vec4(
        mat3(ColorManagement._getMatrix(new Matrix3(), source, target)).mul(outputNode.rgb),
        outputNode.a
      );
    }
    if (ColorManagement.getTransfer(target) === SRGBTransfer) {
      outputNode = vec4(sRGBTransferOETF(outputNode.rgb), outputNode.a);
    }
    return outputNode;
  }
};
var toOutputColorSpace = (node) => nodeObject(new ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, OUTPUT_COLOR_SPACE));
var toWorkingColorSpace = (node) => nodeObject(new ColorSpaceNode(nodeObject(node), OUTPUT_COLOR_SPACE, WORKING_COLOR_SPACE));
var workingToColorSpace = (node, colorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, colorSpace));
var colorSpaceToWorking = (node, colorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), colorSpace, WORKING_COLOR_SPACE));
var convertColorSpace = (node, sourceColorSpace, targetColorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), sourceColorSpace, targetColorSpace));
addMethodChaining("toOutputColorSpace", toOutputColorSpace);
addMethodChaining("toWorkingColorSpace", toWorkingColorSpace);
addMethodChaining("workingToColorSpace", workingToColorSpace);
addMethodChaining("colorSpaceToWorking", colorSpaceToWorking);
var ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {
  static get type() {
    return "ReferenceElementNode";
  }
  constructor(referenceNode, indexNode) {
    super(referenceNode, indexNode);
    this.referenceNode = referenceNode;
    this.isReferenceElementNode = true;
  }
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const arrayType = this.referenceNode.getNodeType();
    const elementType = this.getNodeType();
    return builder.format(snippet, arrayType, elementType);
  }
};
var ReferenceBaseNode = class extends Node {
  static get type() {
    return "ReferenceBaseNode";
  }
  constructor(property3, uniformType, object = null, count = null) {
    super();
    this.property = property3;
    this.uniformType = uniformType;
    this.object = object;
    this.count = count;
    this.properties = property3.split(".");
    this.reference = object;
    this.node = null;
    this.group = null;
    this.updateType = NodeUpdateType.OBJECT;
  }
  setGroup(group) {
    this.group = group;
    return this;
  }
  element(indexNode) {
    return nodeObject(new ReferenceElementNode$1(this, nodeObject(indexNode)));
  }
  setNodeType(uniformType) {
    const node = uniform(null, uniformType).getSelf();
    if (this.group !== null) {
      node.setGroup(this.group);
    }
    this.node = node;
  }
  getNodeType(builder) {
    if (this.node === null) {
      this.updateReference(builder);
      this.updateValue();
    }
    return this.node.getNodeType(builder);
  }
  getValueFromReference(object = this.reference) {
    const { properties } = this;
    let value = object[properties[0]];
    for (let i = 1; i < properties.length; i++) {
      value = value[properties[i]];
    }
    return value;
  }
  updateReference(state) {
    this.reference = this.object !== null ? this.object : state.object;
    return this.reference;
  }
  setup() {
    this.updateValue();
    return this.node;
  }
  update() {
    this.updateValue();
  }
  updateValue() {
    if (this.node === null) this.setNodeType(this.uniformType);
    const value = this.getValueFromReference();
    if (Array.isArray(value)) {
      this.node.array = value;
    } else {
      this.node.value = value;
    }
  }
};
var RendererReferenceNode = class extends ReferenceBaseNode {
  static get type() {
    return "RendererReferenceNode";
  }
  constructor(property3, inputType, renderer = null) {
    super(property3, inputType, renderer);
    this.renderer = renderer;
    this.setGroup(renderGroup);
  }
  updateReference(state) {
    this.reference = this.renderer !== null ? this.renderer : state.renderer;
    return this.reference;
  }
};
var rendererReference = (name, type, renderer) => nodeObject(new RendererReferenceNode(name, type, renderer));
var ToneMappingNode = class extends TempNode {
  static get type() {
    return "ToneMappingNode";
  }
  constructor(toneMapping3, exposureNode = toneMappingExposure, colorNode = null) {
    super("vec3");
    this.toneMapping = toneMapping3;
    this.exposureNode = exposureNode;
    this.colorNode = colorNode;
  }
  getCacheKey() {
    return hash$1(super.getCacheKey(), this.toneMapping);
  }
  setup(builder) {
    const colorNode = this.colorNode || builder.context.color;
    const toneMapping3 = this.toneMapping;
    if (toneMapping3 === NoToneMapping) return colorNode;
    let outputNode = null;
    const toneMappingFn = builder.renderer.library.getToneMappingFunction(toneMapping3);
    if (toneMappingFn !== null) {
      outputNode = vec4(toneMappingFn(colorNode.rgb, this.exposureNode), colorNode.a);
    } else {
      console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", toneMapping3);
      outputNode = colorNode;
    }
    return outputNode;
  }
};
var toneMapping = (mapping, exposure, color3) => nodeObject(new ToneMappingNode(mapping, nodeObject(exposure), nodeObject(color3)));
var toneMappingExposure = rendererReference("toneMappingExposure", "float");
addMethodChaining("toneMapping", (color3, mapping, exposure) => toneMapping(mapping, exposure, color3));
var BufferAttributeNode = class extends InputNode {
  static get type() {
    return "BufferAttributeNode";
  }
  constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferStride = bufferStride;
    this.bufferOffset = bufferOffset;
    this.usage = StaticDrawUsage;
    this.instanced = false;
    this.attribute = null;
    this.global = true;
    if (value && value.isBufferAttribute === true) {
      this.attribute = value;
      this.usage = value.usage;
      this.instanced = value.isInstancedBufferAttribute;
    }
  }
  getHash(builder) {
    if (this.bufferStride === 0 && this.bufferOffset === 0) {
      let bufferData = builder.globalCache.getData(this.value);
      if (bufferData === void 0) {
        bufferData = {
          node: this
        };
        builder.globalCache.setData(this.value, bufferData);
      }
      return bufferData.node.uuid;
    }
    return this.uuid;
  }
  getNodeType(builder) {
    if (this.bufferType === null) {
      this.bufferType = builder.getTypeFromAttribute(this.attribute);
    }
    return this.bufferType;
  }
  setup(builder) {
    if (this.attribute !== null) return;
    const type = this.getNodeType(builder);
    const array = this.value;
    const itemSize = builder.getTypeLength(type);
    const stride = this.bufferStride || itemSize;
    const offset = this.bufferOffset;
    const buffer3 = array.isInterleavedBuffer === true ? array : new InterleavedBuffer(array, stride);
    const bufferAttribute3 = new InterleavedBufferAttribute(buffer3, itemSize, offset);
    buffer3.setUsage(this.usage);
    this.attribute = bufferAttribute3;
    this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);
    const propertyName = builder.getPropertyName(nodeAttribute);
    let output3 = null;
    if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
      this.name = propertyName;
      output3 = propertyName;
    } else {
      const nodeVarying = varying(this);
      output3 = nodeVarying.build(builder, nodeType);
    }
    return output3;
  }
  getInputType() {
    return "bufferAttribute";
  }
  setUsage(value) {
    this.usage = value;
    if (this.attribute && this.attribute.isBufferAttribute === true) {
      this.attribute.usage = value;
    }
    return this;
  }
  setInstanced(value) {
    this.instanced = value;
    return this;
  }
};
var bufferAttribute = (array, type, stride, offset) => nodeObject(new BufferAttributeNode(array, type, stride, offset));
var dynamicBufferAttribute = (array, type, stride, offset) => bufferAttribute(array, type, stride, offset).setUsage(DynamicDrawUsage);
var instancedBufferAttribute = (array, type, stride, offset) => bufferAttribute(array, type, stride, offset).setInstanced(true);
var instancedDynamicBufferAttribute = (array, type, stride, offset) => dynamicBufferAttribute(array, type, stride, offset).setInstanced(true);
addMethodChaining("toAttribute", (bufferNode) => bufferAttribute(bufferNode.value));
var ComputeNode = class extends Node {
  static get type() {
    return "ComputeNode";
  }
  constructor(computeNode, count, workgroupSize = [64]) {
    super("void");
    this.isComputeNode = true;
    this.computeNode = computeNode;
    this.count = count;
    this.workgroupSize = workgroupSize;
    this.dispatchCount = 0;
    this.version = 1;
    this.updateBeforeType = NodeUpdateType.OBJECT;
    this.onInitFunction = null;
    this.updateDispatchCount();
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  updateDispatchCount() {
    const { count, workgroupSize } = this;
    let size = workgroupSize[0];
    for (let i = 1; i < workgroupSize.length; i++)
      size *= workgroupSize[i];
    this.dispatchCount = Math.ceil(count / size);
  }
  onInit(callback) {
    this.onInitFunction = callback;
    return this;
  }
  updateBefore({ renderer }) {
    renderer.compute(this);
  }
  generate(builder) {
    const { shaderStage } = builder;
    if (shaderStage === "compute") {
      const snippet = this.computeNode.build(builder, "void");
      if (snippet !== "") {
        builder.addLineFlowCode(snippet, this);
      }
    }
  }
};
var compute = (node, count, workgroupSize) => nodeObject(new ComputeNode(nodeObject(node), count, workgroupSize));
addMethodChaining("compute", compute);
var CacheNode = class extends Node {
  static get type() {
    return "CacheNode";
  }
  constructor(node, parent = true) {
    super();
    this.node = node;
    this.parent = parent;
    this.isCacheNode = true;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  build(builder, ...params) {
    const previousCache = builder.getCache();
    const cache3 = builder.getCacheFromNode(this, this.parent);
    builder.setCache(cache3);
    const data = this.node.build(builder, ...params);
    builder.setCache(previousCache);
    return data;
  }
};
var cache = (node, ...params) => nodeObject(new CacheNode(nodeObject(node), ...params));
addMethodChaining("cache", cache);
var BypassNode = class extends Node {
  static get type() {
    return "BypassNode";
  }
  constructor(returnNode, callNode) {
    super();
    this.isBypassNode = true;
    this.outputNode = returnNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addLineFlowCode(snippet, this);
    }
    return this.outputNode.build(builder);
  }
};
var bypass = nodeProxy(BypassNode);
addMethodChaining("bypass", bypass);
var RemapNode = class extends Node {
  static get type() {
    return "RemapNode";
  }
  constructor(node, inLowNode, inHighNode, outLowNode = float(0), outHighNode = float(1)) {
    super();
    this.node = node;
    this.inLowNode = inLowNode;
    this.inHighNode = inHighNode;
    this.outLowNode = outLowNode;
    this.outHighNode = outHighNode;
    this.doClamp = true;
  }
  setup() {
    const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;
    let t = node.sub(inLowNode).div(inHighNode.sub(inLowNode));
    if (doClamp === true) t = t.clamp();
    return t.mul(outHighNode.sub(outLowNode)).add(outLowNode);
  }
};
var remap = nodeProxy(RemapNode, null, null, { doClamp: false });
var remapClamp = nodeProxy(RemapNode);
addMethodChaining("remap", remap);
addMethodChaining("remapClamp", remapClamp);
var ExpressionNode = class extends Node {
  static get type() {
    return "ExpressionNode";
  }
  constructor(snippet = "", nodeType = "void") {
    super(nodeType);
    this.snippet = snippet;
  }
  generate(builder, output3) {
    const type = this.getNodeType(builder);
    const snippet = this.snippet;
    if (type === "void") {
      builder.addLineFlowCode(snippet, this);
    } else {
      return builder.format(`( ${snippet} )`, type, output3);
    }
  }
};
var expression = nodeProxy(ExpressionNode);
var Discard = (conditional) => (conditional ? select(conditional, expression("discard")) : expression("discard")).append();
var Return = () => expression("return").append();
addMethodChaining("discard", Discard);
var RenderOutputNode = class extends TempNode {
  static get type() {
    return "RenderOutputNode";
  }
  constructor(colorNode, toneMapping3, outputColorSpace) {
    super("vec4");
    this.colorNode = colorNode;
    this.toneMapping = toneMapping3;
    this.outputColorSpace = outputColorSpace;
    this.isRenderOutput = true;
  }
  setup({ context: context3 }) {
    let outputNode = this.colorNode || context3.color;
    const toneMapping3 = (this.toneMapping !== null ? this.toneMapping : context3.toneMapping) || NoToneMapping;
    const outputColorSpace = (this.outputColorSpace !== null ? this.outputColorSpace : context3.outputColorSpace) || NoColorSpace;
    if (toneMapping3 !== NoToneMapping) {
      outputNode = outputNode.toneMapping(toneMapping3);
    }
    if (outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace) {
      outputNode = outputNode.workingToColorSpace(outputColorSpace);
    }
    return outputNode;
  }
};
var renderOutput = (color3, toneMapping3 = null, outputColorSpace = null) => nodeObject(new RenderOutputNode(nodeObject(color3), toneMapping3, outputColorSpace));
addMethodChaining("renderOutput", renderOutput);
function addNodeElement(name) {
  console.warn("THREE.TSLBase: AddNodeElement has been removed in favor of tree-shaking. Trying add", name);
}
var AttributeNode = class extends Node {
  static get type() {
    return "AttributeNode";
  }
  constructor(attributeName, nodeType = null) {
    super(nodeType);
    this.global = true;
    this._attributeName = attributeName;
  }
  getHash(builder) {
    return this.getAttributeName(builder);
  }
  getNodeType(builder) {
    let nodeType = this.nodeType;
    if (nodeType === null) {
      const attributeName = this.getAttributeName(builder);
      if (builder.hasGeometryAttribute(attributeName)) {
        const attribute3 = builder.geometry.getAttribute(attributeName);
        nodeType = builder.getTypeFromAttribute(attribute3);
      } else {
        nodeType = "float";
      }
    }
    return nodeType;
  }
  setAttributeName(attributeName) {
    this._attributeName = attributeName;
    return this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(builder) {
    const attributeName = this.getAttributeName(builder);
    const nodeType = this.getNodeType(builder);
    const geometryAttribute = builder.hasGeometryAttribute(attributeName);
    if (geometryAttribute === true) {
      const attribute3 = builder.geometry.getAttribute(attributeName);
      const attributeType = builder.getTypeFromAttribute(attribute3);
      const nodeAttribute = builder.getAttribute(attributeName, attributeType);
      if (builder.shaderStage === "vertex") {
        return builder.format(nodeAttribute.name, attributeType, nodeType);
      } else {
        const nodeVarying = varying(this);
        return nodeVarying.build(builder, nodeType);
      }
    } else {
      console.warn(`AttributeNode: Vertex attribute "${attributeName}" not found on geometry.`);
      return builder.generateConst(nodeType);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.global = this.global;
    data._attributeName = this._attributeName;
  }
  deserialize(data) {
    super.deserialize(data);
    this.global = data.global;
    this._attributeName = data._attributeName;
  }
};
var attribute = (name, nodeType) => nodeObject(new AttributeNode(name, nodeType));
var uv = (index) => attribute("uv" + (index > 0 ? index : ""), "vec2");
var TextureSizeNode = class extends Node {
  static get type() {
    return "TextureSizeNode";
  }
  constructor(textureNode, levelNode = null) {
    super("uvec2");
    this.isTextureSizeNode = true;
    this.textureNode = textureNode;
    this.levelNode = levelNode;
  }
  generate(builder, output3) {
    const textureProperty = this.textureNode.build(builder, "property");
    const level = this.levelNode === null ? "0" : this.levelNode.build(builder, "int");
    return builder.format(`${builder.getMethod("textureDimensions")}( ${textureProperty}, ${level} )`, this.getNodeType(builder), output3);
  }
};
var textureSize = nodeProxy(TextureSizeNode);
var MaxMipLevelNode = class extends UniformNode {
  static get type() {
    return "MaxMipLevelNode";
  }
  constructor(textureNode) {
    super(0);
    this._textureNode = textureNode;
    this.updateType = NodeUpdateType.FRAME;
  }
  get textureNode() {
    return this._textureNode;
  }
  get texture() {
    return this._textureNode.value;
  }
  update() {
    const texture3 = this.texture;
    const images = texture3.images;
    const image = images && images.length > 0 ? images[0] && images[0].image || images[0] : texture3.image;
    if (image && image.width !== void 0) {
      const { width, height } = image;
      this.value = Math.log2(Math.max(width, height));
    }
  }
};
var maxMipLevel = nodeProxy(MaxMipLevelNode);
var TextureNode = class extends UniformNode {
  static get type() {
    return "TextureNode";
  }
  constructor(value, uvNode = null, levelNode = null, biasNode = null) {
    super(value);
    this.isTextureNode = true;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
    this.biasNode = biasNode;
    this.compareNode = null;
    this.depthNode = null;
    this.gradNode = null;
    this.sampler = true;
    this.updateMatrix = false;
    this.updateType = NodeUpdateType.NONE;
    this.referenceNode = null;
    this._value = value;
    this._matrixUniform = null;
    this.setUpdateMatrix(uvNode === null);
  }
  set value(value) {
    if (this.referenceNode) {
      this.referenceNode.value = value;
    } else {
      this._value = value;
    }
  }
  get value() {
    return this.referenceNode ? this.referenceNode.value : this._value;
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getNodeType() {
    if (this.value.isDepthTexture === true) return "float";
    if (this.value.type === UnsignedIntType) {
      return "uvec4";
    } else if (this.value.type === IntType) {
      return "ivec4";
    }
    return "vec4";
  }
  getInputType() {
    return "texture";
  }
  getDefaultUV() {
    return uv(this.value.channel);
  }
  updateReference() {
    return this.value;
  }
  getTransformedUV(uvNode) {
    if (this._matrixUniform === null) this._matrixUniform = uniform(this.value.matrix);
    return this._matrixUniform.mul(vec3(uvNode, 1)).xy;
  }
  setUpdateMatrix(value) {
    this.updateMatrix = value;
    this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;
    return this;
  }
  setupUV(builder, uvNode) {
    const texture3 = this.value;
    if (builder.isFlipY() && (texture3.image instanceof ImageBitmap && texture3.flipY === true || texture3.isRenderTargetTexture === true || texture3.isFramebufferTexture === true || texture3.isDepthTexture === true)) {
      if (this.sampler) {
        uvNode = uvNode.flipY();
      } else {
        uvNode = uvNode.setY(int(textureSize(this, this.levelNode).y).sub(uvNode.y).sub(1));
      }
    }
    return uvNode;
  }
  setup(builder) {
    const properties = builder.getNodeProperties(this);
    properties.referenceNode = this.referenceNode;
    let uvNode = this.uvNode;
    if ((uvNode === null || builder.context.forceUVContext === true) && builder.context.getUV) {
      uvNode = builder.context.getUV(this);
    }
    if (!uvNode) uvNode = this.getDefaultUV();
    if (this.updateMatrix === true) {
      uvNode = this.getTransformedUV(uvNode);
    }
    uvNode = this.setupUV(builder, uvNode);
    let levelNode = this.levelNode;
    if (levelNode === null && builder.context.getTextureLevel) {
      levelNode = builder.context.getTextureLevel(this);
    }
    properties.uvNode = uvNode;
    properties.levelNode = levelNode;
    properties.biasNode = this.biasNode;
    properties.compareNode = this.compareNode;
    properties.gradNode = this.gradNode;
    properties.depthNode = this.depthNode;
  }
  generateUV(builder, uvNode) {
    return uvNode.build(builder, this.sampler === true ? "vec2" : "ivec2");
  }
  generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet) {
    const texture3 = this.value;
    let snippet;
    if (levelSnippet) {
      snippet = builder.generateTextureLevel(texture3, textureProperty, uvSnippet, levelSnippet, depthSnippet);
    } else if (biasSnippet) {
      snippet = builder.generateTextureBias(texture3, textureProperty, uvSnippet, biasSnippet, depthSnippet);
    } else if (gradSnippet) {
      snippet = builder.generateTextureGrad(texture3, textureProperty, uvSnippet, gradSnippet, depthSnippet);
    } else if (compareSnippet) {
      snippet = builder.generateTextureCompare(texture3, textureProperty, uvSnippet, compareSnippet, depthSnippet);
    } else if (this.sampler === false) {
      snippet = builder.generateTextureLoad(texture3, textureProperty, uvSnippet, depthSnippet);
    } else {
      snippet = builder.generateTexture(texture3, textureProperty, uvSnippet, depthSnippet);
    }
    return snippet;
  }
  generate(builder, output3) {
    const properties = builder.getNodeProperties(this);
    const texture3 = this.value;
    if (!texture3 || texture3.isTexture !== true) {
      throw new Error("TextureNode: Need a three.js texture.");
    }
    const textureProperty = super.generate(builder, "property");
    if (output3 === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output3)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let propertyName = nodeData.propertyName;
      if (propertyName === void 0) {
        const { uvNode, levelNode, biasNode, compareNode, depthNode, gradNode } = properties;
        const uvSnippet = this.generateUV(builder, uvNode);
        const levelSnippet = levelNode ? levelNode.build(builder, "float") : null;
        const biasSnippet = biasNode ? biasNode.build(builder, "float") : null;
        const depthSnippet = depthNode ? depthNode.build(builder, "int") : null;
        const compareSnippet = compareNode ? compareNode.build(builder, "float") : null;
        const gradSnippet = gradNode ? [gradNode[0].build(builder, "vec2"), gradNode[1].build(builder, "vec2")] : null;
        const nodeVar = builder.getVarFromNode(this);
        propertyName = builder.getPropertyName(nodeVar);
        const snippet2 = this.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet);
        builder.addLineFlowCode(`${propertyName} = ${snippet2}`, this);
        nodeData.snippet = snippet2;
        nodeData.propertyName = propertyName;
      }
      let snippet = propertyName;
      const nodeType = this.getNodeType(builder);
      if (builder.needsToWorkingColorSpace(texture3)) {
        snippet = colorSpaceToWorking(expression(snippet, nodeType), texture3.colorSpace).setup(builder).build(builder, nodeType);
      }
      return builder.format(snippet, nodeType, output3);
    }
  }
  setSampler(value) {
    this.sampler = value;
    return this;
  }
  getSampler() {
    return this.sampler;
  }
  // @TODO: Move to TSL
  uv(uvNode) {
    const textureNode = this.clone();
    textureNode.uvNode = nodeObject(uvNode);
    textureNode.referenceNode = this.getSelf();
    return nodeObject(textureNode);
  }
  blur(amountNode) {
    const textureNode = this.clone();
    textureNode.biasNode = nodeObject(amountNode).mul(maxMipLevel(textureNode));
    textureNode.referenceNode = this.getSelf();
    return nodeObject(textureNode);
  }
  level(levelNode) {
    const textureNode = this.clone();
    textureNode.levelNode = nodeObject(levelNode);
    textureNode.referenceNode = this.getSelf();
    return nodeObject(textureNode);
  }
  size(levelNode) {
    return textureSize(this, levelNode);
  }
  bias(biasNode) {
    const textureNode = this.clone();
    textureNode.biasNode = nodeObject(biasNode);
    textureNode.referenceNode = this.getSelf();
    return nodeObject(textureNode);
  }
  compare(compareNode) {
    const textureNode = this.clone();
    textureNode.compareNode = nodeObject(compareNode);
    textureNode.referenceNode = this.getSelf();
    return nodeObject(textureNode);
  }
  grad(gradNodeX, gradNodeY) {
    const textureNode = this.clone();
    textureNode.gradNode = [nodeObject(gradNodeX), nodeObject(gradNodeY)];
    textureNode.referenceNode = this.getSelf();
    return nodeObject(textureNode);
  }
  depth(depthNode) {
    const textureNode = this.clone();
    textureNode.depthNode = nodeObject(depthNode);
    textureNode.referenceNode = this.getSelf();
    return nodeObject(textureNode);
  }
  // --
  serialize(data) {
    super.serialize(data);
    data.value = this.value.toJSON(data.meta).uuid;
    data.sampler = this.sampler;
    data.updateMatrix = this.updateMatrix;
    data.updateType = this.updateType;
  }
  deserialize(data) {
    super.deserialize(data);
    this.value = data.meta.textures[data.value];
    this.sampler = data.sampler;
    this.updateMatrix = data.updateMatrix;
    this.updateType = data.updateType;
  }
  update() {
    const texture3 = this.value;
    const matrixUniform = this._matrixUniform;
    if (matrixUniform !== null) matrixUniform.value = texture3.matrix;
    if (texture3.matrixAutoUpdate === true) {
      texture3.updateMatrix();
    }
  }
  clone() {
    const newNode = new this.constructor(this.value, this.uvNode, this.levelNode, this.biasNode);
    newNode.sampler = this.sampler;
    return newNode;
  }
};
var texture = nodeProxy(TextureNode);
var textureLoad = (...params) => texture(...params).setSampler(false);
var sampler = (aTexture) => (aTexture.isNode === true ? aTexture : texture(aTexture)).convert("sampler");
var cameraNear = uniform("float").label("cameraNear").setGroup(renderGroup).onRenderUpdate(({ camera }) => camera.near);
var cameraFar = uniform("float").label("cameraFar").setGroup(renderGroup).onRenderUpdate(({ camera }) => camera.far);
var cameraProjectionMatrix = uniform("mat4").label("cameraProjectionMatrix").setGroup(renderGroup).onRenderUpdate(({ camera }) => camera.projectionMatrix);
var cameraProjectionMatrixInverse = uniform("mat4").label("cameraProjectionMatrixInverse").setGroup(renderGroup).onRenderUpdate(({ camera }) => camera.projectionMatrixInverse);
var cameraViewMatrix = uniform("mat4").label("cameraViewMatrix").setGroup(renderGroup).onRenderUpdate(({ camera }) => camera.matrixWorldInverse);
var cameraWorldMatrix = uniform("mat4").label("cameraWorldMatrix").setGroup(renderGroup).onRenderUpdate(({ camera }) => camera.matrixWorld);
var cameraNormalMatrix = uniform("mat3").label("cameraNormalMatrix").setGroup(renderGroup).onRenderUpdate(({ camera }) => camera.normalMatrix);
var cameraPosition = uniform(new Vector3()).label("cameraPosition").setGroup(renderGroup).onRenderUpdate(({ camera }, self2) => self2.value.setFromMatrixPosition(camera.matrixWorld));
var Object3DNode = class _Object3DNode extends Node {
  static get type() {
    return "Object3DNode";
  }
  constructor(scope, object3d = null) {
    super();
    this.scope = scope;
    this.object3d = object3d;
    this.updateType = NodeUpdateType.OBJECT;
    this._uniformNode = new UniformNode(null);
  }
  getNodeType() {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX) {
      return "mat4";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION || scope === _Object3DNode.DIRECTION || scope === _Object3DNode.SCALE) {
      return "vec3";
    }
  }
  update(frame) {
    const object = this.object3d;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX) {
      uniformNode.value = object.matrixWorld;
    } else if (scope === _Object3DNode.POSITION) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
    } else if (scope === _Object3DNode.SCALE) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixScale(object.matrixWorld);
    } else if (scope === _Object3DNode.DIRECTION) {
      uniformNode.value = uniformNode.value || new Vector3();
      object.getWorldDirection(uniformNode.value);
    } else if (scope === _Object3DNode.VIEW_POSITION) {
      const camera = frame.camera;
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION || scope === _Object3DNode.DIRECTION || scope === _Object3DNode.SCALE) {
      this._uniformNode.nodeType = "vec3";
    }
    return this._uniformNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
Object3DNode.WORLD_MATRIX = "worldMatrix";
Object3DNode.POSITION = "position";
Object3DNode.SCALE = "scale";
Object3DNode.VIEW_POSITION = "viewPosition";
Object3DNode.DIRECTION = "direction";
var objectDirection = nodeProxy(Object3DNode, Object3DNode.DIRECTION);
var objectWorldMatrix = nodeProxy(Object3DNode, Object3DNode.WORLD_MATRIX);
var objectPosition = nodeProxy(Object3DNode, Object3DNode.POSITION);
var objectScale = nodeProxy(Object3DNode, Object3DNode.SCALE);
var objectViewPosition = nodeProxy(Object3DNode, Object3DNode.VIEW_POSITION);
var ModelNode = class extends Object3DNode {
  static get type() {
    return "ModelNode";
  }
  constructor(scope) {
    super(scope);
  }
  update(frame) {
    this.object3d = frame.object;
    super.update(frame);
  }
};
var modelDirection = nodeImmutable(ModelNode, ModelNode.DIRECTION);
var modelWorldMatrix = nodeImmutable(ModelNode, ModelNode.WORLD_MATRIX);
var modelPosition = nodeImmutable(ModelNode, ModelNode.POSITION);
var modelScale = nodeImmutable(ModelNode, ModelNode.SCALE);
var modelViewPosition = nodeImmutable(ModelNode, ModelNode.VIEW_POSITION);
var modelNormalMatrix = uniform(new Matrix3()).onObjectUpdate(({ object }, self2) => self2.value.getNormalMatrix(object.matrixWorld));
var modelWorldMatrixInverse = uniform(new Matrix4()).onObjectUpdate(({ object }, self2) => self2.value.copy(object.matrixWorld).invert());
var modelViewMatrix = cameraViewMatrix.mul(modelWorldMatrix).toVar("modelViewMatrix");
var highPrecisionModelViewMatrix = Fn((builder) => {
  builder.context.isHighPrecisionModelViewMatrix = true;
  return uniform("mat4").onObjectUpdate(({ object, camera }) => {
    return object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
  });
}).once()().toVar("highPrecisionModelViewMatrix");
var highPrecisionModelNormalViewMatrix = Fn((builder) => {
  const isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;
  return uniform("mat3").onObjectUpdate(({ object, camera }) => {
    if (isHighPrecisionModelViewMatrix !== true) {
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    }
    return object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
  });
}).once()().toVar("highPrecisionModelNormalMatrix");
var positionGeometry = attribute("position", "vec3");
var positionLocal = positionGeometry.varying("positionLocal");
var positionPrevious = positionGeometry.varying("positionPrevious");
var positionWorld = modelWorldMatrix.mul(positionLocal).xyz.varying("v_positionWorld");
var positionWorldDirection = positionLocal.transformDirection(modelWorldMatrix).varying("v_positionWorldDirection").normalize().toVar("positionWorldDirection");
var positionView = modelViewMatrix.mul(positionLocal).xyz.varying("v_positionView");
var positionViewDirection = positionView.negate().varying("v_positionViewDirection").normalize().toVar("positionViewDirection");
var FrontFacingNode = class extends Node {
  static get type() {
    return "FrontFacingNode";
  }
  constructor() {
    super("bool");
    this.isFrontFacingNode = true;
  }
  generate(builder) {
    const { renderer, material } = builder;
    if (renderer.coordinateSystem === WebGLCoordinateSystem) {
      if (material.side === BackSide) {
        return "false";
      }
    }
    return builder.getFrontFacing();
  }
};
var frontFacing = nodeImmutable(FrontFacingNode);
var faceDirection = float(frontFacing).mul(2).sub(1);
var normalGeometry = attribute("normal", "vec3");
var normalLocal = Fn((builder) => {
  if (builder.geometry.hasAttribute("normal") === false) {
    console.warn('TSL.NormalNode: Vertex attribute "normal" not found on geometry.');
    return vec3(0, 1, 0);
  }
  return normalGeometry;
}, "vec3").once()().toVar("normalLocal");
var normalFlat = positionView.dFdx().cross(positionView.dFdy()).normalize().toVar("normalFlat");
var normalView = Fn((builder) => {
  let node;
  if (builder.material.flatShading === true) {
    node = normalFlat;
  } else {
    node = varying(transformNormalToView(normalLocal), "v_normalView").normalize();
  }
  return node;
}, "vec3").once()().toVar("normalView");
var normalWorld = varying(normalView.transformDirection(cameraViewMatrix), "v_normalWorld").normalize().toVar("normalWorld");
var transformedNormalView = Fn((builder) => {
  return builder.context.setupNormal();
}, "vec3").once()().mul(faceDirection).toVar("transformedNormalView");
var transformedNormalWorld = transformedNormalView.transformDirection(cameraViewMatrix).toVar("transformedNormalWorld");
var transformedClearcoatNormalView = Fn((builder) => {
  return builder.context.setupClearcoatNormal();
}, "vec3").once()().mul(faceDirection).toVar("transformedClearcoatNormalView");
var transformNormal = Fn(([normal2, matrix = modelWorldMatrix]) => {
  const m = mat3(matrix);
  const transformedNormal = normal2.div(vec3(m[0].dot(m[0]), m[1].dot(m[1]), m[2].dot(m[2])));
  return m.mul(transformedNormal).xyz;
});
var transformNormalToView = Fn(([normal2], builder) => {
  const modelNormalViewMatrix = builder.renderer.nodes.modelNormalViewMatrix;
  if (modelNormalViewMatrix !== null) {
    return modelNormalViewMatrix.transformDirection(normal2);
  }
  const transformedNormal = modelNormalMatrix.mul(normal2);
  return cameraViewMatrix.transformDirection(transformedNormal);
});
var materialRefractionRatio = uniform(0).onReference(({ material }) => material).onRenderUpdate(({ material }) => material.refractionRatio);
var reflectView = positionViewDirection.negate().reflect(transformedNormalView);
var refractView = positionViewDirection.negate().refract(transformedNormalView, materialRefractionRatio);
var reflectVector = reflectView.transformDirection(cameraViewMatrix).toVar("reflectVector");
var refractVector = refractView.transformDirection(cameraViewMatrix).toVar("reflectVector");
var CubeTextureNode = class extends TextureNode {
  static get type() {
    return "CubeTextureNode";
  }
  constructor(value, uvNode = null, levelNode = null, biasNode = null) {
    super(value, uvNode, levelNode, biasNode);
    this.isCubeTextureNode = true;
  }
  getInputType() {
    return "cubeTexture";
  }
  getDefaultUV() {
    const texture3 = this.value;
    if (texture3.mapping === CubeReflectionMapping) {
      return reflectVector;
    } else if (texture3.mapping === CubeRefractionMapping) {
      return refractVector;
    } else {
      console.error('THREE.CubeTextureNode: Mapping "%s" not supported.', texture3.mapping);
      return vec3(0, 0, 0);
    }
  }
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for CubeTextureNode
  setupUV(builder, uvNode) {
    const texture3 = this.value;
    if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem || !texture3.isRenderTargetTexture) {
      return vec3(uvNode.x.negate(), uvNode.yz);
    } else {
      return uvNode;
    }
  }
  generateUV(builder, cubeUV) {
    return cubeUV.build(builder, "vec3");
  }
};
var cubeTexture = nodeProxy(CubeTextureNode);
var BufferNode = class extends UniformNode {
  static get type() {
    return "BufferNode";
  }
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
  }
  getElementType(builder) {
    return this.getNodeType(builder);
  }
  getInputType() {
    return "buffer";
  }
};
var buffer = (value, type, count) => nodeObject(new BufferNode(value, type, count));
var UniformArrayElementNode = class extends ArrayElementNode {
  static get type() {
    return "UniformArrayElementNode";
  }
  constructor(arrayBuffer3, indexNode) {
    super(arrayBuffer3, indexNode);
    this.isArrayBufferElementNode = true;
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const type = this.getNodeType();
    return builder.format(snippet, "vec4", type);
  }
};
var UniformArrayNode = class extends BufferNode {
  static get type() {
    return "UniformArrayNode";
  }
  constructor(value, elementType = null) {
    super(null, "vec4");
    this.array = value;
    this.elementType = elementType;
    this._elementType = null;
    this._elementLength = 0;
    this.updateType = NodeUpdateType.RENDER;
    this.isArrayBufferNode = true;
  }
  getElementType() {
    return this.elementType || this._elementType;
  }
  getElementLength() {
    return this._elementLength;
  }
  update() {
    const { array, value } = this;
    const elementLength = this.getElementLength();
    const elementType = this.getElementType();
    if (elementLength === 1) {
      for (let i = 0; i < array.length; i++) {
        const index = i * 4;
        value[index] = array[i];
      }
    } else if (elementType === "color") {
      for (let i = 0; i < array.length; i++) {
        const index = i * 4;
        const vector = array[i];
        value[index] = vector.r;
        value[index + 1] = vector.g;
        value[index + 2] = vector.b || 0;
      }
    } else {
      for (let i = 0; i < array.length; i++) {
        const index = i * 4;
        const vector = array[i];
        value[index] = vector.x;
        value[index + 1] = vector.y;
        value[index + 2] = vector.z || 0;
        value[index + 3] = vector.w || 0;
      }
    }
  }
  setup(builder) {
    const length3 = this.array.length;
    this._elementType = this.elementType === null ? getValueType(this.array[0]) : this.elementType;
    this._elementLength = builder.getTypeLength(this._elementType);
    let arrayType = Float32Array;
    if (this._elementType.charAt(0) === "i") arrayType = Int32Array;
    else if (this._elementType.charAt(0) === "u") arrayType = Uint32Array;
    this.value = new arrayType(length3 * 4);
    this.bufferCount = length3;
    this.bufferType = builder.changeComponentType("vec4", builder.getComponentType(this._elementType));
    return super.setup(builder);
  }
  element(indexNode) {
    return nodeObject(new UniformArrayElementNode(this, nodeObject(indexNode)));
  }
};
var uniformArray = (values, nodeType) => nodeObject(new UniformArrayNode(values, nodeType));
var uniforms = (values, nodeType) => {
  console.warn("TSL.UniformArrayNode: uniforms() has been renamed to uniformArray().");
  return nodeObject(new UniformArrayNode(values, nodeType));
};
var ReferenceElementNode2 = class extends ArrayElementNode {
  static get type() {
    return "ReferenceElementNode";
  }
  constructor(referenceNode, indexNode) {
    super(referenceNode, indexNode);
    this.referenceNode = referenceNode;
    this.isReferenceElementNode = true;
  }
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const arrayType = this.referenceNode.getNodeType();
    const elementType = this.getNodeType();
    return builder.format(snippet, arrayType, elementType);
  }
};
var ReferenceNode = class extends Node {
  static get type() {
    return "ReferenceNode";
  }
  constructor(property3, uniformType, object = null, count = null) {
    super();
    this.property = property3;
    this.uniformType = uniformType;
    this.object = object;
    this.count = count;
    this.properties = property3.split(".");
    this.reference = object;
    this.node = null;
    this.group = null;
    this.name = null;
    this.updateType = NodeUpdateType.OBJECT;
  }
  element(indexNode) {
    return nodeObject(new ReferenceElementNode2(this, nodeObject(indexNode)));
  }
  setGroup(group) {
    this.group = group;
    return this;
  }
  label(name) {
    this.name = name;
    return this;
  }
  setNodeType(uniformType) {
    let node = null;
    if (this.count !== null) {
      node = buffer(null, uniformType, this.count);
    } else if (Array.isArray(this.getValueFromReference())) {
      node = uniformArray(null, uniformType);
    } else if (uniformType === "texture") {
      node = texture(null);
    } else if (uniformType === "cubeTexture") {
      node = cubeTexture(null);
    } else {
      node = uniform(null, uniformType);
    }
    if (this.group !== null) {
      node.setGroup(this.group);
    }
    if (this.name !== null) node.label(this.name);
    this.node = node.getSelf();
  }
  getNodeType(builder) {
    if (this.node === null) {
      this.updateReference(builder);
      this.updateValue();
    }
    return this.node.getNodeType(builder);
  }
  getValueFromReference(object = this.reference) {
    const { properties } = this;
    let value = object[properties[0]];
    for (let i = 1; i < properties.length; i++) {
      value = value[properties[i]];
    }
    return value;
  }
  updateReference(state) {
    this.reference = this.object !== null ? this.object : state.object;
    return this.reference;
  }
  setup() {
    this.updateValue();
    return this.node;
  }
  update() {
    this.updateValue();
  }
  updateValue() {
    if (this.node === null) this.setNodeType(this.uniformType);
    const value = this.getValueFromReference();
    if (Array.isArray(value)) {
      this.node.array = value;
    } else {
      this.node.value = value;
    }
  }
};
var reference = (name, type, object) => nodeObject(new ReferenceNode(name, type, object));
var referenceBuffer = (name, type, count, object) => nodeObject(new ReferenceNode(name, type, object, count));
var MaterialReferenceNode = class extends ReferenceNode {
  static get type() {
    return "MaterialReferenceNode";
  }
  constructor(property3, inputType, material = null) {
    super(property3, inputType, material);
    this.material = material;
    this.isMaterialReferenceNode = true;
  }
  /*setNodeType( node ) {
  
  		super.setNodeType( node );
  
  		this.node.groupNode = renderGroup;
  
  	}*/
  updateReference(state) {
    this.reference = this.material !== null ? this.material : state.material;
    return this.reference;
  }
};
var materialReference = (name, type, material) => nodeObject(new MaterialReferenceNode(name, type, material));
var tangentGeometry = Fn((builder) => {
  if (builder.geometry.hasAttribute("tangent") === false) {
    builder.geometry.computeTangents();
  }
  return attribute("tangent", "vec4");
})();
var tangentLocal = tangentGeometry.xyz.toVar("tangentLocal");
var tangentView = modelViewMatrix.mul(vec4(tangentLocal, 0)).xyz.varying("v_tangentView").normalize().toVar("tangentView");
var tangentWorld = tangentView.transformDirection(cameraViewMatrix).varying("v_tangentWorld").normalize().toVar("tangentWorld");
var transformedTangentView = tangentView.toVar("transformedTangentView");
var transformedTangentWorld = transformedTangentView.transformDirection(cameraViewMatrix).normalize().toVar("transformedTangentWorld");
var getBitangent = (crossNormalTangent) => crossNormalTangent.mul(tangentGeometry.w).xyz;
var bitangentGeometry = varying(getBitangent(normalGeometry.cross(tangentGeometry)), "v_bitangentGeometry").normalize().toVar("bitangentGeometry");
var bitangentLocal = varying(getBitangent(normalLocal.cross(tangentLocal)), "v_bitangentLocal").normalize().toVar("bitangentLocal");
var bitangentView = varying(getBitangent(normalView.cross(tangentView)), "v_bitangentView").normalize().toVar("bitangentView");
var bitangentWorld = varying(getBitangent(normalWorld.cross(tangentWorld)), "v_bitangentWorld").normalize().toVar("bitangentWorld");
var transformedBitangentView = getBitangent(transformedNormalView.cross(transformedTangentView)).normalize().toVar("transformedBitangentView");
var transformedBitangentWorld = transformedBitangentView.transformDirection(cameraViewMatrix).normalize().toVar("transformedBitangentWorld");
var TBNViewMatrix = mat3(tangentView, bitangentView, normalView);
var parallaxDirection = positionViewDirection.mul(TBNViewMatrix);
var parallaxUV = (uv3, scale) => uv3.sub(parallaxDirection.mul(scale));
var transformedBentNormalView = (() => {
  let bentNormal = anisotropyB.cross(positionViewDirection);
  bentNormal = bentNormal.cross(anisotropyB).normalize();
  bentNormal = mix(bentNormal, transformedNormalView, anisotropy.mul(roughness.oneMinus()).oneMinus().pow2().pow2()).normalize();
  return bentNormal;
})();
var perturbNormal2Arb = Fn((inputs) => {
  const { eye_pos, surf_norm, mapN, uv: uv3 } = inputs;
  const q0 = eye_pos.dFdx();
  const q1 = eye_pos.dFdy();
  const st0 = uv3.dFdx();
  const st1 = uv3.dFdy();
  const N = surf_norm;
  const q1perp = q1.cross(N);
  const q0perp = N.cross(q0);
  const T = q1perp.mul(st0.x).add(q0perp.mul(st1.x));
  const B = q1perp.mul(st0.y).add(q0perp.mul(st1.y));
  const det = T.dot(T).max(B.dot(B));
  const scale = faceDirection.mul(det.inverseSqrt());
  return add(T.mul(mapN.x, scale), B.mul(mapN.y, scale), N.mul(mapN.z)).normalize();
});
var NormalMapNode = class extends TempNode {
  static get type() {
    return "NormalMapNode";
  }
  constructor(node, scaleNode = null) {
    super("vec3");
    this.node = node;
    this.scaleNode = scaleNode;
    this.normalMapType = TangentSpaceNormalMap;
  }
  setup(builder) {
    const { normalMapType, scaleNode } = this;
    let normalMap3 = this.node.mul(2).sub(1);
    if (scaleNode !== null) {
      normalMap3 = vec3(normalMap3.xy.mul(scaleNode), normalMap3.z);
    }
    let outputNode = null;
    if (normalMapType === ObjectSpaceNormalMap) {
      outputNode = transformNormalToView(normalMap3);
    } else if (normalMapType === TangentSpaceNormalMap) {
      const tangent = builder.hasGeometryAttribute("tangent");
      if (tangent === true) {
        outputNode = TBNViewMatrix.mul(normalMap3).normalize();
      } else {
        outputNode = perturbNormal2Arb({
          eye_pos: positionView,
          surf_norm: normalView,
          mapN: normalMap3,
          uv: uv()
        });
      }
    }
    return outputNode;
  }
};
var normalMap = nodeProxy(NormalMapNode);
var dHdxy_fwd = Fn(({ textureNode, bumpScale }) => {
  const sampleTexture = (callback) => textureNode.cache().context({ getUV: (texNode) => callback(texNode.uvNode || uv()), forceUVContext: true });
  const Hll = float(sampleTexture((uvNode) => uvNode));
  return vec2(
    float(sampleTexture((uvNode) => uvNode.add(uvNode.dFdx()))).sub(Hll),
    float(sampleTexture((uvNode) => uvNode.add(uvNode.dFdy()))).sub(Hll)
  ).mul(bumpScale);
});
var perturbNormalArb = Fn((inputs) => {
  const { surf_pos, surf_norm, dHdxy } = inputs;
  const vSigmaX = surf_pos.dFdx().normalize();
  const vSigmaY = surf_pos.dFdy().normalize();
  const vN = surf_norm;
  const R1 = vSigmaY.cross(vN);
  const R2 = vN.cross(vSigmaX);
  const fDet = vSigmaX.dot(R1).mul(faceDirection);
  const vGrad = fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));
  return fDet.abs().mul(surf_norm).sub(vGrad).normalize();
});
var BumpMapNode = class extends TempNode {
  static get type() {
    return "BumpMapNode";
  }
  constructor(textureNode, scaleNode = null) {
    super("vec3");
    this.textureNode = textureNode;
    this.scaleNode = scaleNode;
  }
  setup() {
    const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;
    const dHdxy = dHdxy_fwd({ textureNode: this.textureNode, bumpScale });
    return perturbNormalArb({
      surf_pos: positionView,
      surf_norm: normalView,
      dHdxy
    });
  }
};
var bumpMap = nodeProxy(BumpMapNode);
var _propertyCache = /* @__PURE__ */ new Map();
var MaterialNode = class _MaterialNode extends Node {
  static get type() {
    return "MaterialNode";
  }
  constructor(scope) {
    super();
    this.scope = scope;
  }
  getCache(property3, type) {
    let node = _propertyCache.get(property3);
    if (node === void 0) {
      node = materialReference(property3, type);
      _propertyCache.set(property3, node);
    }
    return node;
  }
  getFloat(property3) {
    return this.getCache(property3, "float");
  }
  getColor(property3) {
    return this.getCache(property3, "color");
  }
  getTexture(property3) {
    return this.getCache(property3 === "map" ? "map" : property3 + "Map", "texture");
  }
  setup(builder) {
    const material = builder.context.material;
    const scope = this.scope;
    let node = null;
    if (scope === _MaterialNode.COLOR) {
      const colorNode = material.color !== void 0 ? this.getColor(scope) : vec3();
      if (material.map && material.map.isTexture === true) {
        node = colorNode.mul(this.getTexture("map"));
      } else {
        node = colorNode;
      }
    } else if (scope === _MaterialNode.OPACITY) {
      const opacityNode = this.getFloat(scope);
      if (material.alphaMap && material.alphaMap.isTexture === true) {
        node = opacityNode.mul(this.getTexture("alpha"));
      } else {
        node = opacityNode;
      }
    } else if (scope === _MaterialNode.SPECULAR_STRENGTH) {
      if (material.specularMap && material.specularMap.isTexture === true) {
        node = this.getTexture("specular").r;
      } else {
        node = float(1);
      }
    } else if (scope === _MaterialNode.SPECULAR_INTENSITY) {
      const specularIntensity = this.getFloat(scope);
      if (material.specularMap) {
        node = specularIntensity.mul(this.getTexture(scope).a);
      } else {
        node = specularIntensity;
      }
    } else if (scope === _MaterialNode.SPECULAR_COLOR) {
      const specularColorNode = this.getColor(scope);
      if (material.specularColorMap && material.specularColorMap.isTexture === true) {
        node = specularColorNode.mul(this.getTexture(scope).rgb);
      } else {
        node = specularColorNode;
      }
    } else if (scope === _MaterialNode.ROUGHNESS) {
      const roughnessNode = this.getFloat(scope);
      if (material.roughnessMap && material.roughnessMap.isTexture === true) {
        node = roughnessNode.mul(this.getTexture(scope).g);
      } else {
        node = roughnessNode;
      }
    } else if (scope === _MaterialNode.METALNESS) {
      const metalnessNode = this.getFloat(scope);
      if (material.metalnessMap && material.metalnessMap.isTexture === true) {
        node = metalnessNode.mul(this.getTexture(scope).b);
      } else {
        node = metalnessNode;
      }
    } else if (scope === _MaterialNode.EMISSIVE) {
      const emissiveIntensityNode = this.getFloat("emissiveIntensity");
      const emissiveNode = this.getColor(scope).mul(emissiveIntensityNode);
      if (material.emissiveMap && material.emissiveMap.isTexture === true) {
        node = emissiveNode.mul(this.getTexture(scope));
      } else {
        node = emissiveNode;
      }
    } else if (scope === _MaterialNode.NORMAL) {
      if (material.normalMap) {
        node = normalMap(this.getTexture("normal"), this.getCache("normalScale", "vec2"));
        node.normalMapType = material.normalMapType;
      } else if (material.bumpMap) {
        node = bumpMap(this.getTexture("bump").r, this.getFloat("bumpScale"));
      } else {
        node = normalView;
      }
    } else if (scope === _MaterialNode.CLEARCOAT) {
      const clearcoatNode = this.getFloat(scope);
      if (material.clearcoatMap && material.clearcoatMap.isTexture === true) {
        node = clearcoatNode.mul(this.getTexture(scope).r);
      } else {
        node = clearcoatNode;
      }
    } else if (scope === _MaterialNode.CLEARCOAT_ROUGHNESS) {
      const clearcoatRoughnessNode = this.getFloat(scope);
      if (material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true) {
        node = clearcoatRoughnessNode.mul(this.getTexture(scope).r);
      } else {
        node = clearcoatRoughnessNode;
      }
    } else if (scope === _MaterialNode.CLEARCOAT_NORMAL) {
      if (material.clearcoatNormalMap) {
        node = normalMap(this.getTexture(scope), this.getCache(scope + "Scale", "vec2"));
      } else {
        node = normalView;
      }
    } else if (scope === _MaterialNode.SHEEN) {
      const sheenNode = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      if (material.sheenColorMap && material.sheenColorMap.isTexture === true) {
        node = sheenNode.mul(this.getTexture("sheenColor").rgb);
      } else {
        node = sheenNode;
      }
    } else if (scope === _MaterialNode.SHEEN_ROUGHNESS) {
      const sheenRoughnessNode = this.getFloat(scope);
      if (material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true) {
        node = sheenRoughnessNode.mul(this.getTexture(scope).a);
      } else {
        node = sheenRoughnessNode;
      }
      node = node.clamp(0.07, 1);
    } else if (scope === _MaterialNode.ANISOTROPY) {
      if (material.anisotropyMap && material.anisotropyMap.isTexture === true) {
        const anisotropyPolar = this.getTexture(scope);
        const anisotropyMat = mat2(materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x);
        node = anisotropyMat.mul(anisotropyPolar.rg.mul(2).sub(vec2(1)).normalize().mul(anisotropyPolar.b));
      } else {
        node = materialAnisotropyVector;
      }
    } else if (scope === _MaterialNode.IRIDESCENCE_THICKNESS) {
      const iridescenceThicknessMaximum = reference("1", "float", material.iridescenceThicknessRange);
      if (material.iridescenceThicknessMap) {
        const iridescenceThicknessMinimum = reference("0", "float", material.iridescenceThicknessRange);
        node = iridescenceThicknessMaximum.sub(iridescenceThicknessMinimum).mul(this.getTexture(scope).g).add(iridescenceThicknessMinimum);
      } else {
        node = iridescenceThicknessMaximum;
      }
    } else if (scope === _MaterialNode.TRANSMISSION) {
      const transmissionNode = this.getFloat(scope);
      if (material.transmissionMap) {
        node = transmissionNode.mul(this.getTexture(scope).r);
      } else {
        node = transmissionNode;
      }
    } else if (scope === _MaterialNode.THICKNESS) {
      const thicknessNode = this.getFloat(scope);
      if (material.thicknessMap) {
        node = thicknessNode.mul(this.getTexture(scope).g);
      } else {
        node = thicknessNode;
      }
    } else if (scope === _MaterialNode.IOR) {
      node = this.getFloat(scope);
    } else if (scope === _MaterialNode.LIGHT_MAP) {
      node = this.getTexture(scope).rgb.mul(this.getFloat("lightMapIntensity"));
    } else if (scope === _MaterialNode.AO_MAP) {
      node = this.getTexture(scope).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);
    } else {
      const outputType = this.getNodeType(builder);
      node = this.getCache(scope, outputType);
    }
    return node;
  }
};
MaterialNode.ALPHA_TEST = "alphaTest";
MaterialNode.COLOR = "color";
MaterialNode.OPACITY = "opacity";
MaterialNode.SHININESS = "shininess";
MaterialNode.SPECULAR = "specular";
MaterialNode.SPECULAR_STRENGTH = "specularStrength";
MaterialNode.SPECULAR_INTENSITY = "specularIntensity";
MaterialNode.SPECULAR_COLOR = "specularColor";
MaterialNode.REFLECTIVITY = "reflectivity";
MaterialNode.ROUGHNESS = "roughness";
MaterialNode.METALNESS = "metalness";
MaterialNode.NORMAL = "normal";
MaterialNode.CLEARCOAT = "clearcoat";
MaterialNode.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
MaterialNode.CLEARCOAT_NORMAL = "clearcoatNormal";
MaterialNode.EMISSIVE = "emissive";
MaterialNode.ROTATION = "rotation";
MaterialNode.SHEEN = "sheen";
MaterialNode.SHEEN_ROUGHNESS = "sheenRoughness";
MaterialNode.ANISOTROPY = "anisotropy";
MaterialNode.IRIDESCENCE = "iridescence";
MaterialNode.IRIDESCENCE_IOR = "iridescenceIOR";
MaterialNode.IRIDESCENCE_THICKNESS = "iridescenceThickness";
MaterialNode.IOR = "ior";
MaterialNode.TRANSMISSION = "transmission";
MaterialNode.THICKNESS = "thickness";
MaterialNode.ATTENUATION_DISTANCE = "attenuationDistance";
MaterialNode.ATTENUATION_COLOR = "attenuationColor";
MaterialNode.LINE_SCALE = "scale";
MaterialNode.LINE_DASH_SIZE = "dashSize";
MaterialNode.LINE_GAP_SIZE = "gapSize";
MaterialNode.LINE_WIDTH = "linewidth";
MaterialNode.LINE_DASH_OFFSET = "dashOffset";
MaterialNode.POINT_WIDTH = "pointWidth";
MaterialNode.DISPERSION = "dispersion";
MaterialNode.LIGHT_MAP = "light";
MaterialNode.AO_MAP = "ao";
var materialAlphaTest = nodeImmutable(MaterialNode, MaterialNode.ALPHA_TEST);
var materialColor = nodeImmutable(MaterialNode, MaterialNode.COLOR);
var materialShininess = nodeImmutable(MaterialNode, MaterialNode.SHININESS);
var materialEmissive = nodeImmutable(MaterialNode, MaterialNode.EMISSIVE);
var materialOpacity = nodeImmutable(MaterialNode, MaterialNode.OPACITY);
var materialSpecular = nodeImmutable(MaterialNode, MaterialNode.SPECULAR);
var materialSpecularIntensity = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_INTENSITY);
var materialSpecularColor = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_COLOR);
var materialSpecularStrength = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_STRENGTH);
var materialReflectivity = nodeImmutable(MaterialNode, MaterialNode.REFLECTIVITY);
var materialRoughness = nodeImmutable(MaterialNode, MaterialNode.ROUGHNESS);
var materialMetalness = nodeImmutable(MaterialNode, MaterialNode.METALNESS);
var materialNormal = nodeImmutable(MaterialNode, MaterialNode.NORMAL).context({ getUV: null });
var materialClearcoat = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT);
var materialClearcoatRoughness = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS);
var materialClearcoatNormal = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_NORMAL).context({ getUV: null });
var materialRotation = nodeImmutable(MaterialNode, MaterialNode.ROTATION);
var materialSheen = nodeImmutable(MaterialNode, MaterialNode.SHEEN);
var materialSheenRoughness = nodeImmutable(MaterialNode, MaterialNode.SHEEN_ROUGHNESS);
var materialAnisotropy = nodeImmutable(MaterialNode, MaterialNode.ANISOTROPY);
var materialIridescence = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE);
var materialIridescenceIOR = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_IOR);
var materialIridescenceThickness = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS);
var materialTransmission = nodeImmutable(MaterialNode, MaterialNode.TRANSMISSION);
var materialThickness = nodeImmutable(MaterialNode, MaterialNode.THICKNESS);
var materialIOR = nodeImmutable(MaterialNode, MaterialNode.IOR);
var materialAttenuationDistance = nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_DISTANCE);
var materialAttenuationColor = nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_COLOR);
var materialLineScale = nodeImmutable(MaterialNode, MaterialNode.LINE_SCALE);
var materialLineDashSize = nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_SIZE);
var materialLineGapSize = nodeImmutable(MaterialNode, MaterialNode.LINE_GAP_SIZE);
var materialLineWidth = nodeImmutable(MaterialNode, MaterialNode.LINE_WIDTH);
var materialLineDashOffset = nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_OFFSET);
var materialPointWidth = nodeImmutable(MaterialNode, MaterialNode.POINT_WIDTH);
var materialDispersion = nodeImmutable(MaterialNode, MaterialNode.DISPERSION);
var materialLightMap = nodeImmutable(MaterialNode, MaterialNode.LIGHT_MAP);
var materialAOMap = nodeImmutable(MaterialNode, MaterialNode.AO_MAP);
var materialAnisotropyVector = uniform(new Vector2()).onReference(function(frame) {
  return frame.material;
}).onRenderUpdate(function({ material }) {
  this.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
});
var ModelViewProjectionNode = class extends TempNode {
  static get type() {
    return "ModelViewProjectionNode";
  }
  constructor(positionNode = null) {
    super("vec4");
    this.positionNode = positionNode;
  }
  setup(builder) {
    if (builder.shaderStage === "fragment") {
      return varying(builder.context.mvp);
    }
    const position = this.positionNode || positionLocal;
    const viewMatrix = builder.renderer.nodes.modelViewMatrix || modelViewMatrix;
    return cameraProjectionMatrix.mul(viewMatrix).mul(position);
  }
};
var modelViewProjection = nodeProxy(ModelViewProjectionNode);
var IndexNode = class _IndexNode extends Node {
  static get type() {
    return "IndexNode";
  }
  constructor(scope) {
    super("uint");
    this.scope = scope;
    this.isInstanceIndexNode = true;
  }
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const scope = this.scope;
    let propertyName;
    if (scope === _IndexNode.VERTEX) {
      propertyName = builder.getVertexIndex();
    } else if (scope === _IndexNode.INSTANCE) {
      propertyName = builder.getInstanceIndex();
    } else if (scope === _IndexNode.DRAW) {
      propertyName = builder.getDrawIndex();
    } else if (scope === _IndexNode.INVOCATION_LOCAL) {
      propertyName = builder.getInvocationLocalIndex();
    } else if (scope === _IndexNode.INVOCATION_SUBGROUP) {
      propertyName = builder.getInvocationSubgroupIndex();
    } else if (scope === _IndexNode.SUBGROUP) {
      propertyName = builder.getSubgroupIndex();
    } else {
      throw new Error("THREE.IndexNode: Unknown scope: " + scope);
    }
    let output3;
    if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
      output3 = propertyName;
    } else {
      const nodeVarying = varying(this);
      output3 = nodeVarying.build(builder, nodeType);
    }
    return output3;
  }
};
IndexNode.VERTEX = "vertex";
IndexNode.INSTANCE = "instance";
IndexNode.SUBGROUP = "subgroup";
IndexNode.INVOCATION_LOCAL = "invocationLocal";
IndexNode.INVOCATION_SUBGROUP = "invocationSubgroup";
IndexNode.DRAW = "draw";
var vertexIndex = nodeImmutable(IndexNode, IndexNode.VERTEX);
var instanceIndex = nodeImmutable(IndexNode, IndexNode.INSTANCE);
var subgroupIndex = nodeImmutable(IndexNode, IndexNode.SUBGROUP);
var invocationSubgroupIndex = nodeImmutable(IndexNode, IndexNode.INVOCATION_SUBGROUP);
var invocationLocalIndex = nodeImmutable(IndexNode, IndexNode.INVOCATION_LOCAL);
var drawIndex = nodeImmutable(IndexNode, IndexNode.DRAW);
var InstanceNode = class extends Node {
  static get type() {
    return "InstanceNode";
  }
  constructor(count, instanceMatrix, instanceColor) {
    super("void");
    this.count = count;
    this.instanceMatrix = instanceMatrix;
    this.instanceColor = instanceColor;
    this.instanceMatrixNode = null;
    this.instanceColorNode = null;
    this.updateType = NodeUpdateType.FRAME;
    this.buffer = null;
    this.bufferColor = null;
  }
  setup(builder) {
    const { count, instanceMatrix, instanceColor } = this;
    let { instanceMatrixNode, instanceColorNode } = this;
    if (instanceMatrixNode === null) {
      if (count <= 1e3) {
        instanceMatrixNode = buffer(instanceMatrix.array, "mat4", Math.max(count, 1)).element(instanceIndex);
      } else {
        const buffer3 = new InstancedInterleavedBuffer(instanceMatrix.array, 16, 1);
        this.buffer = buffer3;
        const bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;
        const instanceBuffers = [
          // F.Signature -> bufferAttribute( array, type, stride, offset )
          bufferFn(buffer3, "vec4", 16, 0),
          bufferFn(buffer3, "vec4", 16, 4),
          bufferFn(buffer3, "vec4", 16, 8),
          bufferFn(buffer3, "vec4", 16, 12)
        ];
        instanceMatrixNode = mat4(...instanceBuffers);
      }
      this.instanceMatrixNode = instanceMatrixNode;
    }
    if (instanceColor && instanceColorNode === null) {
      const buffer3 = new InstancedBufferAttribute(instanceColor.array, 3);
      const bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;
      this.bufferColor = buffer3;
      instanceColorNode = vec3(bufferFn(buffer3, "vec3", 3, 0));
      this.instanceColorNode = instanceColorNode;
    }
    const instancePosition = instanceMatrixNode.mul(positionLocal).xyz;
    positionLocal.assign(instancePosition);
    if (builder.hasGeometryAttribute("normal")) {
      const instanceNormal = transformNormal(normalLocal, instanceMatrixNode);
      normalLocal.assign(instanceNormal);
    }
    if (this.instanceColorNode !== null) {
      varyingProperty("vec3", "vInstanceColor").assign(this.instanceColorNode);
    }
  }
  update() {
    if (this.instanceMatrix.usage !== DynamicDrawUsage && this.buffer != null && this.instanceMatrix.version !== this.buffer.version) {
      this.buffer.version = this.instanceMatrix.version;
    }
    if (this.instanceColor && this.instanceColor.usage !== DynamicDrawUsage && this.bufferColor != null && this.instanceColor.version !== this.bufferColor.version) {
      this.bufferColor.version = this.instanceColor.version;
    }
  }
};
var instance = nodeProxy(InstanceNode);
var InstancedMeshNode = class extends InstanceNode {
  static get type() {
    return "InstancedMeshNode";
  }
  constructor(instanceMesh) {
    const { count, instanceMatrix, instanceColor } = instanceMesh;
    super(count, instanceMatrix, instanceColor);
    this.instanceMesh = instanceMesh;
  }
};
var instancedMesh = nodeProxy(InstancedMeshNode);
var BatchNode = class extends Node {
  static get type() {
    return "BatchNode";
  }
  constructor(batchMesh) {
    super("void");
    this.batchMesh = batchMesh;
    this.batchingIdNode = null;
  }
  setup(builder) {
    if (this.batchingIdNode === null) {
      if (builder.getDrawIndex() === null) {
        this.batchingIdNode = instanceIndex;
      } else {
        this.batchingIdNode = drawIndex;
      }
    }
    const getIndirectIndex = Fn(([id]) => {
      const size2 = textureSize(textureLoad(this.batchMesh._indirectTexture), 0);
      const x2 = int(id).modInt(int(size2));
      const y2 = int(id).div(int(size2));
      return textureLoad(this.batchMesh._indirectTexture, ivec2(x2, y2)).x;
    }).setLayout({
      name: "getIndirectIndex",
      type: "uint",
      inputs: [
        { name: "id", type: "int" }
      ]
    });
    const indirectId = getIndirectIndex(int(this.batchingIdNode));
    const matricesTexture = this.batchMesh._matricesTexture;
    const size = textureSize(textureLoad(matricesTexture), 0);
    const j = float(indirectId).mul(4).toInt().toVar();
    const x = j.modInt(size);
    const y = j.div(int(size));
    const batchingMatrix = mat4(
      textureLoad(matricesTexture, ivec2(x, y)),
      textureLoad(matricesTexture, ivec2(x.add(1), y)),
      textureLoad(matricesTexture, ivec2(x.add(2), y)),
      textureLoad(matricesTexture, ivec2(x.add(3), y))
    );
    const colorsTexture = this.batchMesh._colorsTexture;
    if (colorsTexture !== null) {
      const getBatchingColor = Fn(([id]) => {
        const size2 = textureSize(textureLoad(colorsTexture), 0).x;
        const j2 = id;
        const x2 = j2.modInt(size2);
        const y2 = j2.div(size2);
        return textureLoad(colorsTexture, ivec2(x2, y2)).rgb;
      }).setLayout({
        name: "getBatchingColor",
        type: "vec3",
        inputs: [
          { name: "id", type: "int" }
        ]
      });
      const color3 = getBatchingColor(indirectId);
      varyingProperty("vec3", "vBatchColor").assign(color3);
    }
    const bm = mat3(batchingMatrix);
    positionLocal.assign(batchingMatrix.mul(positionLocal));
    const transformedNormal = normalLocal.div(vec3(bm[0].dot(bm[0]), bm[1].dot(bm[1]), bm[2].dot(bm[2])));
    const batchingNormal = bm.mul(transformedNormal).xyz;
    normalLocal.assign(batchingNormal);
    if (builder.hasGeometryAttribute("tangent")) {
      tangentLocal.mulAssign(bm);
    }
  }
};
var batch = nodeProxy(BatchNode);
var _frameId = /* @__PURE__ */ new WeakMap();
var SkinningNode = class extends Node {
  static get type() {
    return "SkinningNode";
  }
  constructor(skinnedMesh, useReference = false) {
    super("void");
    this.skinnedMesh = skinnedMesh;
    this.useReference = useReference;
    this.updateType = NodeUpdateType.OBJECT;
    this.skinIndexNode = attribute("skinIndex", "uvec4");
    this.skinWeightNode = attribute("skinWeight", "vec4");
    let bindMatrixNode, bindMatrixInverseNode, boneMatricesNode;
    if (useReference) {
      bindMatrixNode = reference("bindMatrix", "mat4");
      bindMatrixInverseNode = reference("bindMatrixInverse", "mat4");
      boneMatricesNode = referenceBuffer("skeleton.boneMatrices", "mat4", skinnedMesh.skeleton.bones.length);
    } else {
      bindMatrixNode = uniform(skinnedMesh.bindMatrix, "mat4");
      bindMatrixInverseNode = uniform(skinnedMesh.bindMatrixInverse, "mat4");
      boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, "mat4", skinnedMesh.skeleton.bones.length);
    }
    this.bindMatrixNode = bindMatrixNode;
    this.bindMatrixInverseNode = bindMatrixInverseNode;
    this.boneMatricesNode = boneMatricesNode;
    this.previousBoneMatricesNode = null;
  }
  getSkinnedPosition(boneMatrices = this.boneMatricesNode, position = positionLocal) {
    const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;
    const boneMatX = boneMatrices.element(skinIndexNode.x);
    const boneMatY = boneMatrices.element(skinIndexNode.y);
    const boneMatZ = boneMatrices.element(skinIndexNode.z);
    const boneMatW = boneMatrices.element(skinIndexNode.w);
    const skinVertex = bindMatrixNode.mul(position);
    const skinned = add(
      boneMatX.mul(skinWeightNode.x).mul(skinVertex),
      boneMatY.mul(skinWeightNode.y).mul(skinVertex),
      boneMatZ.mul(skinWeightNode.z).mul(skinVertex),
      boneMatW.mul(skinWeightNode.w).mul(skinVertex)
    );
    return bindMatrixInverseNode.mul(skinned).xyz;
  }
  getSkinnedNormal(boneMatrices = this.boneMatricesNode, normal2 = normalLocal) {
    const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;
    const boneMatX = boneMatrices.element(skinIndexNode.x);
    const boneMatY = boneMatrices.element(skinIndexNode.y);
    const boneMatZ = boneMatrices.element(skinIndexNode.z);
    const boneMatW = boneMatrices.element(skinIndexNode.w);
    let skinMatrix = add(
      skinWeightNode.x.mul(boneMatX),
      skinWeightNode.y.mul(boneMatY),
      skinWeightNode.z.mul(boneMatZ),
      skinWeightNode.w.mul(boneMatW)
    );
    skinMatrix = bindMatrixInverseNode.mul(skinMatrix).mul(bindMatrixNode);
    return skinMatrix.transformDirection(normal2).xyz;
  }
  getPreviousSkinnedPosition(builder) {
    const skinnedMesh = builder.object;
    if (this.previousBoneMatricesNode === null) {
      skinnedMesh.skeleton.previousBoneMatrices = new Float32Array(skinnedMesh.skeleton.boneMatrices);
      this.previousBoneMatricesNode = referenceBuffer("skeleton.previousBoneMatrices", "mat4", skinnedMesh.skeleton.bones.length);
    }
    return this.getSkinnedPosition(this.previousBoneMatricesNode, positionPrevious);
  }
  needsPreviousBoneMatrices(builder) {
    const mrt3 = builder.renderer.getMRT();
    return mrt3 && mrt3.has("velocity");
  }
  setup(builder) {
    if (this.needsPreviousBoneMatrices(builder)) {
      positionPrevious.assign(this.getPreviousSkinnedPosition(builder));
    }
    const skinPosition = this.getSkinnedPosition();
    positionLocal.assign(skinPosition);
    if (builder.hasGeometryAttribute("normal")) {
      const skinNormal = this.getSkinnedNormal();
      normalLocal.assign(skinNormal);
      if (builder.hasGeometryAttribute("tangent")) {
        tangentLocal.assign(skinNormal);
      }
    }
  }
  generate(builder, output3) {
    if (output3 !== "void") {
      return positionLocal.build(builder, output3);
    }
  }
  update(frame) {
    const object = this.useReference ? frame.object : this.skinnedMesh;
    const skeleton = object.skeleton;
    if (_frameId.get(skeleton) === frame.frameId) return;
    _frameId.set(skeleton, frame.frameId);
    if (this.previousBoneMatricesNode !== null) skeleton.previousBoneMatrices.set(skeleton.boneMatrices);
    skeleton.update();
  }
};
var skinning = (skinnedMesh) => nodeObject(new SkinningNode(skinnedMesh));
var skinningReference = (skinnedMesh) => nodeObject(new SkinningNode(skinnedMesh, true));
var LoopNode = class extends Node {
  static get type() {
    return "LoopNode";
  }
  constructor(params = []) {
    super();
    this.params = params;
  }
  getVarName(index) {
    return String.fromCharCode("i".charCodeAt() + index);
  }
  getProperties(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.stackNode !== void 0) return properties;
    const inputs = {};
    for (let i = 0, l = this.params.length - 1; i < l; i++) {
      const param = this.params[i];
      const name = param.isNode !== true && param.name || this.getVarName(i);
      const type = param.isNode !== true && param.type || "int";
      inputs[name] = expression(name, type);
    }
    const stack3 = builder.addStack();
    properties.returnsNode = this.params[this.params.length - 1](inputs, stack3, builder);
    properties.stackNode = stack3;
    builder.removeStack();
    return properties;
  }
  getNodeType(builder) {
    const { returnsNode } = this.getProperties(builder);
    return returnsNode ? returnsNode.getNodeType(builder) : "void";
  }
  setup(builder) {
    this.getProperties(builder);
  }
  generate(builder) {
    const properties = this.getProperties(builder);
    const params = this.params;
    const stackNode = properties.stackNode;
    for (let i = 0, l = params.length - 1; i < l; i++) {
      const param = params[i];
      let start = null, end = null, name = null, type = null, condition = null, update = null;
      if (param.isNode) {
        type = "int";
        name = this.getVarName(i);
        start = "0";
        end = param.build(builder, type);
        condition = "<";
      } else {
        type = param.type || "int";
        name = param.name || this.getVarName(i);
        start = param.start;
        end = param.end;
        condition = param.condition;
        update = param.update;
        if (typeof start === "number") start = builder.generateConst(type, start);
        else if (start && start.isNode) start = start.build(builder, type);
        if (typeof end === "number") end = builder.generateConst(type, end);
        else if (end && end.isNode) end = end.build(builder, type);
        if (start !== void 0 && end === void 0) {
          start = start + " - 1";
          end = "0";
          condition = ">=";
        } else if (end !== void 0 && start === void 0) {
          start = "0";
          condition = "<";
        }
        if (condition === void 0) {
          if (Number(start) > Number(end)) {
            condition = ">=";
          } else {
            condition = "<";
          }
        }
      }
      const internalParam = { start, end, condition };
      const startSnippet = internalParam.start;
      const endSnippet = internalParam.end;
      let declarationSnippet = "";
      let conditionalSnippet = "";
      let updateSnippet = "";
      if (!update) {
        if (type === "int" || type === "uint") {
          if (condition.includes("<")) update = "++";
          else update = "--";
        } else {
          if (condition.includes("<")) update = "+= 1.";
          else update = "-= 1.";
        }
      }
      declarationSnippet += builder.getVar(type, name) + " = " + startSnippet;
      conditionalSnippet += name + " " + condition + " " + endSnippet;
      updateSnippet += name + " " + update;
      const forSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;
      builder.addFlowCode((i === 0 ? "\n" : "") + builder.tab + forSnippet + " {\n\n").addFlowTab();
    }
    const stackSnippet = stackNode.build(builder, "void");
    const returnsSnippet = properties.returnsNode ? properties.returnsNode.build(builder) : "";
    builder.removeFlowTab().addFlowCode("\n" + builder.tab + stackSnippet);
    for (let i = 0, l = this.params.length - 1; i < l; i++) {
      builder.addFlowCode((i === 0 ? "" : builder.tab) + "}\n\n").removeFlowTab();
    }
    builder.addFlowTab();
    return returnsSnippet;
  }
};
var Loop = (...params) => nodeObject(new LoopNode(nodeArray(params, "int"))).append();
var Continue = () => expression("continue").append();
var Break = () => expression("break").append();
var loop = (...params) => {
  console.warn("TSL.LoopNode: loop() has been renamed to Loop().");
  return Loop(...params);
};
var _morphTextures = /* @__PURE__ */ new WeakMap();
var _morphVec4 = new Vector4();
var getMorph = Fn(({ bufferMap, influence, stride, width, depth: depth3, offset }) => {
  const texelIndex = int(vertexIndex).mul(stride).add(offset);
  const y = texelIndex.div(width);
  const x = texelIndex.sub(y.mul(width));
  const bufferAttrib = textureLoad(bufferMap, ivec2(x, y)).depth(depth3);
  return bufferAttrib.mul(influence);
});
function getEntry(geometry) {
  const hasMorphPosition = geometry.morphAttributes.position !== void 0;
  const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
  const hasMorphColors = geometry.morphAttributes.color !== void 0;
  const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
  const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
  let entry = _morphTextures.get(geometry);
  if (entry === void 0 || entry.count !== morphTargetsCount) {
    let disposeTexture = function() {
      bufferTexture.dispose();
      _morphTextures.delete(geometry);
      geometry.removeEventListener("dispose", disposeTexture);
    };
    if (entry !== void 0) entry.texture.dispose();
    const morphTargets = geometry.morphAttributes.position || [];
    const morphNormals = geometry.morphAttributes.normal || [];
    const morphColors = geometry.morphAttributes.color || [];
    let vertexDataCount = 0;
    if (hasMorphPosition === true) vertexDataCount = 1;
    if (hasMorphNormals === true) vertexDataCount = 2;
    if (hasMorphColors === true) vertexDataCount = 3;
    let width = geometry.attributes.position.count * vertexDataCount;
    let height = 1;
    const maxTextureSize = 4096;
    if (width > maxTextureSize) {
      height = Math.ceil(width / maxTextureSize);
      width = maxTextureSize;
    }
    const buffer3 = new Float32Array(width * height * 4 * morphTargetsCount);
    const bufferTexture = new DataArrayTexture(buffer3, width, height, morphTargetsCount);
    bufferTexture.type = FloatType;
    bufferTexture.needsUpdate = true;
    const vertexDataStride = vertexDataCount * 4;
    for (let i = 0; i < morphTargetsCount; i++) {
      const morphTarget = morphTargets[i];
      const morphNormal = morphNormals[i];
      const morphColor = morphColors[i];
      const offset = width * height * 4 * i;
      for (let j = 0; j < morphTarget.count; j++) {
        const stride = j * vertexDataStride;
        if (hasMorphPosition === true) {
          _morphVec4.fromBufferAttribute(morphTarget, j);
          buffer3[offset + stride + 0] = _morphVec4.x;
          buffer3[offset + stride + 1] = _morphVec4.y;
          buffer3[offset + stride + 2] = _morphVec4.z;
          buffer3[offset + stride + 3] = 0;
        }
        if (hasMorphNormals === true) {
          _morphVec4.fromBufferAttribute(morphNormal, j);
          buffer3[offset + stride + 4] = _morphVec4.x;
          buffer3[offset + stride + 5] = _morphVec4.y;
          buffer3[offset + stride + 6] = _morphVec4.z;
          buffer3[offset + stride + 7] = 0;
        }
        if (hasMorphColors === true) {
          _morphVec4.fromBufferAttribute(morphColor, j);
          buffer3[offset + stride + 8] = _morphVec4.x;
          buffer3[offset + stride + 9] = _morphVec4.y;
          buffer3[offset + stride + 10] = _morphVec4.z;
          buffer3[offset + stride + 11] = morphColor.itemSize === 4 ? _morphVec4.w : 1;
        }
      }
    }
    entry = {
      count: morphTargetsCount,
      texture: bufferTexture,
      stride: vertexDataCount,
      size: new Vector2(width, height)
    };
    _morphTextures.set(geometry, entry);
    geometry.addEventListener("dispose", disposeTexture);
  }
  return entry;
}
var MorphNode = class extends Node {
  static get type() {
    return "MorphNode";
  }
  constructor(mesh) {
    super("void");
    this.mesh = mesh;
    this.morphBaseInfluence = uniform(1);
    this.updateType = NodeUpdateType.OBJECT;
  }
  setup(builder) {
    const { geometry } = builder;
    const hasMorphPosition = geometry.morphAttributes.position !== void 0;
    const hasMorphNormals = geometry.hasAttribute("normal") && geometry.morphAttributes.normal !== void 0;
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    const { texture: bufferMap, stride, size } = getEntry(geometry);
    if (hasMorphPosition === true) positionLocal.mulAssign(this.morphBaseInfluence);
    if (hasMorphNormals === true) normalLocal.mulAssign(this.morphBaseInfluence);
    const width = int(size.width);
    Loop(morphTargetsCount, ({ i }) => {
      const influence = float(0).toVar();
      if (this.mesh.count > 1 && (this.mesh.morphTexture !== null && this.mesh.morphTexture !== void 0)) {
        influence.assign(textureLoad(this.mesh.morphTexture, ivec2(int(i).add(1), int(instanceIndex))).r);
      } else {
        influence.assign(reference("morphTargetInfluences", "float").element(i).toVar());
      }
      if (hasMorphPosition === true) {
        positionLocal.addAssign(getMorph({
          bufferMap,
          influence,
          stride,
          width,
          depth: i,
          offset: int(0)
        }));
      }
      if (hasMorphNormals === true) {
        normalLocal.addAssign(getMorph({
          bufferMap,
          influence,
          stride,
          width,
          depth: i,
          offset: int(1)
        }));
      }
    });
  }
  update() {
    const morphBaseInfluence = this.morphBaseInfluence;
    if (this.mesh.geometry.morphTargetsRelative) {
      morphBaseInfluence.value = 1;
    } else {
      morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce((a, b) => a + b, 0);
    }
  }
};
var morphReference = nodeProxy(MorphNode);
var LightingNode = class extends Node {
  static get type() {
    return "LightingNode";
  }
  constructor() {
    super("vec3");
    this.isLightingNode = true;
  }
  generate() {
    console.warn("Abstract function.");
  }
};
var AONode = class extends LightingNode {
  static get type() {
    return "AONode";
  }
  constructor(aoNode = null) {
    super();
    this.aoNode = aoNode;
  }
  setup(builder) {
    builder.context.ambientOcclusion.mulAssign(this.aoNode);
  }
};
var LightingContextNode = class extends ContextNode {
  static get type() {
    return "LightingContextNode";
  }
  constructor(node, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {
    super(node);
    this.lightingModel = lightingModel;
    this.backdropNode = backdropNode;
    this.backdropAlphaNode = backdropAlphaNode;
    this._value = null;
  }
  getContext() {
    const { backdropNode, backdropAlphaNode } = this;
    const directDiffuse = vec3().toVar("directDiffuse"), directSpecular = vec3().toVar("directSpecular"), indirectDiffuse = vec3().toVar("indirectDiffuse"), indirectSpecular = vec3().toVar("indirectSpecular");
    const reflectedLight = {
      directDiffuse,
      directSpecular,
      indirectDiffuse,
      indirectSpecular
    };
    const context3 = {
      radiance: vec3().toVar("radiance"),
      irradiance: vec3().toVar("irradiance"),
      iblIrradiance: vec3().toVar("iblIrradiance"),
      ambientOcclusion: float(1).toVar("ambientOcclusion"),
      reflectedLight,
      backdrop: backdropNode,
      backdropAlpha: backdropAlphaNode
    };
    return context3;
  }
  setup(builder) {
    this.value = this._value || (this._value = this.getContext());
    this.value.lightingModel = this.lightingModel || builder.context.lightingModel;
    return super.setup(builder);
  }
};
var lightingContext = nodeProxy(LightingContextNode);
var IrradianceNode = class extends LightingNode {
  static get type() {
    return "IrradianceNode";
  }
  constructor(node) {
    super();
    this.node = node;
  }
  setup(builder) {
    builder.context.irradiance.addAssign(this.node);
  }
};
var screenSizeVec;
var viewportVec;
var ScreenNode = class _ScreenNode extends Node {
  static get type() {
    return "ScreenNode";
  }
  constructor(scope) {
    super();
    this.scope = scope;
    this.isViewportNode = true;
  }
  getNodeType() {
    if (this.scope === _ScreenNode.VIEWPORT) return "vec4";
    else return "vec2";
  }
  getUpdateType() {
    let updateType = NodeUpdateType.NONE;
    if (this.scope === _ScreenNode.SIZE || this.scope === _ScreenNode.VIEWPORT) {
      updateType = NodeUpdateType.RENDER;
    }
    this.updateType = updateType;
    return updateType;
  }
  update({ renderer }) {
    const renderTarget = renderer.getRenderTarget();
    if (this.scope === _ScreenNode.VIEWPORT) {
      if (renderTarget !== null) {
        viewportVec.copy(renderTarget.viewport);
      } else {
        renderer.getViewport(viewportVec);
        viewportVec.multiplyScalar(renderer.getPixelRatio());
      }
    } else {
      if (renderTarget !== null) {
        screenSizeVec.width = renderTarget.width;
        screenSizeVec.height = renderTarget.height;
      } else {
        renderer.getDrawingBufferSize(screenSizeVec);
      }
    }
  }
  setup() {
    const scope = this.scope;
    let output3 = null;
    if (scope === _ScreenNode.SIZE) {
      output3 = uniform(screenSizeVec || (screenSizeVec = new Vector2()));
    } else if (scope === _ScreenNode.VIEWPORT) {
      output3 = uniform(viewportVec || (viewportVec = new Vector4()));
    } else {
      output3 = vec2(screenCoordinate.div(screenSize));
    }
    return output3;
  }
  generate(builder) {
    if (this.scope === _ScreenNode.COORDINATE) {
      let coord = builder.getFragCoord();
      if (builder.isFlipY()) {
        const size = builder.getNodeProperties(screenSize).outputNode.build(builder);
        coord = `${builder.getType("vec2")}( ${coord}.x, ${size}.y - ${coord}.y )`;
      }
      return coord;
    }
    return super.generate(builder);
  }
};
ScreenNode.COORDINATE = "coordinate";
ScreenNode.VIEWPORT = "viewport";
ScreenNode.SIZE = "size";
ScreenNode.UV = "uv";
var screenUV = nodeImmutable(ScreenNode, ScreenNode.UV);
var screenSize = nodeImmutable(ScreenNode, ScreenNode.SIZE);
var screenCoordinate = nodeImmutable(ScreenNode, ScreenNode.COORDINATE);
var viewport = nodeImmutable(ScreenNode, ScreenNode.VIEWPORT);
var viewportSize = viewport.zw;
var viewportCoordinate = screenCoordinate.sub(viewport.xy);
var viewportUV = viewportCoordinate.div(viewportSize);
var viewportResolution = Fn(() => {
  console.warn('TSL.ViewportNode: "viewportResolution" is deprecated. Use "screenSize" instead.');
  return screenSize;
}, "vec2").once()();
var viewportTopLeft = Fn(() => {
  console.warn('TSL.ViewportNode: "viewportTopLeft" is deprecated. Use "screenUV" instead.');
  return screenUV;
}, "vec2").once()();
var viewportBottomLeft = Fn(() => {
  console.warn('TSL.ViewportNode: "viewportBottomLeft" is deprecated. Use "screenUV.flipY()" instead.');
  return screenUV.flipY();
}, "vec2").once()();
var _size$4 = new Vector2();
var ViewportTextureNode = class extends TextureNode {
  static get type() {
    return "ViewportTextureNode";
  }
  constructor(uvNode = screenUV, levelNode = null, framebufferTexture = null) {
    if (framebufferTexture === null) {
      framebufferTexture = new FramebufferTexture();
      framebufferTexture.minFilter = LinearMipmapLinearFilter;
    }
    super(framebufferTexture, uvNode, levelNode);
    this.generateMipmaps = false;
    this.isOutputTextureNode = true;
    this.updateBeforeType = NodeUpdateType.FRAME;
  }
  updateBefore(frame) {
    const renderer = frame.renderer;
    renderer.getDrawingBufferSize(_size$4);
    const framebufferTexture = this.value;
    if (framebufferTexture.image.width !== _size$4.width || framebufferTexture.image.height !== _size$4.height) {
      framebufferTexture.image.width = _size$4.width;
      framebufferTexture.image.height = _size$4.height;
      framebufferTexture.needsUpdate = true;
    }
    const currentGenerateMipmaps = framebufferTexture.generateMipmaps;
    framebufferTexture.generateMipmaps = this.generateMipmaps;
    renderer.copyFramebufferToTexture(framebufferTexture);
    framebufferTexture.generateMipmaps = currentGenerateMipmaps;
  }
  clone() {
    const viewportTextureNode = new this.constructor(this.uvNode, this.levelNode, this.value);
    viewportTextureNode.generateMipmaps = this.generateMipmaps;
    return viewportTextureNode;
  }
};
var viewportTexture = nodeProxy(ViewportTextureNode);
var viewportMipTexture = nodeProxy(ViewportTextureNode, null, null, { generateMipmaps: true });
var sharedDepthbuffer = null;
var ViewportDepthTextureNode = class extends ViewportTextureNode {
  static get type() {
    return "ViewportDepthTextureNode";
  }
  constructor(uvNode = screenUV, levelNode = null) {
    if (sharedDepthbuffer === null) {
      sharedDepthbuffer = new DepthTexture();
    }
    super(uvNode, levelNode, sharedDepthbuffer);
  }
};
var viewportDepthTexture = nodeProxy(ViewportDepthTextureNode);
var ViewportDepthNode = class _ViewportDepthNode extends Node {
  static get type() {
    return "ViewportDepthNode";
  }
  constructor(scope, valueNode = null) {
    super("float");
    this.scope = scope;
    this.valueNode = valueNode;
    this.isViewportDepthNode = true;
  }
  generate(builder) {
    const { scope } = this;
    if (scope === _ViewportDepthNode.DEPTH_BASE) {
      return builder.getFragDepth();
    }
    return super.generate(builder);
  }
  setup({ camera }) {
    const { scope } = this;
    const value = this.valueNode;
    let node = null;
    if (scope === _ViewportDepthNode.DEPTH_BASE) {
      if (value !== null) {
        node = depthBase().assign(value);
      }
    } else if (scope === _ViewportDepthNode.DEPTH) {
      if (camera.isPerspectiveCamera) {
        node = viewZToPerspectiveDepth(positionView.z, cameraNear, cameraFar);
      } else {
        node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
      }
    } else if (scope === _ViewportDepthNode.LINEAR_DEPTH) {
      if (value !== null) {
        if (camera.isPerspectiveCamera) {
          const viewZ = perspectiveDepthToViewZ(value, cameraNear, cameraFar);
          node = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
        } else {
          node = value;
        }
      } else {
        node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
      }
    }
    return node;
  }
};
ViewportDepthNode.DEPTH_BASE = "depthBase";
ViewportDepthNode.DEPTH = "depth";
ViewportDepthNode.LINEAR_DEPTH = "linearDepth";
var viewZToOrthographicDepth = (viewZ, near, far) => viewZ.add(near).div(near.sub(far));
var orthographicDepthToViewZ = (depth3, near, far) => near.sub(far).mul(depth3).sub(near);
var viewZToPerspectiveDepth = (viewZ, near, far) => near.add(viewZ).mul(far).div(far.sub(near).mul(viewZ));
var perspectiveDepthToViewZ = (depth3, near, far) => near.mul(far).div(far.sub(near).mul(depth3).sub(far));
var viewZToLogarithmicDepth = (viewZ, near, far) => {
  near = near.max(1e-6).toVar();
  const numerator = log2(viewZ.negate().div(near));
  const denominator = log2(far.div(near));
  return numerator.div(denominator);
};
var logarithmicDepthToViewZ = (depth3, near, far) => {
  const exponent = depth3.mul(log(far.div(near)));
  return float(Math.E).pow(exponent).mul(near).negate();
};
var depthBase = nodeProxy(ViewportDepthNode, ViewportDepthNode.DEPTH_BASE);
var depth = nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH);
var linearDepth = nodeProxy(ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH);
var viewportLinearDepth = linearDepth(viewportDepthTexture());
depth.assign = (value) => depthBase(value);
var BuiltinNode = class extends Node {
  constructor(name) {
    super("float");
    this.name = name;
    this.isBuiltinNode = true;
  }
  generate() {
    return this.name;
  }
};
var builtin = nodeProxy(BuiltinNode);
var ClippingNode = class _ClippingNode extends Node {
  static get type() {
    return "ClippingNode";
  }
  constructor(scope = _ClippingNode.DEFAULT) {
    super();
    this.scope = scope;
  }
  setup(builder) {
    super.setup(builder);
    const clippingContext = builder.clippingContext;
    const { intersectionPlanes, unionPlanes } = clippingContext;
    this.hardwareClipping = builder.material.hardwareClipping;
    if (this.scope === _ClippingNode.ALPHA_TO_COVERAGE) {
      return this.setupAlphaToCoverage(intersectionPlanes, unionPlanes);
    } else if (this.scope === _ClippingNode.HARDWARE) {
      return this.setupHardwareClipping(unionPlanes, builder);
    } else {
      return this.setupDefault(intersectionPlanes, unionPlanes);
    }
  }
  setupAlphaToCoverage(intersectionPlanes, unionPlanes) {
    return Fn(() => {
      const distanceToPlane = float().toVar("distanceToPlane");
      const distanceGradient = float().toVar("distanceToGradient");
      const clipOpacity = float(1).toVar("clipOpacity");
      const numUnionPlanes = unionPlanes.length;
      if (!this.hardwareClipping && numUnionPlanes > 0) {
        const clippingPlanes = uniformArray(unionPlanes);
        Loop(numUnionPlanes, ({ i }) => {
          const plane = clippingPlanes.element(i);
          distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));
          distanceGradient.assign(distanceToPlane.fwidth().div(2));
          clipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane));
        });
      }
      const numIntersectionPlanes = intersectionPlanes.length;
      if (numIntersectionPlanes > 0) {
        const clippingPlanes = uniformArray(intersectionPlanes);
        const intersectionClipOpacity = float(1).toVar("intersectionClipOpacity");
        Loop(numIntersectionPlanes, ({ i }) => {
          const plane = clippingPlanes.element(i);
          distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));
          distanceGradient.assign(distanceToPlane.fwidth().div(2));
          intersectionClipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane).oneMinus());
        });
        clipOpacity.mulAssign(intersectionClipOpacity.oneMinus());
      }
      diffuseColor.a.mulAssign(clipOpacity);
      diffuseColor.a.equal(0).discard();
    })();
  }
  setupDefault(intersectionPlanes, unionPlanes) {
    return Fn(() => {
      const numUnionPlanes = unionPlanes.length;
      if (!this.hardwareClipping && numUnionPlanes > 0) {
        const clippingPlanes = uniformArray(unionPlanes);
        Loop(numUnionPlanes, ({ i }) => {
          const plane = clippingPlanes.element(i);
          positionView.dot(plane.xyz).greaterThan(plane.w).discard();
        });
      }
      const numIntersectionPlanes = intersectionPlanes.length;
      if (numIntersectionPlanes > 0) {
        const clippingPlanes = uniformArray(intersectionPlanes);
        const clipped = bool(true).toVar("clipped");
        Loop(numIntersectionPlanes, ({ i }) => {
          const plane = clippingPlanes.element(i);
          clipped.assign(positionView.dot(plane.xyz).greaterThan(plane.w).and(clipped));
        });
        clipped.discard();
      }
    })();
  }
  setupHardwareClipping(unionPlanes, builder) {
    const numUnionPlanes = unionPlanes.length;
    builder.enableHardwareClipping(numUnionPlanes);
    return Fn(() => {
      const clippingPlanes = uniformArray(unionPlanes);
      const hw_clip_distances = builtin(builder.getClipDistance());
      Loop(numUnionPlanes, ({ i }) => {
        const plane = clippingPlanes.element(i);
        const distance3 = positionView.dot(plane.xyz).sub(plane.w).negate();
        hw_clip_distances.element(i).assign(distance3);
      });
    })();
  }
};
ClippingNode.ALPHA_TO_COVERAGE = "alphaToCoverage";
ClippingNode.DEFAULT = "default";
ClippingNode.HARDWARE = "hardware";
var clipping = () => nodeObject(new ClippingNode());
var clippingAlpha = () => nodeObject(new ClippingNode(ClippingNode.ALPHA_TO_COVERAGE));
var hardwareClipping = () => nodeObject(new ClippingNode(ClippingNode.HARDWARE));
var ALPHA_HASH_SCALE = 0.05;
var hash2D = Fn(([value]) => {
  return fract(mul(1e4, sin(mul(17, value.x).add(mul(0.1, value.y)))).mul(add(0.1, abs(sin(mul(13, value.y).add(value.x))))));
});
var hash3D = Fn(([value]) => {
  return hash2D(vec2(hash2D(value.xy), value.z));
});
var getAlphaHashThreshold = Fn(([position]) => {
  const maxDeriv = max$1(
    length(dFdx(position.xyz)),
    length(dFdy(position.xyz))
  );
  const pixScale = float(1).div(float(ALPHA_HASH_SCALE).mul(maxDeriv)).toVar("pixScale");
  const pixScales = vec2(
    exp2(floor(log2(pixScale))),
    exp2(ceil(log2(pixScale)))
  );
  const alpha = vec2(
    hash3D(floor(pixScales.x.mul(position.xyz))),
    hash3D(floor(pixScales.y.mul(position.xyz)))
  );
  const lerpFactor = fract(log2(pixScale));
  const x = add(mul(lerpFactor.oneMinus(), alpha.x), mul(lerpFactor, alpha.y));
  const a = min$1(lerpFactor, lerpFactor.oneMinus());
  const cases = vec3(
    x.mul(x).div(mul(2, a).mul(sub(1, a))),
    x.sub(mul(0.5, a)).div(sub(1, a)),
    sub(1, sub(1, x).mul(sub(1, x)).div(mul(2, a).mul(sub(1, a))))
  );
  const threshold3 = x.lessThan(a.oneMinus()).select(x.lessThan(a).select(cases.x, cases.y), cases.z);
  return clamp(threshold3, 1e-6, 1);
}).setLayout({
  name: "getAlphaHashThreshold",
  type: "float",
  inputs: [
    { name: "position", type: "vec3" }
  ]
});
var NodeMaterial = class extends Material {
  static get type() {
    return "NodeMaterial";
  }
  get type() {
    return this.constructor.type;
  }
  set type(_value) {
  }
  constructor() {
    super();
    this.isNodeMaterial = true;
    this.forceSinglePass = false;
    this.fog = true;
    this.lights = false;
    this.hardwareClipping = false;
    this.lightsNode = null;
    this.envNode = null;
    this.aoNode = null;
    this.colorNode = null;
    this.normalNode = null;
    this.opacityNode = null;
    this.backdropNode = null;
    this.backdropAlphaNode = null;
    this.alphaTestNode = null;
    this.positionNode = null;
    this.geometryNode = null;
    this.depthNode = null;
    this.shadowPositionNode = null;
    this.receivedShadowNode = null;
    this.castShadowNode = null;
    this.outputNode = null;
    this.mrtNode = null;
    this.fragmentNode = null;
    this.vertexNode = null;
  }
  customProgramCacheKey() {
    return this.type + getCacheKey$1(this);
  }
  build(builder) {
    this.setup(builder);
  }
  setupObserver(builder) {
    return new NodeMaterialObserver(builder);
  }
  setup(builder) {
    builder.context.setupNormal = () => this.setupNormal(builder);
    const renderer = builder.renderer;
    const renderTarget = renderer.getRenderTarget();
    builder.addStack();
    builder.stack.outputNode = this.vertexNode || this.setupPosition(builder);
    if (this.geometryNode !== null) {
      builder.stack.outputNode = builder.stack.outputNode.bypass(this.geometryNode);
    }
    builder.addFlow("vertex", builder.removeStack());
    builder.addStack();
    let resultNode;
    const clippingNode = this.setupClipping(builder);
    if (this.depthWrite === true) {
      if (renderTarget !== null) {
        if (renderTarget.depthBuffer === true) this.setupDepth(builder);
      } else {
        if (renderer.depth === true) this.setupDepth(builder);
      }
    }
    if (this.fragmentNode === null) {
      this.setupDiffuseColor(builder);
      this.setupVariants(builder);
      const outgoingLightNode = this.setupLighting(builder);
      if (clippingNode !== null) builder.stack.add(clippingNode);
      const basicOutput = vec4(outgoingLightNode, diffuseColor.a).max(0);
      resultNode = this.setupOutput(builder, basicOutput);
      output.assign(resultNode);
      if (this.outputNode !== null) resultNode = this.outputNode;
      if (renderTarget !== null) {
        const mrt3 = renderer.getMRT();
        const materialMRT = this.mrtNode;
        if (mrt3 !== null) {
          resultNode = mrt3;
          if (materialMRT !== null) {
            resultNode = mrt3.merge(materialMRT);
          }
        } else if (materialMRT !== null) {
          resultNode = materialMRT;
        }
      }
    } else {
      let fragmentNode = this.fragmentNode;
      if (fragmentNode.isOutputStructNode !== true) {
        fragmentNode = vec4(fragmentNode);
      }
      resultNode = this.setupOutput(builder, fragmentNode);
    }
    builder.stack.outputNode = resultNode;
    builder.addFlow("fragment", builder.removeStack());
    builder.monitor = this.setupObserver(builder);
  }
  setupClipping(builder) {
    if (builder.clippingContext === null) return null;
    const { unionPlanes, intersectionPlanes } = builder.clippingContext;
    let result = null;
    if (unionPlanes.length > 0 || intersectionPlanes.length > 0) {
      const samples = builder.renderer.samples;
      if (this.alphaToCoverage && samples > 1) {
        result = clippingAlpha();
      } else {
        builder.stack.add(clipping());
      }
    }
    return result;
  }
  setupHardwareClipping(builder) {
    this.hardwareClipping = false;
    if (builder.clippingContext === null) return;
    const candidateCount = builder.clippingContext.unionPlanes.length;
    if (candidateCount > 0 && candidateCount <= 8 && builder.isAvailable("clipDistance")) {
      builder.stack.add(hardwareClipping());
      this.hardwareClipping = true;
    }
    return;
  }
  setupDepth(builder) {
    const { renderer, camera } = builder;
    let depthNode = this.depthNode;
    if (depthNode === null) {
      const mrt3 = renderer.getMRT();
      if (mrt3 && mrt3.has("depth")) {
        depthNode = mrt3.get("depth");
      } else if (renderer.logarithmicDepthBuffer === true) {
        if (camera.isPerspectiveCamera) {
          depthNode = viewZToLogarithmicDepth(positionView.z, cameraNear, cameraFar);
        } else {
          depthNode = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
        }
      }
    }
    if (depthNode !== null) {
      depth.assign(depthNode).append();
    }
  }
  setupPosition(builder) {
    const { object } = builder;
    const geometry = object.geometry;
    builder.addStack();
    if (geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color) {
      morphReference(object).append();
    }
    if (object.isSkinnedMesh === true) {
      skinningReference(object).append();
    }
    if (this.displacementMap) {
      const displacementMap = materialReference("displacementMap", "texture");
      const displacementScale = materialReference("displacementScale", "float");
      const displacementBias = materialReference("displacementBias", "float");
      positionLocal.addAssign(normalLocal.normalize().mul(displacementMap.x.mul(displacementScale).add(displacementBias)));
    }
    if (object.isBatchedMesh) {
      batch(object).append();
    }
    if (object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true) {
      instancedMesh(object).append();
    }
    if (this.positionNode !== null) {
      positionLocal.assign(this.positionNode);
    }
    this.setupHardwareClipping(builder);
    const mvp = modelViewProjection();
    builder.context.vertex = builder.removeStack();
    builder.context.mvp = mvp;
    return mvp;
  }
  setupDiffuseColor({ object, geometry }) {
    let colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;
    if (this.vertexColors === true && geometry.hasAttribute("color")) {
      colorNode = vec4(colorNode.xyz.mul(attribute("color", "vec3")), colorNode.a);
    }
    if (object.instanceColor) {
      const instanceColor = varyingProperty("vec3", "vInstanceColor");
      colorNode = instanceColor.mul(colorNode);
    }
    if (object.isBatchedMesh && object._colorsTexture) {
      const batchColor = varyingProperty("vec3", "vBatchColor");
      colorNode = batchColor.mul(colorNode);
    }
    diffuseColor.assign(colorNode);
    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
    diffuseColor.a.assign(diffuseColor.a.mul(opacityNode));
    if (this.alphaTestNode !== null || this.alphaTest > 0) {
      const alphaTestNode = this.alphaTestNode !== null ? float(this.alphaTestNode) : materialAlphaTest;
      diffuseColor.a.lessThanEqual(alphaTestNode).discard();
    }
    if (this.alphaHash === true) {
      diffuseColor.a.lessThan(getAlphaHashThreshold(positionLocal)).discard();
    }
    if (this.transparent === false && this.blending === NormalBlending && this.alphaToCoverage === false) {
      diffuseColor.a.assign(1);
    }
  }
  setupVariants() {
  }
  setupOutgoingLight() {
    return this.lights === true ? vec3(0) : diffuseColor.rgb;
  }
  setupNormal() {
    return this.normalNode ? vec3(this.normalNode) : materialNormal;
  }
  setupEnvironment() {
    let node = null;
    if (this.envNode) {
      node = this.envNode;
    } else if (this.envMap) {
      node = this.envMap.isCubeTexture ? materialReference("envMap", "cubeTexture") : materialReference("envMap", "texture");
    }
    return node;
  }
  setupLightMap(builder) {
    let node = null;
    if (builder.material.lightMap) {
      node = new IrradianceNode(materialLightMap);
    }
    return node;
  }
  setupLights(builder) {
    const materialLightsNode = [];
    const envNode = this.setupEnvironment(builder);
    if (envNode && envNode.isLightingNode) {
      materialLightsNode.push(envNode);
    }
    const lightMapNode = this.setupLightMap(builder);
    if (lightMapNode && lightMapNode.isLightingNode) {
      materialLightsNode.push(lightMapNode);
    }
    if (this.aoNode !== null || builder.material.aoMap) {
      const aoNode = this.aoNode !== null ? this.aoNode : materialAOMap;
      materialLightsNode.push(new AONode(aoNode));
    }
    let lightsN = this.lightsNode || builder.lightsNode;
    if (materialLightsNode.length > 0) {
      lightsN = builder.renderer.lighting.createNode([...lightsN.getLights(), ...materialLightsNode]);
    }
    return lightsN;
  }
  setupLightingModel() {
  }
  setupLighting(builder) {
    const { material } = builder;
    const { backdropNode, backdropAlphaNode, emissiveNode } = this;
    const lights3 = this.lights === true || this.lightsNode !== null;
    const lightsNode = lights3 ? this.setupLights(builder) : null;
    let outgoingLightNode = this.setupOutgoingLight(builder);
    if (lightsNode && lightsNode.getScope().hasLights) {
      const lightingModel = this.setupLightingModel(builder);
      outgoingLightNode = lightingContext(lightsNode, lightingModel, backdropNode, backdropAlphaNode);
    } else if (backdropNode !== null) {
      outgoingLightNode = vec3(backdropAlphaNode !== null ? mix(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);
    }
    if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {
      emissive.assign(vec3(emissiveNode ? emissiveNode : materialEmissive));
      outgoingLightNode = outgoingLightNode.add(emissive);
    }
    return outgoingLightNode;
  }
  setupOutput(builder, outputNode) {
    if (this.fog === true) {
      const fogNode = builder.fogNode;
      if (fogNode) outputNode = vec4(fogNode.mix(outputNode.rgb, fogNode.colorNode), outputNode.a);
    }
    return outputNode;
  }
  setDefaultValues(material) {
    for (const property3 in material) {
      const value = material[property3];
      if (this[property3] === void 0) {
        this[property3] = value;
        if (value && value.clone) this[property3] = value.clone();
      }
    }
    const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);
    for (const key in descriptors) {
      if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === void 0 && descriptors[key].get !== void 0) {
        Object.defineProperty(this.constructor.prototype, key, descriptors[key]);
      }
    }
  }
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    const data = Material.prototype.toJSON.call(this, meta);
    const nodeChildren = getNodeChildren(this);
    data.inputNodes = {};
    for (const { property: property3, childNode } of nodeChildren) {
      data.inputNodes[property3] = childNode.toJSON(meta).uuid;
    }
    function extractFromCache(cache3) {
      const values = [];
      for (const key in cache3) {
        const data2 = cache3[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
      if (nodes.length > 0) data.nodes = nodes;
    }
    return data;
  }
  copy(source) {
    this.lightsNode = source.lightsNode;
    this.envNode = source.envNode;
    this.colorNode = source.colorNode;
    this.normalNode = source.normalNode;
    this.opacityNode = source.opacityNode;
    this.backdropNode = source.backdropNode;
    this.backdropAlphaNode = source.backdropAlphaNode;
    this.alphaTestNode = source.alphaTestNode;
    this.positionNode = source.positionNode;
    this.geometryNode = source.geometryNode;
    this.depthNode = source.depthNode;
    this.shadowPositionNode = source.shadowPositionNode;
    this.receivedShadowNode = source.receivedShadowNode;
    this.castShadowNode = source.castShadowNode;
    this.outputNode = source.outputNode;
    this.mrtNode = source.mrtNode;
    this.fragmentNode = source.fragmentNode;
    this.vertexNode = source.vertexNode;
    return super.copy(source);
  }
};
var _defaultValues$e = new PointsMaterial();
var _defaultValues$d = new LineBasicMaterial();
var _defaultValues$c = new LineDashedMaterial();
var _sharedFramebuffer = null;
var ViewportSharedTextureNode = class extends ViewportTextureNode {
  static get type() {
    return "ViewportSharedTextureNode";
  }
  constructor(uvNode = screenUV, levelNode = null) {
    if (_sharedFramebuffer === null) {
      _sharedFramebuffer = new FramebufferTexture();
    }
    super(uvNode, levelNode, _sharedFramebuffer);
  }
  updateReference() {
    return this;
  }
};
var viewportSharedTexture = nodeProxy(ViewportSharedTextureNode);
var _defaultValues$b = new LineDashedMaterial();
var directionToColor = (node) => nodeObject(node).mul(0.5).add(0.5);
var colorToDirection = (node) => nodeObject(node).mul(2).sub(1);
var _defaultValues$a = new MeshNormalMaterial();
var EquirectUVNode = class extends TempNode {
  static get type() {
    return "EquirectUVNode";
  }
  constructor(dirNode = positionWorldDirection) {
    super("vec2");
    this.dirNode = dirNode;
  }
  setup() {
    const dir = this.dirNode;
    const u = dir.z.atan2(dir.x).mul(1 / (Math.PI * 2)).add(0.5);
    const v = dir.y.clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
    return vec2(u, v);
  }
};
var equirectUV = nodeProxy(EquirectUVNode);
var CubeRenderTarget = class extends WebGLCubeRenderTarget {
  constructor(size = 1, options = {}) {
    super(size, options);
    this.isCubeRenderTarget = true;
  }
  fromEquirectangularTexture(renderer, texture$1) {
    const currentMinFilter = texture$1.minFilter;
    const currentGenerateMipmaps = texture$1.generateMipmaps;
    texture$1.generateMipmaps = true;
    this.texture.type = texture$1.type;
    this.texture.colorSpace = texture$1.colorSpace;
    this.texture.generateMipmaps = texture$1.generateMipmaps;
    this.texture.minFilter = texture$1.minFilter;
    this.texture.magFilter = texture$1.magFilter;
    const geometry = new BoxGeometry(5, 5, 5);
    const uvNode = equirectUV(positionWorldDirection);
    const material = new NodeMaterial();
    material.colorNode = texture(texture$1, uvNode, 0);
    material.side = BackSide;
    material.blending = NoBlending;
    const mesh = new Mesh(geometry, material);
    const scene = new Scene();
    scene.add(mesh);
    if (texture$1.minFilter === LinearMipmapLinearFilter) texture$1.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    const currentMRT = renderer.getMRT();
    renderer.setMRT(null);
    camera.update(renderer, scene);
    renderer.setMRT(currentMRT);
    texture$1.minFilter = currentMinFilter;
    texture$1.currentGenerateMipmaps = currentGenerateMipmaps;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
};
var _cache$1 = /* @__PURE__ */ new WeakMap();
var CubeMapNode = class extends TempNode {
  static get type() {
    return "CubeMapNode";
  }
  constructor(envNode) {
    super("vec3");
    this.envNode = envNode;
    this._cubeTexture = null;
    this._cubeTextureNode = cubeTexture();
    const defaultTexture = new CubeTexture();
    defaultTexture.isRenderTargetTexture = true;
    this._defaultTexture = defaultTexture;
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  updateBefore(frame) {
    const { renderer, material } = frame;
    const envNode = this.envNode;
    if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {
      const texture3 = envNode.isTextureNode ? envNode.value : material[envNode.property];
      if (texture3 && texture3.isTexture) {
        const mapping = texture3.mapping;
        if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
          if (_cache$1.has(texture3)) {
            const cubeMap = _cache$1.get(texture3);
            mapTextureMapping(cubeMap, texture3.mapping);
            this._cubeTexture = cubeMap;
          } else {
            const image = texture3.image;
            if (isEquirectangularMapReady$1(image)) {
              const renderTarget = new CubeRenderTarget(image.height);
              renderTarget.fromEquirectangularTexture(renderer, texture3);
              mapTextureMapping(renderTarget.texture, texture3.mapping);
              this._cubeTexture = renderTarget.texture;
              _cache$1.set(texture3, renderTarget.texture);
              texture3.addEventListener("dispose", onTextureDispose);
            } else {
              this._cubeTexture = this._defaultTexture;
            }
          }
          this._cubeTextureNode.value = this._cubeTexture;
        } else {
          this._cubeTextureNode = this.envNode;
        }
      }
    }
  }
  setup(builder) {
    this.updateBefore(builder);
    return this._cubeTextureNode;
  }
};
function isEquirectangularMapReady$1(image) {
  if (image === null || image === void 0) return false;
  return image.height > 0;
}
function onTextureDispose(event) {
  const texture3 = event.target;
  texture3.removeEventListener("dispose", onTextureDispose);
  const renderTarget = _cache$1.get(texture3);
  if (renderTarget !== void 0) {
    _cache$1.delete(texture3);
    renderTarget.dispose();
  }
}
function mapTextureMapping(texture3, mapping) {
  if (mapping === EquirectangularReflectionMapping) {
    texture3.mapping = CubeReflectionMapping;
  } else if (mapping === EquirectangularRefractionMapping) {
    texture3.mapping = CubeRefractionMapping;
  }
}
var cubeMapNode = nodeProxy(CubeMapNode);
var _defaultValues$9 = new MeshBasicMaterial();
var F_Schlick = Fn(({ f0, f90, dotVH }) => {
  const fresnel = dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();
  return f0.mul(fresnel.oneMinus()).add(f90.mul(fresnel));
});
var BRDF_Lambert = Fn((inputs) => {
  return inputs.diffuseColor.mul(1 / Math.PI);
});
var G_BlinnPhong_Implicit = () => float(0.25);
var D_BlinnPhong = Fn(({ dotNH }) => {
  return shininess.mul(float(0.5)).add(1).mul(float(1 / Math.PI)).mul(dotNH.pow(shininess));
});
var BRDF_BlinnPhong = Fn(({ lightDirection }) => {
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNH = transformedNormalView.dot(halfDir).clamp();
  const dotVH = positionViewDirection.dot(halfDir).clamp();
  const F = F_Schlick({ f0: specularColor, f90: 1, dotVH });
  const G = G_BlinnPhong_Implicit();
  const D = D_BlinnPhong({ dotNH });
  return F.mul(G).mul(D);
});
var _defaultValues$8 = new MeshLambertMaterial();
var _defaultValues$7 = new MeshPhongMaterial();
var getGeometryRoughness = Fn((builder) => {
  if (builder.geometry.hasAttribute("normal") === false) {
    return float(0);
  }
  const dxy = normalView.dFdx().abs().max(normalView.dFdy().abs());
  const geometryRoughness = dxy.x.max(dxy.y).max(dxy.z);
  return geometryRoughness;
});
var getRoughness = Fn((inputs) => {
  const { roughness: roughness3 } = inputs;
  const geometryRoughness = getGeometryRoughness();
  let roughnessFactor = roughness3.max(0.0525);
  roughnessFactor = roughnessFactor.add(geometryRoughness);
  roughnessFactor = roughnessFactor.min(1);
  return roughnessFactor;
});
var V_GGX_SmithCorrelated = Fn(({ alpha, dotNL, dotNV }) => {
  const a2 = alpha.pow2();
  const gv = dotNL.mul(a2.add(a2.oneMinus().mul(dotNV.pow2())).sqrt());
  const gl = dotNV.mul(a2.add(a2.oneMinus().mul(dotNL.pow2())).sqrt());
  return div(0.5, gv.add(gl).max(EPSILON));
}).setLayout({
  name: "V_GGX_SmithCorrelated",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNL", type: "float" },
    { name: "dotNV", type: "float" }
  ]
});
var V_GGX_SmithCorrelated_Anisotropic = Fn(({ alphaT: alphaT3, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL }) => {
  const gv = dotNL.mul(vec3(alphaT3.mul(dotTV), alphaB.mul(dotBV), dotNV).length());
  const gl = dotNV.mul(vec3(alphaT3.mul(dotTL), alphaB.mul(dotBL), dotNL).length());
  const v = div(0.5, gv.add(gl));
  return v.saturate();
}).setLayout({
  name: "V_GGX_SmithCorrelated_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotTV", type: "float", qualifier: "in" },
    { name: "dotBV", type: "float", qualifier: "in" },
    { name: "dotTL", type: "float", qualifier: "in" },
    { name: "dotBL", type: "float", qualifier: "in" },
    { name: "dotNV", type: "float", qualifier: "in" },
    { name: "dotNL", type: "float", qualifier: "in" }
  ]
});
var D_GGX = Fn(({ alpha, dotNH }) => {
  const a2 = alpha.pow2();
  const denom = dotNH.pow2().mul(a2.oneMinus()).oneMinus();
  return a2.div(denom.pow2()).mul(1 / Math.PI);
}).setLayout({
  name: "D_GGX",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNH", type: "float" }
  ]
});
var RECIPROCAL_PI = float(1 / Math.PI);
var D_GGX_Anisotropic = Fn(({ alphaT: alphaT3, alphaB, dotNH, dotTH, dotBH }) => {
  const a2 = alphaT3.mul(alphaB);
  const v = vec3(alphaB.mul(dotTH), alphaT3.mul(dotBH), a2.mul(dotNH));
  const v2 = v.dot(v);
  const w22 = a2.div(v2);
  return RECIPROCAL_PI.mul(a2.mul(w22.pow2()));
}).setLayout({
  name: "D_GGX_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotNH", type: "float", qualifier: "in" },
    { name: "dotTH", type: "float", qualifier: "in" },
    { name: "dotBH", type: "float", qualifier: "in" }
  ]
});
var BRDF_GGX = Fn((inputs) => {
  const { lightDirection, f0, f90, roughness: roughness3, f, USE_IRIDESCENCE, USE_ANISOTROPY } = inputs;
  const normalView3 = inputs.normalView || transformedNormalView;
  const alpha = roughness3.pow2();
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNL = normalView3.dot(lightDirection).clamp();
  const dotNV = normalView3.dot(positionViewDirection).clamp();
  const dotNH = normalView3.dot(halfDir).clamp();
  const dotVH = positionViewDirection.dot(halfDir).clamp();
  let F = F_Schlick({ f0, f90, dotVH });
  let V, D;
  if (defined(USE_IRIDESCENCE)) {
    F = iridescence.mix(F, f);
  }
  if (defined(USE_ANISOTROPY)) {
    const dotTL = anisotropyT.dot(lightDirection);
    const dotTV = anisotropyT.dot(positionViewDirection);
    const dotTH = anisotropyT.dot(halfDir);
    const dotBL = anisotropyB.dot(lightDirection);
    const dotBV = anisotropyB.dot(positionViewDirection);
    const dotBH = anisotropyB.dot(halfDir);
    V = V_GGX_SmithCorrelated_Anisotropic({ alphaT, alphaB: alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL });
    D = D_GGX_Anisotropic({ alphaT, alphaB: alpha, dotNH, dotTH, dotBH });
  } else {
    V = V_GGX_SmithCorrelated({ alpha, dotNL, dotNV });
    D = D_GGX({ alpha, dotNH });
  }
  return F.mul(V).mul(D);
});
var DFGApprox = Fn(({ roughness: roughness3, dotNV }) => {
  const c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const c1 = vec4(1, 0.0425, 1.04, -0.04);
  const r = roughness3.mul(c0).add(c1);
  const a004 = r.x.mul(r.x).min(dotNV.mul(-9.28).exp2()).mul(r.x).add(r.y);
  const fab = vec2(-1.04, 1.04).mul(a004).add(r.zw);
  return fab;
}).setLayout({
  name: "DFGApprox",
  type: "vec2",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNV", type: "vec3" }
  ]
});
var EnvironmentBRDF = Fn((inputs) => {
  const { dotNV, specularColor: specularColor3, specularF90: specularF903, roughness: roughness3 } = inputs;
  const fab = DFGApprox({ dotNV, roughness: roughness3 });
  return specularColor3.mul(fab.x).add(specularF903.mul(fab.y));
});
var Schlick_to_F0 = Fn(({ f, f90, dotVH }) => {
  const x = dotVH.oneMinus().saturate();
  const x2 = x.mul(x);
  const x5 = x.mul(x2, x2).clamp(0, 0.9999);
  return f.sub(vec3(f90).mul(x5)).div(x5.oneMinus());
}).setLayout({
  name: "Schlick_to_F0",
  type: "vec3",
  inputs: [
    { name: "f", type: "vec3" },
    { name: "f90", type: "float" },
    { name: "dotVH", type: "float" }
  ]
});
var D_Charlie = Fn(({ roughness: roughness3, dotNH }) => {
  const alpha = roughness3.pow2();
  const invAlpha = float(1).div(alpha);
  const cos2h = dotNH.pow2();
  const sin2h = cos2h.oneMinus().max(78125e-7);
  return float(2).add(invAlpha).mul(sin2h.pow(invAlpha.mul(0.5))).div(2 * Math.PI);
}).setLayout({
  name: "D_Charlie",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNH", type: "float" }
  ]
});
var V_Neubelt = Fn(({ dotNV, dotNL }) => {
  return float(1).div(float(4).mul(dotNL.add(dotNV).sub(dotNL.mul(dotNV))));
}).setLayout({
  name: "V_Neubelt",
  type: "float",
  inputs: [
    { name: "dotNV", type: "float" },
    { name: "dotNL", type: "float" }
  ]
});
var BRDF_Sheen = Fn(({ lightDirection }) => {
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNL = transformedNormalView.dot(lightDirection).clamp();
  const dotNV = transformedNormalView.dot(positionViewDirection).clamp();
  const dotNH = transformedNormalView.dot(halfDir).clamp();
  const D = D_Charlie({ roughness: sheenRoughness, dotNH });
  const V = V_Neubelt({ dotNV, dotNL });
  return sheen.mul(D).mul(V);
});
var LTC_Uv = Fn(({ N, V, roughness: roughness3 }) => {
  const LUT_SIZE = 64;
  const LUT_SCALE = (LUT_SIZE - 1) / LUT_SIZE;
  const LUT_BIAS = 0.5 / LUT_SIZE;
  const dotNV = N.dot(V).saturate();
  const uv3 = vec2(roughness3, dotNV.oneMinus().sqrt());
  uv3.assign(uv3.mul(LUT_SCALE).add(LUT_BIAS));
  return uv3;
}).setLayout({
  name: "LTC_Uv",
  type: "vec2",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "roughness", type: "float" }
  ]
});
var LTC_ClippedSphereFormFactor = Fn(({ f }) => {
  const l = f.length();
  return max$1(l.mul(l).add(f.z).div(l.add(1)), 0);
}).setLayout({
  name: "LTC_ClippedSphereFormFactor",
  type: "float",
  inputs: [
    { name: "f", type: "vec3" }
  ]
});
var LTC_EdgeVectorFormFactor = Fn(({ v1, v2 }) => {
  const x = v1.dot(v2);
  const y = x.abs().toVar();
  const a = y.mul(0.0145206).add(0.4965155).mul(y).add(0.8543985).toVar();
  const b = y.add(4.1616724).mul(y).add(3.417594).toVar();
  const v = a.div(b);
  const theta_sintheta = x.greaterThan(0).select(v, max$1(x.mul(x).oneMinus(), 1e-7).inverseSqrt().mul(0.5).sub(v));
  return v1.cross(v2).mul(theta_sintheta);
}).setLayout({
  name: "LTC_EdgeVectorFormFactor",
  type: "vec3",
  inputs: [
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" }
  ]
});
var LTC_Evaluate = Fn(({ N, V, P, mInv, p0, p1, p2, p3 }) => {
  const v1 = p1.sub(p0).toVar();
  const v2 = p3.sub(p0).toVar();
  const lightNormal = v1.cross(v2);
  const result = vec3().toVar();
  If(lightNormal.dot(P.sub(p0)).greaterThanEqual(0), () => {
    const T1 = V.sub(N.mul(V.dot(N))).normalize();
    const T2 = N.cross(T1).negate();
    const mat = mInv.mul(mat3(T1, T2, N).transpose()).toVar();
    const coords0 = mat.mul(p0.sub(P)).normalize().toVar();
    const coords1 = mat.mul(p1.sub(P)).normalize().toVar();
    const coords2 = mat.mul(p2.sub(P)).normalize().toVar();
    const coords3 = mat.mul(p3.sub(P)).normalize().toVar();
    const vectorFormFactor = vec3(0).toVar();
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords0, v2: coords1 }));
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords1, v2: coords2 }));
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords2, v2: coords3 }));
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords3, v2: coords0 }));
    result.assign(vec3(LTC_ClippedSphereFormFactor({ f: vectorFormFactor })));
  });
  return result;
}).setLayout({
  name: "LTC_Evaluate",
  type: "vec3",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "P", type: "vec3" },
    { name: "mInv", type: "mat3" },
    { name: "p0", type: "vec3" },
    { name: "p1", type: "vec3" },
    { name: "p2", type: "vec3" },
    { name: "p3", type: "vec3" }
  ]
});
var bC = 1 / 6;
var w0 = (a) => mul(bC, mul(a, mul(a, a.negate().add(3)).sub(3)).add(1));
var w1 = (a) => mul(bC, mul(a, mul(a, mul(3, a).sub(6))).add(4));
var w2 = (a) => mul(bC, mul(a, mul(a, mul(-3, a).add(3)).add(3)).add(1));
var w3 = (a) => mul(bC, pow(a, 3));
var g0 = (a) => w0(a).add(w1(a));
var g1 = (a) => w2(a).add(w3(a));
var h0 = (a) => add(-1, w1(a).div(w0(a).add(w1(a))));
var h1 = (a) => add(1, w3(a).div(w2(a).add(w3(a))));
var bicubic = (textureNode, texelSize, lod) => {
  const uv3 = textureNode.uvNode;
  const uvScaled = mul(uv3, texelSize.zw).add(0.5);
  const iuv = floor(uvScaled);
  const fuv = fract(uvScaled);
  const g0x = g0(fuv.x);
  const g1x = g1(fuv.x);
  const h0x = h0(fuv.x);
  const h1x = h1(fuv.x);
  const h0y = h0(fuv.y);
  const h1y = h1(fuv.y);
  const p0 = vec2(iuv.x.add(h0x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
  const p1 = vec2(iuv.x.add(h1x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
  const p2 = vec2(iuv.x.add(h0x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
  const p3 = vec2(iuv.x.add(h1x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
  const a = g0(fuv.y).mul(add(g0x.mul(textureNode.uv(p0).level(lod)), g1x.mul(textureNode.uv(p1).level(lod))));
  const b = g1(fuv.y).mul(add(g0x.mul(textureNode.uv(p2).level(lod)), g1x.mul(textureNode.uv(p3).level(lod))));
  return a.add(b);
};
var textureBicubic = Fn(([textureNode, lodNode = float(3)]) => {
  const fLodSize = vec2(textureNode.size(int(lodNode)));
  const cLodSize = vec2(textureNode.size(int(lodNode.add(1))));
  const fLodSizeInv = div(1, fLodSize);
  const cLodSizeInv = div(1, cLodSize);
  const fSample = bicubic(textureNode, vec4(fLodSizeInv, fLodSize), floor(lodNode));
  const cSample = bicubic(textureNode, vec4(cLodSizeInv, cLodSize), ceil(lodNode));
  return fract(lodNode).mix(fSample, cSample);
});
var getVolumeTransmissionRay = Fn(([n, v, thickness3, ior3, modelMatrix]) => {
  const refractionVector = vec3(refract(v.negate(), normalize(n), div(1, ior3)));
  const modelScale3 = vec3(
    length(modelMatrix[0].xyz),
    length(modelMatrix[1].xyz),
    length(modelMatrix[2].xyz)
  );
  return normalize(refractionVector).mul(thickness3.mul(modelScale3));
}).setLayout({
  name: "getVolumeTransmissionRay",
  type: "vec3",
  inputs: [
    { name: "n", type: "vec3" },
    { name: "v", type: "vec3" },
    { name: "thickness", type: "float" },
    { name: "ior", type: "float" },
    { name: "modelMatrix", type: "mat4" }
  ]
});
var applyIorToRoughness = Fn(([roughness3, ior3]) => {
  return roughness3.mul(clamp(ior3.mul(2).sub(2), 0, 1));
}).setLayout({
  name: "applyIorToRoughness",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "ior", type: "float" }
  ]
});
var viewportBackSideTexture = viewportMipTexture();
var viewportFrontSideTexture = viewportMipTexture();
var getTransmissionSample = Fn(([fragCoord, roughness3, ior3], { material }) => {
  const vTexture = material.side == BackSide ? viewportBackSideTexture : viewportFrontSideTexture;
  const transmissionSample = vTexture.uv(fragCoord);
  const lod = log2(screenSize.x).mul(applyIorToRoughness(roughness3, ior3));
  return textureBicubic(transmissionSample, lod);
});
var volumeAttenuation = Fn(([transmissionDistance, attenuationColor3, attenuationDistance3]) => {
  If(attenuationDistance3.notEqual(0), () => {
    const attenuationCoefficient = log(attenuationColor3).negate().div(attenuationDistance3);
    const transmittance = exp(attenuationCoefficient.negate().mul(transmissionDistance));
    return transmittance;
  });
  return vec3(1);
}).setLayout({
  name: "volumeAttenuation",
  type: "vec3",
  inputs: [
    { name: "transmissionDistance", type: "float" },
    { name: "attenuationColor", type: "vec3" },
    { name: "attenuationDistance", type: "float" }
  ]
});
var getIBLVolumeRefraction = Fn(([n, v, roughness3, diffuseColor3, specularColor3, specularF903, position, modelMatrix, viewMatrix, projMatrix, ior3, thickness3, attenuationColor3, attenuationDistance3, dispersion3]) => {
  let transmittedLight, transmittance;
  if (dispersion3) {
    transmittedLight = vec4().toVar();
    transmittance = vec3().toVar();
    const halfSpread = ior3.sub(1).mul(dispersion3.mul(0.025));
    const iors = vec3(ior3.sub(halfSpread), ior3, ior3.add(halfSpread));
    Loop({ start: 0, end: 3 }, ({ i }) => {
      const ior4 = iors.element(i);
      const transmissionRay = getVolumeTransmissionRay(n, v, thickness3, ior4, modelMatrix);
      const refractedRayExit = position.add(transmissionRay);
      const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1)));
      const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();
      refractionCoords.addAssign(1);
      refractionCoords.divAssign(2);
      refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus()));
      const transmissionSample = getTransmissionSample(refractionCoords, roughness3, ior4);
      transmittedLight.element(i).assign(transmissionSample.element(i));
      transmittedLight.a.addAssign(transmissionSample.a);
      transmittance.element(i).assign(diffuseColor3.element(i).mul(volumeAttenuation(length(transmissionRay), attenuationColor3, attenuationDistance3).element(i)));
    });
    transmittedLight.a.divAssign(3);
  } else {
    const transmissionRay = getVolumeTransmissionRay(n, v, thickness3, ior3, modelMatrix);
    const refractedRayExit = position.add(transmissionRay);
    const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1)));
    const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();
    refractionCoords.addAssign(1);
    refractionCoords.divAssign(2);
    refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus()));
    transmittedLight = getTransmissionSample(refractionCoords, roughness3, ior3);
    transmittance = diffuseColor3.mul(volumeAttenuation(length(transmissionRay), attenuationColor3, attenuationDistance3));
  }
  const attenuatedColor = transmittance.rgb.mul(transmittedLight.rgb);
  const dotNV = n.dot(v).clamp();
  const F = vec3(EnvironmentBRDF({
    // n, v, specularColor, specularF90, roughness
    dotNV,
    specularColor: specularColor3,
    specularF90: specularF903,
    roughness: roughness3
  }));
  const transmittanceFactor = transmittance.r.add(transmittance.g, transmittance.b).div(3);
  return vec4(F.oneMinus().mul(attenuatedColor), transmittedLight.a.oneMinus().mul(transmittanceFactor).oneMinus());
});
var XYZ_TO_REC709 = mat3(
  3.2404542,
  -0.969266,
  0.0556434,
  -1.5371385,
  1.8760108,
  -0.2040259,
  -0.4985314,
  0.041556,
  1.0572252
);
var Fresnel0ToIor = (fresnel0) => {
  const sqrtF0 = fresnel0.sqrt();
  return vec3(1).add(sqrtF0).div(vec3(1).sub(sqrtF0));
};
var IorToFresnel0 = (transmittedIor, incidentIor) => {
  return transmittedIor.sub(incidentIor).div(transmittedIor.add(incidentIor)).pow2();
};
var evalSensitivity = (OPD, shift) => {
  const phase = OPD.mul(2 * Math.PI * 1e-9);
  const val = vec3(54856e-17, 44201e-17, 52481e-17);
  const pos = vec3(1681e3, 1795300, 2208400);
  const VAR = vec3(43278e5, 93046e5, 66121e5);
  const x = float(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(phase.mul(2239900).add(shift.x).cos()).mul(phase.pow2().mul(-45282e5).exp());
  let xyz = val.mul(VAR.mul(2 * Math.PI).sqrt()).mul(pos.mul(phase).add(shift).cos()).mul(phase.pow2().negate().mul(VAR).exp());
  xyz = vec3(xyz.x.add(x), xyz.y, xyz.z).div(10685e-11);
  const rgb = XYZ_TO_REC709.mul(xyz);
  return rgb;
};
var evalIridescence = Fn(({ outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 }) => {
  const iridescenceIOR3 = mix(outsideIOR, eta2, smoothstep(0, 0.03, thinFilmThickness));
  const sinTheta2Sq = outsideIOR.div(iridescenceIOR3).pow2().mul(cosTheta1.pow2().oneMinus());
  const cosTheta2Sq = sinTheta2Sq.oneMinus();
  If(cosTheta2Sq.lessThan(0), () => {
    return vec3(1);
  });
  const cosTheta2 = cosTheta2Sq.sqrt();
  const R0 = IorToFresnel0(iridescenceIOR3, outsideIOR);
  const R12 = F_Schlick({ f0: R0, f90: 1, dotVH: cosTheta1 });
  const T121 = R12.oneMinus();
  const phi12 = iridescenceIOR3.lessThan(outsideIOR).select(Math.PI, 0);
  const phi21 = float(Math.PI).sub(phi12);
  const baseIOR = Fresnel0ToIor(baseF0.clamp(0, 0.9999));
  const R1 = IorToFresnel0(baseIOR, iridescenceIOR3.toVec3());
  const R23 = F_Schlick({ f0: R1, f90: 1, dotVH: cosTheta2 });
  const phi23 = vec3(
    baseIOR.x.lessThan(iridescenceIOR3).select(Math.PI, 0),
    baseIOR.y.lessThan(iridescenceIOR3).select(Math.PI, 0),
    baseIOR.z.lessThan(iridescenceIOR3).select(Math.PI, 0)
  );
  const OPD = iridescenceIOR3.mul(thinFilmThickness, cosTheta2, 2);
  const phi = vec3(phi21).add(phi23);
  const R123 = R12.mul(R23).clamp(1e-5, 0.9999);
  const r123 = R123.sqrt();
  const Rs = T121.pow2().mul(R23).div(vec3(1).sub(R123));
  const C0 = R12.add(Rs);
  const I = C0.toVar();
  const Cm = Rs.sub(T121).toVar();
  Loop({ start: 1, end: 2, condition: "<=", name: "m" }, ({ m }) => {
    Cm.mulAssign(r123);
    const Sm = evalSensitivity(float(m).mul(OPD), float(m).mul(phi)).mul(2);
    I.addAssign(Cm.mul(Sm));
  });
  return I.max(vec3(0));
}).setLayout({
  name: "evalIridescence",
  type: "vec3",
  inputs: [
    { name: "outsideIOR", type: "float" },
    { name: "eta2", type: "float" },
    { name: "cosTheta1", type: "float" },
    { name: "thinFilmThickness", type: "float" },
    { name: "baseF0", type: "vec3" }
  ]
});
var IBLSheenBRDF = Fn(({ normal: normal2, viewDir, roughness: roughness3 }) => {
  const dotNV = normal2.dot(viewDir).saturate();
  const r2 = roughness3.pow2();
  const a = select(
    roughness3.lessThan(0.25),
    float(-339.2).mul(r2).add(float(161.4).mul(roughness3)).sub(25.9),
    float(-8.48).mul(r2).add(float(14.3).mul(roughness3)).sub(9.95)
  );
  const b = select(
    roughness3.lessThan(0.25),
    float(44).mul(r2).sub(float(23.7).mul(roughness3)).add(3.26),
    float(1.97).mul(r2).sub(float(3.27).mul(roughness3)).add(0.72)
  );
  const DG = select(roughness3.lessThan(0.25), 0, float(0.1).mul(roughness3).sub(0.025)).add(a.mul(dotNV).add(b).exp());
  return DG.mul(1 / Math.PI).saturate();
});
var clearcoatF0 = vec3(0.04);
var clearcoatF90 = float(1);
var cubeUV_r0 = float(1);
var cubeUV_m0 = float(-2);
var cubeUV_r1 = float(0.8);
var cubeUV_m1 = float(-1);
var cubeUV_r4 = float(0.4);
var cubeUV_m4 = float(2);
var cubeUV_r5 = float(0.305);
var cubeUV_m5 = float(3);
var cubeUV_r6 = float(0.21);
var cubeUV_m6 = float(4);
var cubeUV_minMipLevel = float(4);
var cubeUV_minTileSize = float(16);
var getFace = Fn(([direction2]) => {
  const absDirection = vec3(abs(direction2)).toVar();
  const face = float(-1).toVar();
  If(absDirection.x.greaterThan(absDirection.z), () => {
    If(absDirection.x.greaterThan(absDirection.y), () => {
      face.assign(select(direction2.x.greaterThan(0), 0, 3));
    }).Else(() => {
      face.assign(select(direction2.y.greaterThan(0), 1, 4));
    });
  }).Else(() => {
    If(absDirection.z.greaterThan(absDirection.y), () => {
      face.assign(select(direction2.z.greaterThan(0), 2, 5));
    }).Else(() => {
      face.assign(select(direction2.y.greaterThan(0), 1, 4));
    });
  });
  return face;
}).setLayout({
  name: "getFace",
  type: "float",
  inputs: [
    { name: "direction", type: "vec3" }
  ]
});
var getUV = Fn(([direction2, face]) => {
  const uv3 = vec2().toVar();
  If(face.equal(0), () => {
    uv3.assign(vec2(direction2.z, direction2.y).div(abs(direction2.x)));
  }).ElseIf(face.equal(1), () => {
    uv3.assign(vec2(direction2.x.negate(), direction2.z.negate()).div(abs(direction2.y)));
  }).ElseIf(face.equal(2), () => {
    uv3.assign(vec2(direction2.x.negate(), direction2.y).div(abs(direction2.z)));
  }).ElseIf(face.equal(3), () => {
    uv3.assign(vec2(direction2.z.negate(), direction2.y).div(abs(direction2.x)));
  }).ElseIf(face.equal(4), () => {
    uv3.assign(vec2(direction2.x.negate(), direction2.z).div(abs(direction2.y)));
  }).Else(() => {
    uv3.assign(vec2(direction2.x, direction2.y).div(abs(direction2.z)));
  });
  return mul(0.5, uv3.add(1));
}).setLayout({
  name: "getUV",
  type: "vec2",
  inputs: [
    { name: "direction", type: "vec3" },
    { name: "face", type: "float" }
  ]
});
var roughnessToMip = Fn(([roughness3]) => {
  const mip = float(0).toVar();
  If(roughness3.greaterThanEqual(cubeUV_r1), () => {
    mip.assign(cubeUV_r0.sub(roughness3).mul(cubeUV_m1.sub(cubeUV_m0)).div(cubeUV_r0.sub(cubeUV_r1)).add(cubeUV_m0));
  }).ElseIf(roughness3.greaterThanEqual(cubeUV_r4), () => {
    mip.assign(cubeUV_r1.sub(roughness3).mul(cubeUV_m4.sub(cubeUV_m1)).div(cubeUV_r1.sub(cubeUV_r4)).add(cubeUV_m1));
  }).ElseIf(roughness3.greaterThanEqual(cubeUV_r5), () => {
    mip.assign(cubeUV_r4.sub(roughness3).mul(cubeUV_m5.sub(cubeUV_m4)).div(cubeUV_r4.sub(cubeUV_r5)).add(cubeUV_m4));
  }).ElseIf(roughness3.greaterThanEqual(cubeUV_r6), () => {
    mip.assign(cubeUV_r5.sub(roughness3).mul(cubeUV_m6.sub(cubeUV_m5)).div(cubeUV_r5.sub(cubeUV_r6)).add(cubeUV_m5));
  }).Else(() => {
    mip.assign(float(-2).mul(log2(mul(1.16, roughness3))));
  });
  return mip;
}).setLayout({
  name: "roughnessToMip",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" }
  ]
});
var getDirection = Fn(([uv_immutable, face]) => {
  const uv3 = uv_immutable.toVar();
  uv3.assign(mul(2, uv3).sub(1));
  const direction2 = vec3(uv3, 1).toVar();
  If(face.equal(0), () => {
    direction2.assign(direction2.zyx);
  }).ElseIf(face.equal(1), () => {
    direction2.assign(direction2.xzy);
    direction2.xz.mulAssign(-1);
  }).ElseIf(face.equal(2), () => {
    direction2.x.mulAssign(-1);
  }).ElseIf(face.equal(3), () => {
    direction2.assign(direction2.zyx);
    direction2.xz.mulAssign(-1);
  }).ElseIf(face.equal(4), () => {
    direction2.assign(direction2.xzy);
    direction2.xy.mulAssign(-1);
  }).ElseIf(face.equal(5), () => {
    direction2.z.mulAssign(-1);
  });
  return direction2;
}).setLayout({
  name: "getDirection",
  type: "vec3",
  inputs: [
    { name: "uv", type: "vec2" },
    { name: "face", type: "float" }
  ]
});
var textureCubeUV = Fn(([envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {
  const roughness3 = float(roughness_immutable);
  const sampleDir = vec3(sampleDir_immutable);
  const mip = clamp(roughnessToMip(roughness3), cubeUV_m0, CUBEUV_MAX_MIP);
  const mipF = fract(mip);
  const mipInt = floor(mip);
  const color0 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();
  If(mipF.notEqual(0), () => {
    const color1 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt.add(1), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();
    color0.assign(mix(color0, color1, mipF));
  });
  return color0;
});
var bilinearCubeUV = Fn(([envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {
  const mipInt = float(mipInt_immutable).toVar();
  const direction2 = vec3(direction_immutable);
  const face = float(getFace(direction2)).toVar();
  const filterInt = float(max$1(cubeUV_minMipLevel.sub(mipInt), 0)).toVar();
  mipInt.assign(max$1(mipInt, cubeUV_minMipLevel));
  const faceSize = float(exp2(mipInt)).toVar();
  const uv3 = vec2(getUV(direction2, face).mul(faceSize.sub(2)).add(1)).toVar();
  If(face.greaterThan(2), () => {
    uv3.y.addAssign(faceSize);
    face.subAssign(3);
  });
  uv3.x.addAssign(face.mul(faceSize));
  uv3.x.addAssign(filterInt.mul(mul(3, cubeUV_minTileSize)));
  uv3.y.addAssign(mul(4, exp2(CUBEUV_MAX_MIP).sub(faceSize)));
  uv3.x.mulAssign(CUBEUV_TEXEL_WIDTH);
  uv3.y.mulAssign(CUBEUV_TEXEL_HEIGHT);
  return envMap.uv(uv3).grad(vec2(), vec2());
});
var getSample = Fn(({ envMap, mipInt, outputDirection: outputDirection2, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
  const cosTheta = cos(theta);
  const sampleDirection = outputDirection2.mul(cosTheta).add(axis.cross(outputDirection2).mul(sin(theta))).add(axis.mul(axis.dot(outputDirection2).mul(cosTheta.oneMinus())));
  return bilinearCubeUV(envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP);
});
var blur = Fn(({ n, latitudinal, poleAxis, outputDirection: outputDirection2, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
  const axis = vec3(select(latitudinal, poleAxis, cross(poleAxis, outputDirection2))).toVar();
  If(all(axis.equals(vec3(0))), () => {
    axis.assign(vec3(outputDirection2.z, 0, outputDirection2.x.negate()));
  });
  axis.assign(normalize(axis));
  const gl_FragColor = vec3().toVar();
  gl_FragColor.addAssign(weights.element(int(0)).mul(getSample({ theta: 0, axis, outputDirection: outputDirection2, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
  Loop({ start: int(1), end: n }, ({ i }) => {
    If(i.greaterThanEqual(samples), () => {
      Break();
    });
    const theta = float(dTheta.mul(float(i))).toVar();
    gl_FragColor.addAssign(weights.element(i).mul(getSample({ theta: theta.mul(-1), axis, outputDirection: outputDirection2, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
    gl_FragColor.addAssign(weights.element(i).mul(getSample({ theta, axis, outputDirection: outputDirection2, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
  });
  return vec4(gl_FragColor, 1);
});
var _generator = null;
var _cache = /* @__PURE__ */ new WeakMap();
function _generateCubeUVSize(imageHeight) {
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function _getPMREMFromTexture(texture3) {
  let cacheTexture = _cache.get(texture3);
  const pmremVersion = cacheTexture !== void 0 ? cacheTexture.pmremVersion : -1;
  if (pmremVersion !== texture3.pmremVersion) {
    const image = texture3.image;
    if (texture3.isCubeTexture) {
      if (isCubeMapReady(image)) {
        cacheTexture = _generator.fromCubemap(texture3, cacheTexture);
      } else {
        return null;
      }
    } else {
      if (isEquirectangularMapReady(image)) {
        cacheTexture = _generator.fromEquirectangular(texture3, cacheTexture);
      } else {
        return null;
      }
    }
    cacheTexture.pmremVersion = texture3.pmremVersion;
    _cache.set(texture3, cacheTexture);
  }
  return cacheTexture.texture;
}
var PMREMNode = class extends TempNode {
  static get type() {
    return "PMREMNode";
  }
  constructor(value, uvNode = null, levelNode = null) {
    super("vec3");
    this._value = value;
    this._pmrem = null;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
    this._generator = null;
    const defaultTexture = new Texture();
    defaultTexture.isRenderTargetTexture = true;
    this._texture = texture(defaultTexture);
    this._width = uniform(0);
    this._height = uniform(0);
    this._maxMip = uniform(0);
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  set value(value) {
    this._value = value;
    this._pmrem = null;
  }
  get value() {
    return this._value;
  }
  updateFromTexture(texture3) {
    const cubeUVSize = _generateCubeUVSize(texture3.image.height);
    this._texture.value = texture3;
    this._width.value = cubeUVSize.texelWidth;
    this._height.value = cubeUVSize.texelHeight;
    this._maxMip.value = cubeUVSize.maxMip;
  }
  updateBefore() {
    let pmrem = this._pmrem;
    const pmremVersion = pmrem ? pmrem.pmremVersion : -1;
    const texture3 = this._value;
    if (pmremVersion !== texture3.pmremVersion) {
      if (texture3.isPMREMTexture === true) {
        pmrem = texture3;
      } else {
        pmrem = _getPMREMFromTexture(texture3);
      }
      if (pmrem !== null) {
        this._pmrem = pmrem;
        this.updateFromTexture(pmrem);
      }
    }
  }
  setup(builder) {
    if (_generator === null) {
      _generator = builder.createPMREMGenerator();
    }
    this.updateBefore(builder);
    let uvNode = this.uvNode;
    if (uvNode === null && builder.context.getUV) {
      uvNode = builder.context.getUV(this);
    }
    const texture3 = this.value;
    if (builder.renderer.coordinateSystem === WebGLCoordinateSystem && texture3.isPMREMTexture !== true && texture3.isRenderTargetTexture === true) {
      uvNode = vec3(uvNode.x.negate(), uvNode.yz);
    }
    let levelNode = this.levelNode;
    if (levelNode === null && builder.context.getTextureLevel) {
      levelNode = builder.context.getTextureLevel(this);
    }
    return textureCubeUV(this._texture, uvNode, levelNode, this._width, this._height, this._maxMip);
  }
};
function isCubeMapReady(image) {
  if (image === null || image === void 0) return false;
  let count = 0;
  const length3 = 6;
  for (let i = 0; i < length3; i++) {
    if (image[i] !== void 0) count++;
  }
  return count === length3;
}
function isEquirectangularMapReady(image) {
  if (image === null || image === void 0) return false;
  return image.height > 0;
}
var pmremTexture = nodeProxy(PMREMNode);
var _defaultValues$6 = new MeshStandardMaterial();
var _defaultValues$5 = new MeshPhysicalMaterial();
var getGradientIrradiance = Fn(({ normal: normal2, lightDirection, builder }) => {
  const dotNL = normal2.dot(lightDirection);
  const coord = vec2(dotNL.mul(0.5).add(0.5), 0);
  if (builder.material.gradientMap) {
    const gradientMap = materialReference("gradientMap", "texture").context({ getUV: () => coord });
    return vec3(gradientMap.r);
  } else {
    const fw = coord.fwidth().mul(0.5);
    return mix(vec3(0.7), vec3(1), smoothstep(float(0.7).sub(fw.x), float(0.7).add(fw.x), coord.x));
  }
});
var _defaultValues$4 = new MeshToonMaterial();
var MatcapUVNode = class extends TempNode {
  static get type() {
    return "MatcapUVNode";
  }
  constructor() {
    super("vec2");
  }
  setup() {
    const x = vec3(positionViewDirection.z, 0, positionViewDirection.x.negate()).normalize();
    const y = positionViewDirection.cross(x);
    return vec2(x.dot(transformedNormalView), y.dot(transformedNormalView)).mul(0.495).add(0.5);
  }
};
var matcapUV = nodeImmutable(MatcapUVNode);
var _defaultValues$3 = new MeshMatcapMaterial();
var _defaultValues$2 = new PointsMaterial();
var RotateNode = class extends TempNode {
  static get type() {
    return "RotateNode";
  }
  constructor(positionNode, rotationNode) {
    super();
    this.positionNode = positionNode;
    this.rotationNode = rotationNode;
  }
  getNodeType(builder) {
    return this.positionNode.getNodeType(builder);
  }
  setup(builder) {
    const { rotationNode, positionNode } = this;
    const nodeType = this.getNodeType(builder);
    if (nodeType === "vec2") {
      const cosAngle = rotationNode.cos();
      const sinAngle = rotationNode.sin();
      const rotationMatrix = mat2(
        cosAngle,
        sinAngle,
        sinAngle.negate(),
        cosAngle
      );
      return rotationMatrix.mul(positionNode);
    } else {
      const rotation = rotationNode;
      const rotationXMatrix = mat4(vec4(1, 0, 0, 0), vec4(0, cos(rotation.x), sin(rotation.x).negate(), 0), vec4(0, sin(rotation.x), cos(rotation.x), 0), vec4(0, 0, 0, 1));
      const rotationYMatrix = mat4(vec4(cos(rotation.y), 0, sin(rotation.y), 0), vec4(0, 1, 0, 0), vec4(sin(rotation.y).negate(), 0, cos(rotation.y), 0), vec4(0, 0, 0, 1));
      const rotationZMatrix = mat4(vec4(cos(rotation.z), sin(rotation.z).negate(), 0, 0), vec4(sin(rotation.z), cos(rotation.z), 0, 0), vec4(0, 0, 1, 0), vec4(0, 0, 0, 1));
      return rotationXMatrix.mul(rotationYMatrix).mul(rotationZMatrix).mul(vec4(positionNode, 1)).xyz;
    }
  }
};
var rotate = nodeProxy(RotateNode);
var _defaultValues$1 = new SpriteMaterial();
var _defaultValues = new ShadowMaterial();
var normal = Fn(({ texture: texture3, uv: uv3 }) => {
  const epsilon = 1e-4;
  const ret = vec3().toVar();
  If(uv3.x.lessThan(epsilon), () => {
    ret.assign(vec3(1, 0, 0));
  }).ElseIf(uv3.y.lessThan(epsilon), () => {
    ret.assign(vec3(0, 1, 0));
  }).ElseIf(uv3.z.lessThan(epsilon), () => {
    ret.assign(vec3(0, 0, 1));
  }).ElseIf(uv3.x.greaterThan(1 - epsilon), () => {
    ret.assign(vec3(-1, 0, 0));
  }).ElseIf(uv3.y.greaterThan(1 - epsilon), () => {
    ret.assign(vec3(0, -1, 0));
  }).ElseIf(uv3.z.greaterThan(1 - epsilon), () => {
    ret.assign(vec3(0, 0, -1));
  }).Else(() => {
    const step3 = 0.01;
    const x = texture3.uv(uv3.add(vec3(-step3, 0, 0))).r.sub(texture3.uv(uv3.add(vec3(step3, 0, 0))).r);
    const y = texture3.uv(uv3.add(vec3(0, -step3, 0))).r.sub(texture3.uv(uv3.add(vec3(0, step3, 0))).r);
    const z = texture3.uv(uv3.add(vec3(0, 0, -step3))).r.sub(texture3.uv(uv3.add(vec3(0, 0, step3))).r);
    ret.assign(vec3(x, y, z));
  });
  return ret.normalize();
});
var Texture3DNode = class extends TextureNode {
  static get type() {
    return "Texture3DNode";
  }
  constructor(value, uvNode = null, levelNode = null) {
    super(value, uvNode, levelNode);
    this.isTexture3DNode = true;
  }
  getInputType() {
    return "texture3D";
  }
  getDefaultUV() {
    return vec3(0.5, 0.5, 0.5);
  }
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for 3d TextureNode
  setupUV(builder, uvNode) {
    return uvNode;
  }
  generateUV(builder, uvNode) {
    return uvNode.build(builder, "vec3");
  }
  normal(uvNode) {
    return normal({ texture: this, uv: uvNode });
  }
};
var texture3D = nodeProxy(Texture3DNode);
var _size$3 = new Vector3();
var Color4 = class extends Color {
  constructor(r, g, b, a = 1) {
    super(r, g, b);
    this.a = a;
  }
  set(r, g, b, a = 1) {
    this.a = a;
    return super.set(r, g, b);
  }
  copy(color3) {
    if (color3.a !== void 0) this.a = color3.a;
    return super.copy(color3);
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b, this.a);
  }
};
var ParameterNode = class extends PropertyNode {
  static get type() {
    return "ParameterNode";
  }
  constructor(nodeType, name = null) {
    super(nodeType, name);
    this.isParameterNode = true;
  }
  getHash() {
    return this.uuid;
  }
  generate() {
    return this.name;
  }
};
var parameter = (type, name) => nodeObject(new ParameterNode(type, name));
var StackNode = class extends Node {
  static get type() {
    return "StackNode";
  }
  constructor(parent = null) {
    super();
    this.nodes = [];
    this.outputNode = null;
    this.parent = parent;
    this._currentCond = null;
    this.isStackNode = true;
  }
  getNodeType(builder) {
    return this.outputNode ? this.outputNode.getNodeType(builder) : "void";
  }
  add(node) {
    this.nodes.push(node);
    return this;
  }
  If(boolNode, method) {
    const methodNode = new ShaderNode(method);
    this._currentCond = select(boolNode, methodNode);
    return this.add(this._currentCond);
  }
  ElseIf(boolNode, method) {
    const methodNode = new ShaderNode(method);
    const ifNode = select(boolNode, methodNode);
    this._currentCond.elseNode = ifNode;
    this._currentCond = ifNode;
    return this;
  }
  Else(method) {
    this._currentCond.elseNode = new ShaderNode(method);
    return this;
  }
  build(builder, ...params) {
    const previousStack = getCurrentStack();
    setCurrentStack(this);
    for (const node of this.nodes) {
      node.build(builder, "void");
    }
    setCurrentStack(previousStack);
    return this.outputNode ? this.outputNode.build(builder, ...params) : super.build(builder, ...params);
  }
  //
  else(...params) {
    console.warn("TSL.StackNode: .else() has been renamed to .Else().");
    return this.Else(...params);
  }
  elseif(...params) {
    console.warn("TSL.StackNode: .elseif() has been renamed to .ElseIf().");
    return this.ElseIf(...params);
  }
};
var stack = nodeProxy(StackNode);
var StructTypeNode = class extends Node {
  static get type() {
    return "StructTypeNode";
  }
  constructor(types) {
    super();
    this.types = types;
    this.isStructTypeNode = true;
  }
  getMemberTypes() {
    return this.types;
  }
};
var OutputStructNode = class extends Node {
  static get type() {
    return "OutputStructNode";
  }
  constructor(...members) {
    super();
    this.members = members;
    this.isOutputStructNode = true;
  }
  setup(builder) {
    super.setup(builder);
    const members = this.members;
    const types = [];
    for (let i = 0; i < members.length; i++) {
      types.push(members[i].getNodeType(builder));
    }
    this.nodeType = builder.getStructTypeFromNode(new StructTypeNode(types)).name;
  }
  generate(builder, output3) {
    const propertyName = builder.getOutputStructName();
    const members = this.members;
    const structPrefix = propertyName !== "" ? propertyName + "." : "";
    for (let i = 0; i < members.length; i++) {
      const snippet = members[i].build(builder, output3);
      builder.addLineFlowCode(`${structPrefix}m${i} = ${snippet}`, this);
    }
    return propertyName;
  }
};
var outputStruct = nodeProxy(OutputStructNode);
function getTextureIndex(textures, name) {
  for (let i = 0; i < textures.length; i++) {
    if (textures[i].name === name) {
      return i;
    }
  }
  return -1;
}
var MRTNode = class extends OutputStructNode {
  static get type() {
    return "MRTNode";
  }
  constructor(outputNodes) {
    super();
    this.outputNodes = outputNodes;
    this.isMRTNode = true;
  }
  has(name) {
    return this.outputNodes[name] !== void 0;
  }
  get(name) {
    return this.outputNodes[name];
  }
  merge(mrtNode) {
    const outputs = { ...this.outputNodes, ...mrtNode.outputNodes };
    return mrt(outputs);
  }
  setup(builder) {
    const outputNodes = this.outputNodes;
    const mrt3 = builder.renderer.getRenderTarget();
    const members = [];
    const textures = mrt3.textures;
    for (const name in outputNodes) {
      const index = getTextureIndex(textures, name);
      members[index] = vec4(outputNodes[name]);
    }
    this.members = members;
    return super.setup(builder);
  }
};
var mrt = nodeProxy(MRTNode);
var hash = Fn(([seed]) => {
  const state = seed.toUint().mul(747796405).add(2891336453);
  const word = state.shiftRight(state.shiftRight(28).add(4)).bitXor(state).mul(277803737);
  const result = word.shiftRight(22).bitXor(word);
  return result.toFloat().mul(1 / 2 ** 32);
});
var parabola = (x, k) => pow(mul(4, x.mul(sub(1, x))), k);
var gain = (x, k) => x.lessThan(0.5) ? parabola(x.mul(2), k).div(2) : sub(1, parabola(mul(sub(1, x), 2), k).div(2));
var pcurve = (x, a, b) => pow(div(pow(x, a), add(pow(x, a), pow(sub(1, x), b))), 1 / a);
var sinc = (x, k) => sin(PI.mul(k.mul(x).sub(1))).div(PI.mul(k.mul(x).sub(1)));
var tri = Fn(([x]) => {
  return x.fract().sub(0.5).abs();
}).setLayout({
  name: "tri",
  type: "float",
  inputs: [
    { name: "x", type: "float" }
  ]
});
var tri3 = Fn(([p]) => {
  return vec3(tri(p.z.add(tri(p.y.mul(1)))), tri(p.z.add(tri(p.x.mul(1)))), tri(p.y.add(tri(p.x.mul(1)))));
}).setLayout({
  name: "tri3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
var triNoise3D = Fn(([p_immutable, spd, time3]) => {
  const p = vec3(p_immutable).toVar();
  const z = float(1.4).toVar();
  const rz = float(0).toVar();
  const bp = vec3(p).toVar();
  Loop({ start: float(0), end: float(3), type: "float", condition: "<=" }, () => {
    const dg = vec3(tri3(bp.mul(2))).toVar();
    p.addAssign(dg.add(time3.mul(float(0.1).mul(spd))));
    bp.mulAssign(1.8);
    z.mulAssign(1.5);
    p.mulAssign(1.2);
    const t = float(tri(p.z.add(tri(p.x.add(tri(p.y)))))).toVar();
    rz.addAssign(t.div(z));
    bp.addAssign(0.14);
  });
  return rz;
}).setLayout({
  name: "triNoise3D",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "spd", type: "float" },
    { name: "time", type: "float" }
  ]
});
var FunctionOverloadingNode = class extends Node {
  static get type() {
    return "FunctionOverloadingNode";
  }
  constructor(functionNodes = [], ...parametersNodes) {
    super();
    this.functionNodes = functionNodes;
    this.parametersNodes = parametersNodes;
    this._candidateFnCall = null;
    this.global = true;
  }
  getNodeType() {
    return this.functionNodes[0].shaderNode.layout.type;
  }
  setup(builder) {
    const params = this.parametersNodes;
    let candidateFnCall = this._candidateFnCall;
    if (candidateFnCall === null) {
      let candidateFn = null;
      let candidateScore = -1;
      for (const functionNode of this.functionNodes) {
        const shaderNode = functionNode.shaderNode;
        const layout = shaderNode.layout;
        if (layout === null) {
          throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");
        }
        const inputs = layout.inputs;
        if (params.length === inputs.length) {
          let score = 0;
          for (let i = 0; i < params.length; i++) {
            const param = params[i];
            const input = inputs[i];
            if (param.getNodeType(builder) === input.type) {
              score++;
            } else {
              score = 0;
            }
          }
          if (score > candidateScore) {
            candidateFn = functionNode;
            candidateScore = score;
          }
        }
      }
      this._candidateFnCall = candidateFnCall = candidateFn(...params);
    }
    return candidateFnCall;
  }
};
var overloadingBaseFn = nodeProxy(FunctionOverloadingNode);
var overloadingFn = (functionNodes) => (...params) => overloadingBaseFn(functionNodes, ...params);
var time = uniform(0).setGroup(renderGroup).onRenderUpdate((frame) => frame.time);
var deltaTime = uniform(0).setGroup(renderGroup).onRenderUpdate((frame) => frame.deltaTime);
var frameId = uniform(0, "uint").setGroup(renderGroup).onRenderUpdate((frame) => frame.frameId);
var timerLocal = (timeScale = 1) => {
  console.warn('TSL: timerLocal() is deprecated. Use "time" instead.');
  return time.mul(timeScale);
};
var timerGlobal = (timeScale = 1) => {
  console.warn('TSL: timerGlobal() is deprecated. Use "time" instead.');
  return time.mul(timeScale);
};
var timerDelta = (timeScale = 1) => {
  console.warn('TSL: timerDelta() is deprecated. Use "deltaTime" instead.');
  return deltaTime.mul(timeScale);
};
var oscSine = (t = time) => t.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5);
var oscSquare = (t = time) => t.fract().round();
var oscTriangle = (t = time) => t.add(0.5).fract().mul(2).sub(1).abs();
var oscSawtooth = (t = time) => t.fract();
var rotateUV = Fn(([uv3, rotation, center = vec2(0.5)]) => {
  return rotate(uv3.sub(center), rotation).add(center);
});
var spherizeUV = Fn(([uv3, strength, center = vec2(0.5)]) => {
  const delta = uv3.sub(center);
  const delta2 = delta.dot(delta);
  const delta4 = delta2.mul(delta2);
  const deltaOffset = delta4.mul(strength);
  return uv3.add(delta.mul(deltaOffset));
});
var billboarding = Fn(({ position = null, horizontal = true, vertical = false }) => {
  let worldMatrix;
  if (position !== null) {
    worldMatrix = modelWorldMatrix.toVar();
    worldMatrix[3][0] = position.x;
    worldMatrix[3][1] = position.y;
    worldMatrix[3][2] = position.z;
  } else {
    worldMatrix = modelWorldMatrix;
  }
  const modelViewMatrix3 = cameraViewMatrix.mul(worldMatrix);
  if (defined(horizontal)) {
    modelViewMatrix3[0][0] = modelWorldMatrix[0].length();
    modelViewMatrix3[0][1] = 0;
    modelViewMatrix3[0][2] = 0;
  }
  if (defined(vertical)) {
    modelViewMatrix3[1][0] = 0;
    modelViewMatrix3[1][1] = modelWorldMatrix[1].length();
    modelViewMatrix3[1][2] = 0;
  }
  modelViewMatrix3[2][0] = 0;
  modelViewMatrix3[2][1] = 0;
  modelViewMatrix3[2][2] = 1;
  return cameraProjectionMatrix.mul(modelViewMatrix3).mul(positionLocal);
});
var viewportSafeUV = Fn(([uv3 = null]) => {
  const depth3 = linearDepth();
  const depthDiff = linearDepth(viewportDepthTexture(uv3)).sub(depth3);
  const finalUV = depthDiff.lessThan(0).select(screenUV, uv3);
  return finalUV;
});
var SpriteSheetUVNode = class extends Node {
  static get type() {
    return "SpriteSheetUVNode";
  }
  constructor(countNode, uvNode = uv(), frameNode = float(0)) {
    super("vec2");
    this.countNode = countNode;
    this.uvNode = uvNode;
    this.frameNode = frameNode;
  }
  setup() {
    const { frameNode, uvNode, countNode } = this;
    const { width, height } = countNode;
    const frameNum = frameNode.mod(width.mul(height)).floor();
    const column = frameNum.mod(width);
    const row = height.sub(frameNum.add(1).div(width).ceil());
    const scale = countNode.reciprocal();
    const uvFrameOffset = vec2(column, row);
    return uvNode.add(uvFrameOffset).mul(scale);
  }
};
var spritesheetUV = nodeProxy(SpriteSheetUVNode);
var TriplanarTexturesNode = class extends Node {
  static get type() {
    return "TriplanarTexturesNode";
  }
  constructor(textureXNode, textureYNode = null, textureZNode = null, scaleNode = float(1), positionNode = positionLocal, normalNode = normalLocal) {
    super("vec4");
    this.textureXNode = textureXNode;
    this.textureYNode = textureYNode;
    this.textureZNode = textureZNode;
    this.scaleNode = scaleNode;
    this.positionNode = positionNode;
    this.normalNode = normalNode;
  }
  setup() {
    const { textureXNode, textureYNode, textureZNode, scaleNode, positionNode, normalNode } = this;
    let bf = normalNode.abs().normalize();
    bf = bf.div(bf.dot(vec3(1)));
    const tx = positionNode.yz.mul(scaleNode);
    const ty = positionNode.zx.mul(scaleNode);
    const tz = positionNode.xy.mul(scaleNode);
    const textureX = textureXNode.value;
    const textureY = textureYNode !== null ? textureYNode.value : textureX;
    const textureZ = textureZNode !== null ? textureZNode.value : textureX;
    const cx = texture(textureX, tx).mul(bf.x);
    const cy = texture(textureY, ty).mul(bf.y);
    const cz = texture(textureZ, tz).mul(bf.z);
    return add(cx, cy, cz);
  }
};
var triplanarTextures = nodeProxy(TriplanarTexturesNode);
var triplanarTexture = (...params) => triplanarTextures(...params);
var _reflectorPlane = new Plane();
var _normal = new Vector3();
var _reflectorWorldPosition = new Vector3();
var _cameraWorldPosition = new Vector3();
var _rotationMatrix = new Matrix4();
var _lookAtPosition = new Vector3(0, 0, -1);
var clipPlane = new Vector4();
var _view = new Vector3();
var _target = new Vector3();
var _q = new Vector4();
var _size$2 = new Vector2();
var _defaultRT = new RenderTarget();
var _defaultUV = screenUV.flipX();
_defaultRT.depthTexture = new DepthTexture(1, 1);
var _inReflector = false;
var ReflectorNode = class _ReflectorNode extends TextureNode {
  static get type() {
    return "ReflectorNode";
  }
  constructor(parameters = {}) {
    super(parameters.defaultTexture || _defaultRT.texture, _defaultUV);
    this._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode(this, parameters);
    this._depthNode = null;
    this.setUpdateMatrix(false);
  }
  get reflector() {
    return this._reflectorBaseNode;
  }
  get target() {
    return this._reflectorBaseNode.target;
  }
  getDepthNode() {
    if (this._depthNode === null) {
      if (this._reflectorBaseNode.depth !== true) {
        throw new Error("THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ");
      }
      this._depthNode = nodeObject(new _ReflectorNode({
        defaultTexture: _defaultRT.depthTexture,
        reflector: this._reflectorBaseNode
      }));
    }
    return this._depthNode;
  }
  setup(builder) {
    if (!builder.object.isQuadMesh) this._reflectorBaseNode.build(builder);
    return super.setup(builder);
  }
  clone() {
    const texture3 = new this.constructor(this.reflectorNode);
    texture3._reflectorBaseNode = this._reflectorBaseNode;
    return texture3;
  }
};
var ReflectorBaseNode = class extends Node {
  static get type() {
    return "ReflectorBaseNode";
  }
  constructor(textureNode, parameters = {}) {
    super();
    const {
      target = new Object3D(),
      resolution = 1,
      generateMipmaps = false,
      bounces = true,
      depth: depth3 = false
    } = parameters;
    this.textureNode = textureNode;
    this.target = target;
    this.resolution = resolution;
    this.generateMipmaps = generateMipmaps;
    this.bounces = bounces;
    this.depth = depth3;
    this.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;
    this.virtualCameras = /* @__PURE__ */ new WeakMap();
    this.renderTargets = /* @__PURE__ */ new WeakMap();
  }
  _updateResolution(renderTarget, renderer) {
    const resolution = this.resolution;
    renderer.getDrawingBufferSize(_size$2);
    renderTarget.setSize(Math.round(_size$2.width * resolution), Math.round(_size$2.height * resolution));
  }
  setup(builder) {
    this._updateResolution(_defaultRT, builder.renderer);
    return super.setup(builder);
  }
  getVirtualCamera(camera) {
    let virtualCamera = this.virtualCameras.get(camera);
    if (virtualCamera === void 0) {
      virtualCamera = camera.clone();
      this.virtualCameras.set(camera, virtualCamera);
    }
    return virtualCamera;
  }
  getRenderTarget(camera) {
    let renderTarget = this.renderTargets.get(camera);
    if (renderTarget === void 0) {
      renderTarget = new RenderTarget(0, 0, { type: HalfFloatType });
      if (this.generateMipmaps === true) {
        renderTarget.texture.minFilter = LinearMipMapLinearFilter;
        renderTarget.texture.generateMipmaps = true;
      }
      if (this.depth === true) {
        renderTarget.depthTexture = new DepthTexture();
      }
      this.renderTargets.set(camera, renderTarget);
    }
    return renderTarget;
  }
  updateBefore(frame) {
    if (this.bounces === false && _inReflector) return;
    _inReflector = true;
    const { scene, camera, renderer, material } = frame;
    const { target } = this;
    const virtualCamera = this.getVirtualCamera(camera);
    const renderTarget = this.getRenderTarget(virtualCamera);
    renderer.getDrawingBufferSize(_size$2);
    this._updateResolution(renderTarget, renderer);
    _reflectorWorldPosition.setFromMatrixPosition(target.matrixWorld);
    _cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
    _rotationMatrix.extractRotation(target.matrixWorld);
    _normal.set(0, 0, 1);
    _normal.applyMatrix4(_rotationMatrix);
    _view.subVectors(_reflectorWorldPosition, _cameraWorldPosition);
    if (_view.dot(_normal) > 0) return;
    _view.reflect(_normal).negate();
    _view.add(_reflectorWorldPosition);
    _rotationMatrix.extractRotation(camera.matrixWorld);
    _lookAtPosition.set(0, 0, -1);
    _lookAtPosition.applyMatrix4(_rotationMatrix);
    _lookAtPosition.add(_cameraWorldPosition);
    _target.subVectors(_reflectorWorldPosition, _lookAtPosition);
    _target.reflect(_normal).negate();
    _target.add(_reflectorWorldPosition);
    virtualCamera.coordinateSystem = camera.coordinateSystem;
    virtualCamera.position.copy(_view);
    virtualCamera.up.set(0, 1, 0);
    virtualCamera.up.applyMatrix4(_rotationMatrix);
    virtualCamera.up.reflect(_normal);
    virtualCamera.lookAt(_target);
    virtualCamera.near = camera.near;
    virtualCamera.far = camera.far;
    virtualCamera.updateMatrixWorld();
    virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
    _reflectorPlane.setFromNormalAndCoplanarPoint(_normal, _reflectorWorldPosition);
    _reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
    clipPlane.set(_reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant);
    const projectionMatrix = virtualCamera.projectionMatrix;
    _q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
    _q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
    _q.z = -1;
    _q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
    clipPlane.multiplyScalar(1 / clipPlane.dot(_q));
    const clipBias = 0;
    projectionMatrix.elements[2] = clipPlane.x;
    projectionMatrix.elements[6] = clipPlane.y;
    projectionMatrix.elements[10] = renderer.coordinateSystem === WebGPUCoordinateSystem ? clipPlane.z - clipBias : clipPlane.z + 1 - clipBias;
    projectionMatrix.elements[14] = clipPlane.w;
    this.textureNode.value = renderTarget.texture;
    if (this.depth === true) {
      this.textureNode.getDepthNode().value = renderTarget.depthTexture;
    }
    material.visible = false;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentMRT = renderer.getMRT();
    renderer.setMRT(null);
    renderer.setRenderTarget(renderTarget);
    renderer.render(scene, virtualCamera);
    renderer.setMRT(currentMRT);
    renderer.setRenderTarget(currentRenderTarget);
    material.visible = true;
    _inReflector = false;
  }
};
var reflector = (parameters) => nodeObject(new ReflectorNode(parameters));
var _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var QuadGeometry = class extends BufferGeometry {
  constructor(flipY = false) {
    super();
    const uv3 = flipY === false ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];
    this.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    this.setAttribute("uv", new Float32BufferAttribute(uv3, 2));
  }
};
var _geometry = new QuadGeometry();
var QuadMesh = class extends Mesh {
  constructor(material = null) {
    super(_geometry, material);
    this.camera = _camera;
    this.isQuadMesh = true;
  }
  renderAsync(renderer) {
    return renderer.renderAsync(this, _camera);
  }
  render(renderer) {
    renderer.render(this, _camera);
  }
};
var _size$1 = new Vector2();
var RTTNode = class extends TextureNode {
  static get type() {
    return "RTTNode";
  }
  constructor(node, width = null, height = null, options = { type: HalfFloatType }) {
    const renderTarget = new RenderTarget(width, height, options);
    super(renderTarget.texture, uv());
    this.node = node;
    this.width = width;
    this.height = height;
    this.renderTarget = renderTarget;
    this.textureNeedsUpdate = true;
    this.autoUpdate = true;
    this.updateMap = /* @__PURE__ */ new WeakMap();
    this._rttNode = null;
    this._quadMesh = new QuadMesh(new NodeMaterial());
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  get autoSize() {
    return this.width === null;
  }
  setup(builder) {
    this._rttNode = this.node.context(builder.getSharedContext());
    this._quadMesh.material.name = "RTT";
    this._quadMesh.material.needsUpdate = true;
    return super.setup(builder);
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    const effectiveWidth = width * this.pixelRatio;
    const effectiveHeight = height * this.pixelRatio;
    this.renderTarget.setSize(effectiveWidth, effectiveHeight);
    this.textureNeedsUpdate = true;
  }
  setPixelRatio(pixelRatio) {
    this.pixelRatio = pixelRatio;
    this.setSize(this.width, this.height);
  }
  updateBefore({ renderer }) {
    if (this.textureNeedsUpdate === false && this.autoUpdate === false) return;
    this.textureNeedsUpdate = false;
    if (this.autoSize === true) {
      this.pixelRatio = renderer.getPixelRatio();
      const size = renderer.getSize(_size$1);
      this.setSize(size.width, size.height);
    }
    this._quadMesh.material.fragmentNode = this._rttNode;
    const currentRenderTarget = renderer.getRenderTarget();
    renderer.setRenderTarget(this.renderTarget);
    this._quadMesh.render(renderer);
    renderer.setRenderTarget(currentRenderTarget);
  }
  clone() {
    const newNode = new TextureNode(this.value, this.uvNode, this.levelNode);
    newNode.sampler = this.sampler;
    newNode.referenceNode = this;
    return newNode;
  }
};
var rtt = (node, ...params) => nodeObject(new RTTNode(nodeObject(node), ...params));
var convertToTexture = (node, ...params) => {
  if (node.isTextureNode) return node;
  if (node.isPassNode) return node.getTextureNode();
  return rtt(node, ...params);
};
var getViewPosition = Fn(([screenPosition, depth3, projectionMatrixInverse], builder) => {
  let clipSpacePosition;
  if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem) {
    screenPosition = vec2(screenPosition.x, screenPosition.y.oneMinus()).mul(2).sub(1);
    clipSpacePosition = vec4(vec3(screenPosition, depth3), 1);
  } else {
    clipSpacePosition = vec4(vec3(screenPosition.x, screenPosition.y.oneMinus(), depth3).mul(2).sub(1), 1);
  }
  const viewSpacePosition = vec4(projectionMatrixInverse.mul(clipSpacePosition));
  return viewSpacePosition.xyz.div(viewSpacePosition.w);
});
var getScreenPosition = Fn(([viewPosition, projectionMatrix]) => {
  const sampleClipPos = projectionMatrix.mul(vec4(viewPosition, 1));
  const sampleUv = sampleClipPos.xy.div(sampleClipPos.w).mul(0.5).add(0.5).toVar();
  return vec2(sampleUv.x, sampleUv.y.oneMinus());
});
var getNormalFromDepth = Fn(([uv3, depthTexture, projectionMatrixInverse]) => {
  const size = textureSize(textureLoad(depthTexture));
  const p = ivec2(uv3.mul(size)).toVar();
  const c0 = textureLoad(depthTexture, p).toVar();
  const l2 = textureLoad(depthTexture, p.sub(ivec2(2, 0))).toVar();
  const l1 = textureLoad(depthTexture, p.sub(ivec2(1, 0))).toVar();
  const r1 = textureLoad(depthTexture, p.add(ivec2(1, 0))).toVar();
  const r2 = textureLoad(depthTexture, p.add(ivec2(2, 0))).toVar();
  const b2 = textureLoad(depthTexture, p.add(ivec2(0, 2))).toVar();
  const b1 = textureLoad(depthTexture, p.add(ivec2(0, 1))).toVar();
  const t1 = textureLoad(depthTexture, p.sub(ivec2(0, 1))).toVar();
  const t2 = textureLoad(depthTexture, p.sub(ivec2(0, 2))).toVar();
  const dl = abs(sub(float(2).mul(l1).sub(l2), c0)).toVar();
  const dr = abs(sub(float(2).mul(r1).sub(r2), c0)).toVar();
  const db = abs(sub(float(2).mul(b1).sub(b2), c0)).toVar();
  const dt = abs(sub(float(2).mul(t1).sub(t2), c0)).toVar();
  const ce = getViewPosition(uv3, c0, projectionMatrixInverse).toVar();
  const dpdx = dl.lessThan(dr).select(ce.sub(getViewPosition(uv3.sub(vec2(float(1).div(size.x), 0)), l1, projectionMatrixInverse)), ce.negate().add(getViewPosition(uv3.add(vec2(float(1).div(size.x), 0)), r1, projectionMatrixInverse)));
  const dpdy = db.lessThan(dt).select(ce.sub(getViewPosition(uv3.add(vec2(0, float(1).div(size.y))), b1, projectionMatrixInverse)), ce.negate().add(getViewPosition(uv3.sub(vec2(0, float(1).div(size.y))), t1, projectionMatrixInverse)));
  return normalize(cross(dpdx, dpdy));
});
var StorageInstancedBufferAttribute = class extends InstancedBufferAttribute {
  constructor(array, itemSize, typeClass = Float32Array) {
    if (ArrayBuffer.isView(array) === false) array = new typeClass(array * itemSize);
    super(array, itemSize);
    this.isStorageInstancedBufferAttribute = true;
  }
};
var StorageBufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, typeClass = Float32Array) {
    if (ArrayBuffer.isView(array) === false) array = new typeClass(array * itemSize);
    super(array, itemSize);
    this.isStorageBufferAttribute = true;
  }
};
var StorageArrayElementNode = class extends ArrayElementNode {
  static get type() {
    return "StorageArrayElementNode";
  }
  constructor(storageBufferNode, indexNode) {
    super(storageBufferNode, indexNode);
    this.isStorageArrayElementNode = true;
  }
  set storageBufferNode(value) {
    this.node = value;
  }
  get storageBufferNode() {
    return this.node;
  }
  setup(builder) {
    if (builder.isAvailable("storageBuffer") === false) {
      if (this.node.isPBO === true) {
        builder.setupPBO(this.node);
      }
    }
    return super.setup(builder);
  }
  generate(builder, output3) {
    let snippet;
    const isAssignContext = builder.context.assign;
    if (builder.isAvailable("storageBuffer") === false) {
      if (this.node.isPBO === true && isAssignContext !== true && (this.node.value.isInstancedBufferAttribute || builder.shaderStage !== "compute")) {
        snippet = builder.generatePBO(this);
      } else {
        snippet = this.node.build(builder);
      }
    } else {
      snippet = super.generate(builder);
    }
    if (isAssignContext !== true) {
      const type = this.getNodeType(builder);
      snippet = builder.format(snippet, type, output3);
    }
    return snippet;
  }
};
var storageElement = nodeProxy(StorageArrayElementNode);
var StorageBufferNode = class extends BufferNode {
  static get type() {
    return "StorageBufferNode";
  }
  constructor(value, bufferType = null, bufferCount = 0) {
    if (bufferType === null && (value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute)) {
      bufferType = getTypeFromLength(value.itemSize);
      bufferCount = value.count;
    }
    super(value, bufferType, bufferCount);
    this.isStorageBufferNode = true;
    this.access = NodeAccess.READ_WRITE;
    this.isAtomic = false;
    this.isPBO = false;
    this.bufferCount = bufferCount;
    this._attribute = null;
    this._varying = null;
    this.global = true;
    if (value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true) {
      if (value.isInstancedBufferAttribute) value.isStorageInstancedBufferAttribute = true;
      else value.isStorageBufferAttribute = true;
    }
  }
  getHash(builder) {
    if (this.bufferCount === 0) {
      let bufferData = builder.globalCache.getData(this.value);
      if (bufferData === void 0) {
        bufferData = {
          node: this
        };
        builder.globalCache.setData(this.value, bufferData);
      }
      return bufferData.node.uuid;
    }
    return this.uuid;
  }
  getInputType() {
    return this.value.isIndirectStorageBufferAttribute ? "indirectStorageBuffer" : "storageBuffer";
  }
  element(indexNode) {
    return storageElement(this, indexNode);
  }
  setPBO(value) {
    this.isPBO = value;
    return this;
  }
  getPBO() {
    return this.isPBO;
  }
  setAccess(value) {
    this.access = value;
    return this;
  }
  toReadOnly() {
    return this.setAccess(NodeAccess.READ_ONLY);
  }
  setAtomic(value) {
    this.isAtomic = value;
    return this;
  }
  toAtomic() {
    return this.setAtomic(true);
  }
  getAttributeData() {
    if (this._attribute === null) {
      this._attribute = bufferAttribute(this.value);
      this._varying = varying(this._attribute);
    }
    return {
      attribute: this._attribute,
      varying: this._varying
    };
  }
  getNodeType(builder) {
    if (builder.isAvailable("storageBuffer") || builder.isAvailable("indirectStorageBuffer")) {
      return super.getNodeType(builder);
    }
    const { attribute: attribute3 } = this.getAttributeData();
    return attribute3.getNodeType(builder);
  }
  generate(builder) {
    if (builder.isAvailable("storageBuffer") || builder.isAvailable("indirectStorageBuffer")) {
      return super.generate(builder);
    }
    const { attribute: attribute3, varying: varying3 } = this.getAttributeData();
    const output3 = varying3.build(builder);
    builder.registerTransform(output3, attribute3);
    return output3;
  }
};
var storage = (value, type, count) => nodeObject(new StorageBufferNode(value, type, count));
var storageObject = (value, type, count) => {
  console.warn('THREE.TSL: "storageObject()" is deprecated. Use "storage().setPBO( true )" instead.');
  return storage(value, type, count).setPBO(true);
};
var attributeArray = (count, type = "float") => {
  const itemSize = getLengthFromType(type);
  const buffer3 = new StorageBufferAttribute(count, itemSize);
  const node = storage(buffer3, type, count);
  return node;
};
var instancedArray = (count, type = "float") => {
  const itemSize = getLengthFromType(type);
  const buffer3 = new StorageInstancedBufferAttribute(count, itemSize);
  const node = storage(buffer3, type, count);
  return node;
};
var VertexColorNode = class extends AttributeNode {
  static get type() {
    return "VertexColorNode";
  }
  constructor(index = 0) {
    super(null, "vec4");
    this.isVertexColorNode = true;
    this.index = index;
  }
  getAttributeName() {
    const index = this.index;
    return "color" + (index > 0 ? index : "");
  }
  generate(builder) {
    const attributeName = this.getAttributeName(builder);
    const geometryAttribute = builder.hasGeometryAttribute(attributeName);
    let result;
    if (geometryAttribute === true) {
      result = super.generate(builder);
    } else {
      result = builder.generateConst(this.nodeType, new Vector4(1, 1, 1, 1));
    }
    return result;
  }
  serialize(data) {
    super.serialize(data);
    data.index = this.index;
  }
  deserialize(data) {
    super.deserialize(data);
    this.index = data.index;
  }
};
var vertexColor = (...params) => nodeObject(new VertexColorNode(...params));
var PointUVNode = class extends Node {
  static get type() {
    return "PointUVNode";
  }
  constructor() {
    super("vec2");
    this.isPointUVNode = true;
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
};
var pointUV = nodeImmutable(PointUVNode);
var _e1 = new Euler();
var _m1 = new Matrix4();
var SceneNode = class _SceneNode extends Node {
  static get type() {
    return "SceneNode";
  }
  constructor(scope = _SceneNode.BACKGROUND_BLURRINESS, scene = null) {
    super();
    this.scope = scope;
    this.scene = scene;
  }
  setup(builder) {
    const scope = this.scope;
    const scene = this.scene !== null ? this.scene : builder.scene;
    let output3;
    if (scope === _SceneNode.BACKGROUND_BLURRINESS) {
      output3 = reference("backgroundBlurriness", "float", scene);
    } else if (scope === _SceneNode.BACKGROUND_INTENSITY) {
      output3 = reference("backgroundIntensity", "float", scene);
    } else if (scope === _SceneNode.BACKGROUND_ROTATION) {
      output3 = uniform("mat4").label("backgroundRotation").setGroup(renderGroup).onRenderUpdate(() => {
        const background = scene.background;
        if (background !== null && background.isTexture && background.mapping !== UVMapping) {
          _e1.copy(scene.backgroundRotation);
          _e1.x *= -1;
          _e1.y *= -1;
          _e1.z *= -1;
          _m1.makeRotationFromEuler(_e1);
        } else {
          _m1.identity();
        }
        return _m1;
      });
    } else {
      console.error("THREE.SceneNode: Unknown scope:", scope);
    }
    return output3;
  }
};
SceneNode.BACKGROUND_BLURRINESS = "backgroundBlurriness";
SceneNode.BACKGROUND_INTENSITY = "backgroundIntensity";
SceneNode.BACKGROUND_ROTATION = "backgroundRotation";
var backgroundBlurriness = nodeImmutable(SceneNode, SceneNode.BACKGROUND_BLURRINESS);
var backgroundIntensity = nodeImmutable(SceneNode, SceneNode.BACKGROUND_INTENSITY);
var backgroundRotation = nodeImmutable(SceneNode, SceneNode.BACKGROUND_ROTATION);
var StorageTextureNode = class extends TextureNode {
  static get type() {
    return "StorageTextureNode";
  }
  constructor(value, uvNode, storeNode = null) {
    super(value, uvNode);
    this.storeNode = storeNode;
    this.isStorageTextureNode = true;
    this.access = NodeAccess.WRITE_ONLY;
  }
  getInputType() {
    return "storageTexture";
  }
  setup(builder) {
    super.setup(builder);
    const properties = builder.getNodeProperties(this);
    properties.storeNode = this.storeNode;
  }
  setAccess(value) {
    this.access = value;
    return this;
  }
  generate(builder, output3) {
    let snippet;
    if (this.storeNode !== null) {
      snippet = this.generateStore(builder);
    } else {
      snippet = super.generate(builder, output3);
    }
    return snippet;
  }
  toReadWrite() {
    return this.setAccess(NodeAccess.READ_WRITE);
  }
  toReadOnly() {
    return this.setAccess(NodeAccess.READ_ONLY);
  }
  toWriteOnly() {
    return this.setAccess(NodeAccess.WRITE_ONLY);
  }
  generateStore(builder) {
    const properties = builder.getNodeProperties(this);
    const { uvNode, storeNode } = properties;
    const textureProperty = super.generate(builder, "property");
    const uvSnippet = uvNode.build(builder, "uvec2");
    const storeSnippet = storeNode.build(builder, "vec4");
    const snippet = builder.generateTextureStore(builder, textureProperty, uvSnippet, storeSnippet);
    builder.addLineFlowCode(snippet, this);
  }
};
var storageTexture = nodeProxy(StorageTextureNode);
var textureStore = (value, uvNode, storeNode) => {
  const node = storageTexture(value, uvNode, storeNode);
  if (storeNode !== null) node.append();
  return node;
};
var UserDataNode = class extends ReferenceNode {
  static get type() {
    return "UserDataNode";
  }
  constructor(property3, inputType, userData3 = null) {
    super(property3, inputType, userData3);
    this.userData = userData3;
  }
  updateReference(state) {
    this.reference = this.userData !== null ? this.userData : state.object.userData;
    return this.reference;
  }
};
var userData = (name, inputType, userData3) => nodeObject(new UserDataNode(name, inputType, userData3));
var _objectData = /* @__PURE__ */ new WeakMap();
var VelocityNode = class extends TempNode {
  static get type() {
    return "VelocityNode";
  }
  constructor() {
    super("vec2");
    this.projectionMatrix = null;
    this.updateType = NodeUpdateType.OBJECT;
    this.updateAfterType = NodeUpdateType.OBJECT;
    this.previousModelWorldMatrix = uniform(new Matrix4());
    this.previousProjectionMatrix = uniform(new Matrix4()).setGroup(renderGroup);
    this.previousCameraViewMatrix = uniform(new Matrix4());
  }
  setProjectionMatrix(projectionMatrix) {
    this.projectionMatrix = projectionMatrix;
  }
  update({ frameId: frameId3, camera, object }) {
    const previousModelMatrix = getPreviousMatrix(object);
    this.previousModelWorldMatrix.value.copy(previousModelMatrix);
    const cameraData = getData(camera);
    if (cameraData.frameId !== frameId3) {
      cameraData.frameId = frameId3;
      if (cameraData.previousProjectionMatrix === void 0) {
        cameraData.previousProjectionMatrix = new Matrix4();
        cameraData.previousCameraViewMatrix = new Matrix4();
        cameraData.currentProjectionMatrix = new Matrix4();
        cameraData.currentCameraViewMatrix = new Matrix4();
        cameraData.previousProjectionMatrix.copy(this.projectionMatrix || camera.projectionMatrix);
        cameraData.previousCameraViewMatrix.copy(camera.matrixWorldInverse);
      } else {
        cameraData.previousProjectionMatrix.copy(cameraData.currentProjectionMatrix);
        cameraData.previousCameraViewMatrix.copy(cameraData.currentCameraViewMatrix);
      }
      cameraData.currentProjectionMatrix.copy(this.projectionMatrix || camera.projectionMatrix);
      cameraData.currentCameraViewMatrix.copy(camera.matrixWorldInverse);
      this.previousProjectionMatrix.value.copy(cameraData.previousProjectionMatrix);
      this.previousCameraViewMatrix.value.copy(cameraData.previousCameraViewMatrix);
    }
  }
  updateAfter({ object }) {
    getPreviousMatrix(object).copy(object.matrixWorld);
  }
  setup() {
    const projectionMatrix = this.projectionMatrix === null ? cameraProjectionMatrix : uniform(this.projectionMatrix);
    const previousModelViewMatrix = this.previousCameraViewMatrix.mul(this.previousModelWorldMatrix);
    const clipPositionCurrent = projectionMatrix.mul(modelViewMatrix).mul(positionLocal);
    const clipPositionPrevious = this.previousProjectionMatrix.mul(previousModelViewMatrix).mul(positionPrevious);
    const ndcPositionCurrent = clipPositionCurrent.xy.div(clipPositionCurrent.w);
    const ndcPositionPrevious = clipPositionPrevious.xy.div(clipPositionPrevious.w);
    const velocity3 = sub(ndcPositionCurrent, ndcPositionPrevious);
    return velocity3;
  }
};
function getData(object) {
  let objectData = _objectData.get(object);
  if (objectData === void 0) {
    objectData = {};
    _objectData.set(object, objectData);
  }
  return objectData;
}
function getPreviousMatrix(object, index = 0) {
  const objectData = getData(object);
  let matrix = objectData[index];
  if (matrix === void 0) {
    objectData[index] = matrix = new Matrix4();
  }
  return matrix;
}
var velocity = nodeImmutable(VelocityNode);
var blendBurn = Fn(([base, blend]) => {
  return min$1(1, base.oneMinus().div(blend)).oneMinus();
}).setLayout({
  name: "blendBurn",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var blendDodge = Fn(([base, blend]) => {
  return min$1(base.div(blend.oneMinus()), 1);
}).setLayout({
  name: "blendDodge",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var blendScreen = Fn(([base, blend]) => {
  return base.oneMinus().mul(blend.oneMinus()).oneMinus();
}).setLayout({
  name: "blendScreen",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var blendOverlay = Fn(([base, blend]) => {
  return mix(base.mul(2).mul(blend), base.oneMinus().mul(2).mul(blend.oneMinus()).oneMinus(), step(0.5, base));
}).setLayout({
  name: "blendOverlay",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var blendColor = Fn(([base, blend]) => {
  const outAlpha = blend.a.add(base.a.mul(blend.a.oneMinus()));
  return vec4(blend.rgb.mul(blend.a).add(base.rgb.mul(base.a).mul(blend.a.oneMinus())).div(outAlpha), outAlpha);
}).setLayout({
  name: "blendColor",
  type: "vec4",
  inputs: [
    { name: "base", type: "vec4" },
    { name: "blend", type: "vec4" }
  ]
});
var burn = (...params) => {
  console.warn('THREE.TSL: "burn" has been renamed. Use "blendBurn" instead.');
  return blendBurn(params);
};
var dodge = (...params) => {
  console.warn('THREE.TSL: "dodge" has been renamed. Use "blendDodge" instead.');
  return blendDodge(params);
};
var screen = (...params) => {
  console.warn('THREE.TSL: "screen" has been renamed. Use "blendScreen" instead.');
  return blendScreen(params);
};
var overlay = (...params) => {
  console.warn('THREE.TSL: "overlay" has been renamed. Use "blendOverlay" instead.');
  return blendOverlay(params);
};
var grayscale = Fn(([color3]) => {
  return luminance(color3.rgb);
});
var saturation = Fn(([color3, adjustment = float(1)]) => {
  return adjustment.mix(luminance(color3.rgb), color3.rgb);
});
var vibrance = Fn(([color3, adjustment = float(1)]) => {
  const average = add(color3.r, color3.g, color3.b).div(3);
  const mx = color3.r.max(color3.g.max(color3.b));
  const amt = mx.sub(average).mul(adjustment).mul(-3);
  return mix(color3.rgb, mx, amt);
});
var hue = Fn(([color3, adjustment = float(1)]) => {
  const k = vec3(0.57735, 0.57735, 0.57735);
  const cosAngle = adjustment.cos();
  return vec3(color3.rgb.mul(cosAngle).add(k.cross(color3.rgb).mul(adjustment.sin()).add(k.mul(dot(k, color3.rgb).mul(cosAngle.oneMinus())))));
});
var luminance = (color3, luminanceCoefficients = vec3(ColorManagement.getLuminanceCoefficients(new Vector3()))) => dot(color3, luminanceCoefficients);
var threshold = (color3, threshold3) => mix(vec3(0), color3, luminance(color3).sub(threshold3).max(0));
var cdl = Fn(([
  color3,
  slope = vec3(1),
  offset = vec3(0),
  power = vec3(1),
  saturation3 = float(1),
  // ASC CDL v1.2 explicitly requires Rec. 709 luminance coefficients.
  luminanceCoefficients = vec3(ColorManagement.getLuminanceCoefficients(new Vector3(), LinearSRGBColorSpace))
]) => {
  const luma = color3.rgb.dot(vec3(luminanceCoefficients));
  const v = max$1(color3.rgb.mul(slope).add(offset), 0).toVar();
  const pv = v.pow(power).toVar();
  If(v.r.greaterThan(0), () => {
    v.r.assign(pv.r);
  });
  If(v.g.greaterThan(0), () => {
    v.g.assign(pv.g);
  });
  If(v.b.greaterThan(0), () => {
    v.b.assign(pv.b);
  });
  v.assign(luma.add(v.sub(luma).mul(saturation3)));
  return vec4(v.rgb, color3.a);
});
var PosterizeNode = class extends TempNode {
  static get type() {
    return "PosterizeNode";
  }
  constructor(sourceNode, stepsNode) {
    super();
    this.sourceNode = sourceNode;
    this.stepsNode = stepsNode;
  }
  setup() {
    const { sourceNode, stepsNode } = this;
    return sourceNode.mul(stepsNode).floor().div(stepsNode);
  }
};
var posterize = nodeProxy(PosterizeNode);
var _size = new Vector2();
var PassTextureNode = class extends TextureNode {
  static get type() {
    return "PassTextureNode";
  }
  constructor(passNode, texture3) {
    super(texture3);
    this.passNode = passNode;
    this.setUpdateMatrix(false);
  }
  setup(builder) {
    if (builder.object.isQuadMesh) this.passNode.build(builder);
    return super.setup(builder);
  }
  clone() {
    return new this.constructor(this.passNode, this.value);
  }
};
var PassMultipleTextureNode = class extends PassTextureNode {
  static get type() {
    return "PassMultipleTextureNode";
  }
  constructor(passNode, textureName, previousTexture = false) {
    super(passNode, null);
    this.textureName = textureName;
    this.previousTexture = previousTexture;
  }
  updateTexture() {
    this.value = this.previousTexture ? this.passNode.getPreviousTexture(this.textureName) : this.passNode.getTexture(this.textureName);
  }
  setup(builder) {
    this.updateTexture();
    return super.setup(builder);
  }
  clone() {
    return new this.constructor(this.passNode, this.textureName, this.previousTexture);
  }
};
var PassNode = class _PassNode extends TempNode {
  static get type() {
    return "PassNode";
  }
  constructor(scope, scene, camera, options = {}) {
    super("vec4");
    this.scope = scope;
    this.scene = scene;
    this.camera = camera;
    this.options = options;
    this._pixelRatio = 1;
    this._width = 1;
    this._height = 1;
    const depthTexture = new DepthTexture();
    depthTexture.isRenderTargetTexture = true;
    depthTexture.name = "depth";
    const renderTarget = new RenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType, ...options });
    renderTarget.texture.name = "output";
    renderTarget.depthTexture = depthTexture;
    this.renderTarget = renderTarget;
    this.updateBeforeType = NodeUpdateType.FRAME;
    this._textures = {
      output: renderTarget.texture,
      depth: depthTexture
    };
    this._textureNodes = {};
    this._linearDepthNodes = {};
    this._viewZNodes = {};
    this._previousTextures = {};
    this._previousTextureNodes = {};
    this._cameraNear = uniform(0);
    this._cameraFar = uniform(0);
    this._mrt = null;
    this.isPassNode = true;
  }
  setMRT(mrt3) {
    this._mrt = mrt3;
    return this;
  }
  getMRT() {
    return this._mrt;
  }
  isGlobal() {
    return true;
  }
  getTexture(name) {
    let texture3 = this._textures[name];
    if (texture3 === void 0) {
      const refTexture = this.renderTarget.texture;
      texture3 = refTexture.clone();
      texture3.isRenderTargetTexture = true;
      texture3.name = name;
      this._textures[name] = texture3;
      this.renderTarget.textures.push(texture3);
    }
    return texture3;
  }
  getPreviousTexture(name) {
    let texture3 = this._previousTextures[name];
    if (texture3 === void 0) {
      texture3 = this.getTexture(name).clone();
      texture3.isRenderTargetTexture = true;
      this._previousTextures[name] = texture3;
    }
    return texture3;
  }
  toggleTexture(name) {
    const prevTexture = this._previousTextures[name];
    if (prevTexture !== void 0) {
      const texture3 = this._textures[name];
      const index = this.renderTarget.textures.indexOf(texture3);
      this.renderTarget.textures[index] = prevTexture;
      this._textures[name] = prevTexture;
      this._previousTextures[name] = texture3;
      this._textureNodes[name].updateTexture();
      this._previousTextureNodes[name].updateTexture();
    }
  }
  getTextureNode(name = "output") {
    let textureNode = this._textureNodes[name];
    if (textureNode === void 0) {
      textureNode = nodeObject(new PassMultipleTextureNode(this, name));
      textureNode.updateTexture();
      this._textureNodes[name] = textureNode;
    }
    return textureNode;
  }
  getPreviousTextureNode(name = "output") {
    let textureNode = this._previousTextureNodes[name];
    if (textureNode === void 0) {
      if (this._textureNodes[name] === void 0) this.getTextureNode(name);
      textureNode = nodeObject(new PassMultipleTextureNode(this, name, true));
      textureNode.updateTexture();
      this._previousTextureNodes[name] = textureNode;
    }
    return textureNode;
  }
  getViewZNode(name = "depth") {
    let viewZNode = this._viewZNodes[name];
    if (viewZNode === void 0) {
      const cameraNear3 = this._cameraNear;
      const cameraFar3 = this._cameraFar;
      this._viewZNodes[name] = viewZNode = perspectiveDepthToViewZ(this.getTextureNode(name), cameraNear3, cameraFar3);
    }
    return viewZNode;
  }
  getLinearDepthNode(name = "depth") {
    let linearDepthNode = this._linearDepthNodes[name];
    if (linearDepthNode === void 0) {
      const cameraNear3 = this._cameraNear;
      const cameraFar3 = this._cameraFar;
      const viewZNode = this.getViewZNode(name);
      this._linearDepthNodes[name] = linearDepthNode = viewZToOrthographicDepth(viewZNode, cameraNear3, cameraFar3);
    }
    return linearDepthNode;
  }
  setup({ renderer }) {
    this.renderTarget.samples = this.options.samples === void 0 ? renderer.samples : this.options.samples;
    if (renderer.backend.isWebGLBackend === true) {
      this.renderTarget.samples = 0;
    }
    this.renderTarget.depthTexture.isMultisampleRenderTargetTexture = this.renderTarget.samples > 1;
    return this.scope === _PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();
  }
  updateBefore(frame) {
    const { renderer } = frame;
    const { scene, camera } = this;
    this._pixelRatio = renderer.getPixelRatio();
    const size = renderer.getSize(_size);
    this.setSize(size.width, size.height);
    const currentRenderTarget = renderer.getRenderTarget();
    const currentMRT = renderer.getMRT();
    this._cameraNear.value = camera.near;
    this._cameraFar.value = camera.far;
    for (const name in this._previousTextures) {
      this.toggleTexture(name);
    }
    renderer.setRenderTarget(this.renderTarget);
    renderer.setMRT(this._mrt);
    renderer.render(scene, camera);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.setMRT(currentMRT);
  }
  setSize(width, height) {
    this._width = width;
    this._height = height;
    const effectiveWidth = this._width * this._pixelRatio;
    const effectiveHeight = this._height * this._pixelRatio;
    this.renderTarget.setSize(effectiveWidth, effectiveHeight);
  }
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget.dispose();
  }
};
PassNode.COLOR = "color";
PassNode.DEPTH = "depth";
var pass = (scene, camera, options) => nodeObject(new PassNode(PassNode.COLOR, scene, camera, options));
var passTexture = (pass3, texture3) => nodeObject(new PassTextureNode(pass3, texture3));
var depthPass = (scene, camera) => nodeObject(new PassNode(PassNode.DEPTH, scene, camera));
var ToonOutlinePassNode = class extends PassNode {
  static get type() {
    return "ToonOutlinePassNode";
  }
  constructor(scene, camera, colorNode, thicknessNode, alphaNode) {
    super(PassNode.COLOR, scene, camera);
    this.colorNode = colorNode;
    this.thicknessNode = thicknessNode;
    this.alphaNode = alphaNode;
    this._materialCache = /* @__PURE__ */ new WeakMap();
  }
  updateBefore(frame) {
    const { renderer } = frame;
    const currentRenderObjectFunction = renderer.getRenderObjectFunction();
    renderer.setRenderObjectFunction((object, scene, camera, geometry, material, group, lightsNode, clippingContext) => {
      if (material.isMeshToonMaterial || material.isMeshToonNodeMaterial) {
        if (material.wireframe === false) {
          const outlineMaterial = this._getOutlineMaterial(material);
          renderer.renderObject(object, scene, camera, geometry, outlineMaterial, group, lightsNode, clippingContext);
        }
      }
      renderer.renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext);
    });
    super.updateBefore(frame);
    renderer.setRenderObjectFunction(currentRenderObjectFunction);
  }
  _createMaterial() {
    const material = new NodeMaterial();
    material.isMeshToonOutlineMaterial = true;
    material.name = "Toon_Outline";
    material.side = BackSide;
    const outlineNormal = normalLocal.negate();
    const mvp = cameraProjectionMatrix.mul(modelViewMatrix);
    const ratio = float(1);
    const pos = mvp.mul(vec4(positionLocal, 1));
    const pos2 = mvp.mul(vec4(positionLocal.add(outlineNormal), 1));
    const norm = normalize(pos.sub(pos2));
    material.vertexNode = pos.add(norm.mul(this.thicknessNode).mul(pos.w).mul(ratio));
    material.colorNode = vec4(this.colorNode, this.alphaNode);
    return material;
  }
  _getOutlineMaterial(originalMaterial) {
    let outlineMaterial = this._materialCache.get(originalMaterial);
    if (outlineMaterial === void 0) {
      outlineMaterial = this._createMaterial();
      this._materialCache.set(originalMaterial, outlineMaterial);
    }
    return outlineMaterial;
  }
};
var toonOutlinePass = (scene, camera, color3 = new Color(0, 0, 0), thickness3 = 3e-3, alpha = 1) => nodeObject(new ToonOutlinePassNode(scene, camera, nodeObject(color3), nodeObject(thickness3), nodeObject(alpha)));
var linearToneMapping = Fn(([color3, exposure]) => {
  return color3.mul(exposure).clamp();
}).setLayout({
  name: "linearToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
var reinhardToneMapping = Fn(([color3, exposure]) => {
  color3 = color3.mul(exposure);
  return color3.div(color3.add(1)).clamp();
}).setLayout({
  name: "reinhardToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
var cineonToneMapping = Fn(([color3, exposure]) => {
  color3 = color3.mul(exposure);
  color3 = color3.sub(4e-3).max(0);
  const a = color3.mul(color3.mul(6.2).add(0.5));
  const b = color3.mul(color3.mul(6.2).add(1.7)).add(0.06);
  return a.div(b).pow(2.2);
}).setLayout({
  name: "cineonToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
var RRTAndODTFit = Fn(([color3]) => {
  const a = color3.mul(color3.add(0.0245786)).sub(90537e-9);
  const b = color3.mul(color3.add(0.432951).mul(0.983729)).add(0.238081);
  return a.div(b);
});
var acesFilmicToneMapping = Fn(([color3, exposure]) => {
  const ACESInputMat = mat3(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  );
  const ACESOutputMat = mat3(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  color3 = color3.mul(exposure).div(0.6);
  color3 = ACESInputMat.mul(color3);
  color3 = RRTAndODTFit(color3);
  color3 = ACESOutputMat.mul(color3);
  return color3.clamp();
}).setLayout({
  name: "acesFilmicToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
var LINEAR_REC2020_TO_LINEAR_SRGB = mat3(vec3(1.6605, -0.1246, -0.0182), vec3(-0.5876, 1.1329, -0.1006), vec3(-0.0728, -83e-4, 1.1187));
var LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(vec3(0.6274, 0.0691, 0.0164), vec3(0.3293, 0.9195, 0.088), vec3(0.0433, 0.0113, 0.8956));
var agxDefaultContrastApprox = Fn(([x_immutable]) => {
  const x = vec3(x_immutable).toVar();
  const x2 = vec3(x.mul(x)).toVar();
  const x4 = vec3(x2.mul(x2)).toVar();
  return float(15.5).mul(x4.mul(x2)).sub(mul(40.14, x4.mul(x))).add(mul(31.96, x4).sub(mul(6.868, x2.mul(x))).add(mul(0.4298, x2).add(mul(0.1191, x).sub(232e-5))));
});
var agxToneMapping = Fn(([color3, exposure]) => {
  const colortone = vec3(color3).toVar();
  const AgXInsetMatrix = mat3(vec3(0.856627153315983, 0.137318972929847, 0.11189821299995), vec3(0.0951212405381588, 0.761241990602591, 0.0767994186031903), vec3(0.0482516061458583, 0.101439036467562, 0.811302368396859));
  const AgXOutsetMatrix = mat3(vec3(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), vec3(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), vec3(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405));
  const AgxMinEv = float(-12.47393);
  const AgxMaxEv = float(4.026069);
  colortone.mulAssign(exposure);
  colortone.assign(LINEAR_SRGB_TO_LINEAR_REC2020.mul(colortone));
  colortone.assign(AgXInsetMatrix.mul(colortone));
  colortone.assign(max$1(colortone, 1e-10));
  colortone.assign(log2(colortone));
  colortone.assign(colortone.sub(AgxMinEv).div(AgxMaxEv.sub(AgxMinEv)));
  colortone.assign(clamp(colortone, 0, 1));
  colortone.assign(agxDefaultContrastApprox(colortone));
  colortone.assign(AgXOutsetMatrix.mul(colortone));
  colortone.assign(pow(max$1(vec3(0), colortone), vec3(2.2)));
  colortone.assign(LINEAR_REC2020_TO_LINEAR_SRGB.mul(colortone));
  colortone.assign(clamp(colortone, 0, 1));
  return colortone;
}).setLayout({
  name: "agxToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
var neutralToneMapping = Fn(([color3, exposure]) => {
  const StartCompression = float(0.8 - 0.04);
  const Desaturation = float(0.15);
  color3 = color3.mul(exposure);
  const x = min$1(color3.r, min$1(color3.g, color3.b));
  const offset = select(x.lessThan(0.08), x.sub(mul(6.25, x.mul(x))), 0.04);
  color3.subAssign(offset);
  const peak = max$1(color3.r, max$1(color3.g, color3.b));
  If(peak.lessThan(StartCompression), () => {
    return color3;
  });
  const d = sub(1, StartCompression);
  const newPeak = sub(1, d.mul(d).div(peak.add(d.sub(StartCompression))));
  color3.mulAssign(newPeak.div(peak));
  const g = sub(1, div(1, Desaturation.mul(peak.sub(newPeak)).add(1)));
  return mix(color3, vec3(newPeak), g);
}).setLayout({
  name: "neutralToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
var CodeNode = class extends Node {
  static get type() {
    return "CodeNode";
  }
  constructor(code3 = "", includes = [], language = "") {
    super("code");
    this.isCodeNode = true;
    this.code = code3;
    this.language = language;
    this.includes = includes;
  }
  isGlobal() {
    return true;
  }
  setIncludes(includes) {
    this.includes = includes;
    return this;
  }
  getIncludes() {
    return this.includes;
  }
  generate(builder) {
    const includes = this.getIncludes(builder);
    for (const include of includes) {
      include.build(builder);
    }
    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
    nodeCode.code = this.code;
    return nodeCode.code;
  }
  serialize(data) {
    super.serialize(data);
    data.code = this.code;
    data.language = this.language;
  }
  deserialize(data) {
    super.deserialize(data);
    this.code = data.code;
    this.language = data.language;
  }
};
var code = nodeProxy(CodeNode);
var js = (src, includes) => code(src, includes, "js");
var wgsl = (src, includes) => code(src, includes, "wgsl");
var glsl = (src, includes) => code(src, includes, "glsl");
var FunctionNode = class extends CodeNode {
  static get type() {
    return "FunctionNode";
  }
  constructor(code3 = "", includes = [], language = "") {
    super(code3, includes, language);
  }
  getNodeType(builder) {
    return this.getNodeFunction(builder).type;
  }
  getInputs(builder) {
    return this.getNodeFunction(builder).inputs;
  }
  getNodeFunction(builder) {
    const nodeData = builder.getDataFromNode(this);
    let nodeFunction = nodeData.nodeFunction;
    if (nodeFunction === void 0) {
      nodeFunction = builder.parser.parseFunction(this.code);
      nodeData.nodeFunction = nodeFunction;
    }
    return nodeFunction;
  }
  generate(builder, output3) {
    super.generate(builder);
    const nodeFunction = this.getNodeFunction(builder);
    const name = nodeFunction.name;
    const type = nodeFunction.type;
    const nodeCode = builder.getCodeFromNode(this, type);
    if (name !== "") {
      nodeCode.name = name;
    }
    const propertyName = builder.getPropertyName(nodeCode);
    const code3 = this.getNodeFunction(builder).getCode(propertyName);
    nodeCode.code = code3 + "\n";
    if (output3 === "property") {
      return propertyName;
    } else {
      return builder.format(`${propertyName}()`, type, output3);
    }
  }
};
var nativeFn = (code3, includes = [], language = "") => {
  for (let i = 0; i < includes.length; i++) {
    const include = includes[i];
    if (typeof include === "function") {
      includes[i] = include.functionNode;
    }
  }
  const functionNode = nodeObject(new FunctionNode(code3, includes, language));
  const fn = (...params) => functionNode.call(...params);
  fn.functionNode = functionNode;
  return fn;
};
var glslFn = (code3, includes) => nativeFn(code3, includes, "glsl");
var wgslFn = (code3, includes) => nativeFn(code3, includes, "wgsl");
var ScriptableValueNode = class extends Node {
  static get type() {
    return "ScriptableValueNode";
  }
  constructor(value = null) {
    super();
    this._value = value;
    this._cache = null;
    this.inputType = null;
    this.outpuType = null;
    this.events = new EventDispatcher();
    this.isScriptableValueNode = true;
  }
  get isScriptableOutputNode() {
    return this.outputType !== null;
  }
  set value(val) {
    if (this._value === val) return;
    if (this._cache && this.inputType === "URL" && this.value.value instanceof ArrayBuffer) {
      URL.revokeObjectURL(this._cache);
      this._cache = null;
    }
    this._value = val;
    this.events.dispatchEvent({ type: "change" });
    this.refresh();
  }
  get value() {
    return this._value;
  }
  refresh() {
    this.events.dispatchEvent({ type: "refresh" });
  }
  getValue() {
    const value = this.value;
    if (value && this._cache === null && this.inputType === "URL" && value.value instanceof ArrayBuffer) {
      this._cache = URL.createObjectURL(new Blob([value.value]));
    } else if (value && value.value !== null && value.value !== void 0 && ((this.inputType === "URL" || this.inputType === "String") && typeof value.value === "string" || this.inputType === "Number" && typeof value.value === "number" || this.inputType === "Vector2" && value.value.isVector2 || this.inputType === "Vector3" && value.value.isVector3 || this.inputType === "Vector4" && value.value.isVector4 || this.inputType === "Color" && value.value.isColor || this.inputType === "Matrix3" && value.value.isMatrix3 || this.inputType === "Matrix4" && value.value.isMatrix4)) {
      return value.value;
    }
    return this._cache || value;
  }
  getNodeType(builder) {
    return this.value && this.value.isNode ? this.value.getNodeType(builder) : "float";
  }
  setup() {
    return this.value && this.value.isNode ? this.value : float();
  }
  serialize(data) {
    super.serialize(data);
    if (this.value !== null) {
      if (this.inputType === "ArrayBuffer") {
        data.value = arrayBufferToBase64(this.value);
      } else {
        data.value = this.value ? this.value.toJSON(data.meta).uuid : null;
      }
    } else {
      data.value = null;
    }
    data.inputType = this.inputType;
    data.outputType = this.outputType;
  }
  deserialize(data) {
    super.deserialize(data);
    let value = null;
    if (data.value !== null) {
      if (data.inputType === "ArrayBuffer") {
        value = base64ToArrayBuffer(data.value);
      } else if (data.inputType === "Texture") {
        value = data.meta.textures[data.value];
      } else {
        value = data.meta.nodes[data.value] || null;
      }
    }
    this.value = value;
    this.inputType = data.inputType;
    this.outputType = data.outputType;
  }
};
var scriptableValue = nodeProxy(ScriptableValueNode);
var Resources = class extends Map {
  get(key, callback = null, ...params) {
    if (this.has(key)) return super.get(key);
    if (callback !== null) {
      const value = callback(...params);
      this.set(key, value);
      return value;
    }
  }
};
var Parameters = class {
  constructor(scriptableNode) {
    this.scriptableNode = scriptableNode;
  }
  get parameters() {
    return this.scriptableNode.parameters;
  }
  get layout() {
    return this.scriptableNode.getLayout();
  }
  getInputLayout(id) {
    return this.scriptableNode.getInputLayout(id);
  }
  get(name) {
    const param = this.parameters[name];
    const value = param ? param.getValue() : null;
    return value;
  }
};
var ScriptableNodeResources = new Resources();
var ScriptableNode = class extends Node {
  static get type() {
    return "ScriptableNode";
  }
  constructor(codeNode = null, parameters = {}) {
    super();
    this.codeNode = codeNode;
    this.parameters = parameters;
    this._local = new Resources();
    this._output = scriptableValue();
    this._outputs = {};
    this._source = this.source;
    this._method = null;
    this._object = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this.onRefresh = this.onRefresh.bind(this);
    this.isScriptableNode = true;
  }
  get source() {
    return this.codeNode ? this.codeNode.code : "";
  }
  setLocal(name, value) {
    return this._local.set(name, value);
  }
  getLocal(name) {
    return this._local.get(name);
  }
  onRefresh() {
    this._refresh();
  }
  getInputLayout(id) {
    for (const element3 of this.getLayout()) {
      if (element3.inputType && (element3.id === id || element3.name === id)) {
        return element3;
      }
    }
  }
  getOutputLayout(id) {
    for (const element3 of this.getLayout()) {
      if (element3.outputType && (element3.id === id || element3.name === id)) {
        return element3;
      }
    }
  }
  setOutput(name, value) {
    const outputs = this._outputs;
    if (outputs[name] === void 0) {
      outputs[name] = scriptableValue(value);
    } else {
      outputs[name].value = value;
    }
    return this;
  }
  getOutput(name) {
    return this._outputs[name];
  }
  getParameter(name) {
    return this.parameters[name];
  }
  setParameter(name, value) {
    const parameters = this.parameters;
    if (value && value.isScriptableNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].getDefaultOutput().events.addEventListener("refresh", this.onRefresh);
    } else if (value && value.isScriptableValueNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else if (parameters[name] === void 0) {
      parameters[name] = scriptableValue(value);
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else {
      parameters[name].value = value;
    }
    return this;
  }
  getValue() {
    return this.getDefaultOutput().getValue();
  }
  deleteParameter(name) {
    let valueNode = this.parameters[name];
    if (valueNode) {
      if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();
      valueNode.events.removeEventListener("refresh", this.onRefresh);
    }
    return this;
  }
  clearParameters() {
    for (const name of Object.keys(this.parameters)) {
      this.deleteParameter(name);
    }
    this.needsUpdate = true;
    return this;
  }
  call(name, ...params) {
    const object = this.getObject();
    const method = object[name];
    if (typeof method === "function") {
      return method(...params);
    }
  }
  async callAsync(name, ...params) {
    const object = this.getObject();
    const method = object[name];
    if (typeof method === "function") {
      return method.constructor.name === "AsyncFunction" ? await method(...params) : method(...params);
    }
  }
  getNodeType(builder) {
    return this.getDefaultOutputNode().getNodeType(builder);
  }
  refresh(output3 = null) {
    if (output3 !== null) {
      this.getOutput(output3).refresh();
    } else {
      this._refresh();
    }
  }
  getObject() {
    if (this.needsUpdate) this.dispose();
    if (this._object !== null) return this._object;
    const refresh = () => this.refresh();
    const setOutput = (id, value) => this.setOutput(id, value);
    const parameters = new Parameters(this);
    const THREE = ScriptableNodeResources.get("THREE");
    const TSL2 = ScriptableNodeResources.get("TSL");
    const method = this.getMethod(this.codeNode);
    const params = [parameters, this._local, ScriptableNodeResources, refresh, setOutput, THREE, TSL2];
    this._object = method(...params);
    const layout = this._object.layout;
    if (layout) {
      if (layout.cache === false) {
        this._local.clear();
      }
      this._output.outputType = layout.outputType || null;
      if (Array.isArray(layout.elements)) {
        for (const element3 of layout.elements) {
          const id = element3.id || element3.name;
          if (element3.inputType) {
            if (this.getParameter(id) === void 0) this.setParameter(id, null);
            this.getParameter(id).inputType = element3.inputType;
          }
          if (element3.outputType) {
            if (this.getOutput(id) === void 0) this.setOutput(id, null);
            this.getOutput(id).outputType = element3.outputType;
          }
        }
      }
    }
    return this._object;
  }
  deserialize(data) {
    super.deserialize(data);
    for (const name in this.parameters) {
      let valueNode = this.parameters[name];
      if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();
      valueNode.events.addEventListener("refresh", this.onRefresh);
    }
  }
  getLayout() {
    return this.getObject().layout;
  }
  getDefaultOutputNode() {
    const output3 = this.getDefaultOutput().value;
    if (output3 && output3.isNode) {
      return output3;
    }
    return float();
  }
  getDefaultOutput() {
    return this._exec()._output;
  }
  getMethod() {
    if (this.needsUpdate) this.dispose();
    if (this._method !== null) return this._method;
    const parametersProps = ["parameters", "local", "global", "refresh", "setOutput", "THREE", "TSL"];
    const interfaceProps = ["layout", "init", "main", "dispose"];
    const properties = interfaceProps.join(", ");
    const declarations = "var " + properties + "; var output = {};\n";
    const returns = "\nreturn { ...output, " + properties + " };";
    const code3 = declarations + this.codeNode.code + returns;
    this._method = new Function(...parametersProps, code3);
    return this._method;
  }
  dispose() {
    if (this._method === null) return;
    if (this._object && typeof this._object.dispose === "function") {
      this._object.dispose();
    }
    this._method = null;
    this._object = null;
    this._source = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this._output.value = null;
    this._outputs = {};
  }
  setup() {
    return this.getDefaultOutputNode();
  }
  getCacheKey(force) {
    const values = [hashString(this.source), this.getDefaultOutputNode().getCacheKey(force)];
    for (const param in this.parameters) {
      values.push(this.parameters[param].getCacheKey(force));
    }
    return hashArray(values);
  }
  set needsUpdate(value) {
    if (value === true) this.dispose();
  }
  get needsUpdate() {
    return this.source !== this._source;
  }
  _exec() {
    if (this.codeNode === null) return this;
    if (this._needsOutputUpdate === true) {
      this._value = this.call("main");
      this._needsOutputUpdate = false;
    }
    this._output.value = this._value;
    return this;
  }
  _refresh() {
    this.needsUpdate = true;
    this._exec();
    this._output.refresh();
  }
};
var scriptable = nodeProxy(ScriptableNode);
var FogNode = class extends Node {
  static get type() {
    return "FogNode";
  }
  constructor(colorNode, factorNode) {
    super("float");
    this.isFogNode = true;
    this.colorNode = colorNode;
    this.factorNode = factorNode;
  }
  getViewZNode(builder) {
    let viewZ;
    const getViewZ = builder.context.getViewZ;
    if (getViewZ !== void 0) {
      viewZ = getViewZ(this);
    }
    return (viewZ || positionView.z).negate();
  }
  setup() {
    return this.factorNode;
  }
};
var fog = nodeProxy(FogNode);
var FogRangeNode = class extends FogNode {
  static get type() {
    return "FogRangeNode";
  }
  constructor(colorNode, nearNode, farNode) {
    super(colorNode);
    this.isFogRangeNode = true;
    this.nearNode = nearNode;
    this.farNode = farNode;
  }
  setup(builder) {
    const viewZ = this.getViewZNode(builder);
    return smoothstep(this.nearNode, this.farNode, viewZ);
  }
};
var rangeFog = nodeProxy(FogRangeNode);
var FogExp2Node = class extends FogNode {
  static get type() {
    return "FogExp2Node";
  }
  constructor(colorNode, densityNode) {
    super(colorNode);
    this.isFogExp2Node = true;
    this.densityNode = densityNode;
  }
  setup(builder) {
    const viewZ = this.getViewZNode(builder);
    const density = this.densityNode;
    return density.mul(density, viewZ, viewZ).negate().exp().oneMinus();
  }
};
var densityFog = nodeProxy(FogExp2Node);
var min = null;
var max = null;
var RangeNode = class extends Node {
  static get type() {
    return "RangeNode";
  }
  constructor(minNode = float(), maxNode = float()) {
    super();
    this.minNode = minNode;
    this.maxNode = maxNode;
  }
  getVectorLength(builder) {
    const minLength = builder.getTypeLength(getValueType(this.minNode.value));
    const maxLength = builder.getTypeLength(getValueType(this.maxNode.value));
    return minLength > maxLength ? minLength : maxLength;
  }
  getNodeType(builder) {
    return builder.object.count > 1 ? builder.getTypeFromLength(this.getVectorLength(builder)) : "float";
  }
  setup(builder) {
    const object = builder.object;
    let output3 = null;
    if (object.count > 1) {
      const minValue = this.minNode.value;
      const maxValue = this.maxNode.value;
      const minLength = builder.getTypeLength(getValueType(minValue));
      const maxLength = builder.getTypeLength(getValueType(maxValue));
      min = min || new Vector4();
      max = max || new Vector4();
      min.setScalar(0);
      max.setScalar(0);
      if (minLength === 1) min.setScalar(minValue);
      else if (minValue.isColor) min.set(minValue.r, minValue.g, minValue.b);
      else min.set(minValue.x, minValue.y, minValue.z || 0, minValue.w || 0);
      if (maxLength === 1) max.setScalar(maxValue);
      else if (maxValue.isColor) max.set(maxValue.r, maxValue.g, maxValue.b);
      else max.set(maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0);
      const stride = 4;
      const length3 = stride * object.count;
      const array = new Float32Array(length3);
      for (let i = 0; i < length3; i++) {
        const index = i % stride;
        const minElementValue = min.getComponent(index);
        const maxElementValue = max.getComponent(index);
        array[i] = MathUtils.lerp(minElementValue, maxElementValue, Math.random());
      }
      const nodeType = this.getNodeType(builder);
      if (object.count <= 4096) {
        output3 = buffer(array, "vec4", object.count).element(instanceIndex).convert(nodeType);
      } else {
        const bufferAttribute3 = new InstancedBufferAttribute(array, 4);
        builder.geometry.setAttribute("__range" + this.id, bufferAttribute3);
        output3 = instancedBufferAttribute(bufferAttribute3).convert(nodeType);
      }
    } else {
      output3 = float(0);
    }
    return output3;
  }
};
var range = nodeProxy(RangeNode);
var ComputeBuiltinNode = class extends Node {
  static get type() {
    return "ComputeBuiltinNode";
  }
  constructor(builtinName, nodeType) {
    super(nodeType);
    this._builtinName = builtinName;
  }
  getHash(builder) {
    return this.getBuiltinName(builder);
  }
  getNodeType() {
    return this.nodeType;
  }
  setBuiltinName(builtinName) {
    this._builtinName = builtinName;
    return this;
  }
  getBuiltinName() {
    return this._builtinName;
  }
  hasBuiltin(builder) {
    builder.hasBuiltin(this._builtinName);
  }
  generate(builder, output3) {
    const builtinName = this.getBuiltinName(builder);
    const nodeType = this.getNodeType(builder);
    if (builder.shaderStage === "compute") {
      return builder.format(builtinName, nodeType, output3);
    } else {
      console.warn(`ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage`);
      return builder.generateConst(nodeType);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.global = this.global;
    data._builtinName = this._builtinName;
  }
  deserialize(data) {
    super.deserialize(data);
    this.global = data.global;
    this._builtinName = data._builtinName;
  }
};
var computeBuiltin = (name, nodeType) => nodeObject(new ComputeBuiltinNode(name, nodeType));
var numWorkgroups = computeBuiltin("numWorkgroups", "uvec3");
var workgroupId = computeBuiltin("workgroupId", "uvec3");
var localId = computeBuiltin("localId", "uvec3");
var subgroupSize = computeBuiltin("subgroupSize", "uint");
var BarrierNode = class extends Node {
  constructor(scope) {
    super();
    this.scope = scope;
  }
  generate(builder) {
    const { scope } = this;
    const { renderer } = builder;
    if (renderer.backend.isWebGLBackend === true) {
      builder.addFlowCode(`	// ${scope}Barrier 
`);
    } else {
      builder.addLineFlowCode(`${scope}Barrier()`, this);
    }
  }
};
var barrier = nodeProxy(BarrierNode);
var workgroupBarrier = () => barrier("workgroup").append();
var storageBarrier = () => barrier("storage").append();
var textureBarrier = () => barrier("texture").append();
var WorkgroupInfoElementNode = class extends ArrayElementNode {
  constructor(workgroupInfoNode, indexNode) {
    super(workgroupInfoNode, indexNode);
    this.isWorkgroupInfoElementNode = true;
  }
  generate(builder, output3) {
    let snippet;
    const isAssignContext = builder.context.assign;
    snippet = super.generate(builder);
    if (isAssignContext !== true) {
      const type = this.getNodeType(builder);
      snippet = builder.format(snippet, type, output3);
    }
    return snippet;
  }
};
var WorkgroupInfoNode = class extends Node {
  constructor(scope, bufferType, bufferCount = 0) {
    super(bufferType);
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
    this.isWorkgroupInfoNode = true;
    this.scope = scope;
  }
  label(name) {
    this.name = name;
    return this;
  }
  getHash() {
    return this.uuid;
  }
  setScope(scope) {
    this.scope = scope;
    return this;
  }
  getInputType() {
    return `${this.scope}Array`;
  }
  element(indexNode) {
    return nodeObject(new WorkgroupInfoElementNode(this, indexNode));
  }
  generate(builder) {
    return builder.getScopedArray(this.name || `${this.scope}Array_${this.id}`, this.scope.toLowerCase(), this.bufferType, this.bufferCount);
  }
};
var workgroupArray = (type, count) => nodeObject(new WorkgroupInfoNode("Workgroup", type, count));
var AtomicFunctionNode = class extends TempNode {
  static get type() {
    return "AtomicFunctionNode";
  }
  constructor(method, pointerNode, valueNode, storeNode = null) {
    super("uint");
    this.method = method;
    this.pointerNode = pointerNode;
    this.valueNode = valueNode;
    this.storeNode = storeNode;
  }
  getInputType(builder) {
    return this.pointerNode.getNodeType(builder);
  }
  getNodeType(builder) {
    return this.getInputType(builder);
  }
  generate(builder) {
    const method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.pointerNode;
    const b = this.valueNode;
    const params = [];
    params.push(`&${a.build(builder, inputType)}`);
    params.push(b.build(builder, inputType));
    const methodSnippet = `${builder.getMethod(method, type)}( ${params.join(", ")} )`;
    if (this.storeNode !== null) {
      const varSnippet = this.storeNode.build(builder, inputType);
      builder.addLineFlowCode(`${varSnippet} = ${methodSnippet}`, this);
    } else {
      builder.addLineFlowCode(methodSnippet, this);
    }
  }
};
AtomicFunctionNode.ATOMIC_LOAD = "atomicLoad";
AtomicFunctionNode.ATOMIC_STORE = "atomicStore";
AtomicFunctionNode.ATOMIC_ADD = "atomicAdd";
AtomicFunctionNode.ATOMIC_SUB = "atomicSub";
AtomicFunctionNode.ATOMIC_MAX = "atomicMax";
AtomicFunctionNode.ATOMIC_MIN = "atomicMin";
AtomicFunctionNode.ATOMIC_AND = "atomicAnd";
AtomicFunctionNode.ATOMIC_OR = "atomicOr";
AtomicFunctionNode.ATOMIC_XOR = "atomicXor";
var atomicNode = nodeProxy(AtomicFunctionNode);
var atomicFunc = (method, pointerNode, valueNode, storeNode) => {
  const node = atomicNode(method, pointerNode, valueNode, storeNode);
  node.append();
  return node;
};
var atomicStore = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode, storeNode);
var atomicAdd = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode, storeNode);
var atomicSub = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode, storeNode);
var atomicMax = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode, storeNode);
var atomicMin = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode, storeNode);
var atomicAnd = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode, storeNode);
var atomicOr = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode, storeNode);
var atomicXor = (pointerNode, valueNode, storeNode = null) => atomicFunc(AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode, storeNode);
var uniformsLib;
function getLightData(light) {
  uniformsLib = uniformsLib || /* @__PURE__ */ new WeakMap();
  let uniforms3 = uniformsLib.get(light);
  if (uniforms3 === void 0) uniformsLib.set(light, uniforms3 = {});
  return uniforms3;
}
function lightShadowMatrix(light) {
  const data = getLightData(light);
  return data.shadowMatrix || (data.shadowMatrix = uniform("mat4").setGroup(renderGroup).onRenderUpdate(() => {
    light.shadow.updateMatrices(light);
    return light.shadow.matrix;
  }));
}
function lightProjectionUV(light) {
  const data = getLightData(light);
  if (data.projectionUV === void 0) {
    const spotLightCoord = lightShadowMatrix(light).mul(positionWorld);
    data.projectionUV = spotLightCoord.xyz.div(spotLightCoord.w);
  }
  return data.projectionUV;
}
function lightPosition(light) {
  const data = getLightData(light);
  return data.position || (data.position = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate((_, self2) => self2.value.setFromMatrixPosition(light.matrixWorld)));
}
function lightTargetPosition(light) {
  const data = getLightData(light);
  return data.targetPosition || (data.targetPosition = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate((_, self2) => self2.value.setFromMatrixPosition(light.target.matrixWorld)));
}
function lightViewPosition(light) {
  const data = getLightData(light);
  return data.viewPosition || (data.viewPosition = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate(({ camera }, self2) => {
    self2.value = self2.value || new Vector3();
    self2.value.setFromMatrixPosition(light.matrixWorld);
    self2.value.applyMatrix4(camera.matrixWorldInverse);
  }));
}
var lightTargetDirection = (light) => cameraViewMatrix.transformDirection(lightPosition(light).sub(lightTargetPosition(light)));
var sortLights = (lights3) => {
  return lights3.sort((a, b) => a.id - b.id);
};
var getLightNodeById = (id, lightNodes) => {
  for (const lightNode of lightNodes) {
    if (lightNode.isAnalyticLightNode && lightNode.light.id === id) {
      return lightNode;
    }
  }
  return null;
};
var _lightsNodeRef = /* @__PURE__ */ new WeakMap();
var LightsNode = class extends Node {
  static get type() {
    return "LightsNode";
  }
  constructor() {
    super("vec3");
    this.totalDiffuseNode = vec3().toVar("totalDiffuse");
    this.totalSpecularNode = vec3().toVar("totalSpecular");
    this.outgoingLightNode = vec3().toVar("outgoingLight");
    this._lights = [];
    this._lightNodes = null;
    this._lightNodesHash = null;
    this.global = true;
  }
  getHash(builder) {
    if (this._lightNodesHash === null) {
      if (this._lightNodes === null) this.setupLightsNode(builder);
      const hash3 = [];
      for (const lightNode of this._lightNodes) {
        hash3.push(lightNode.getSelf().getHash());
      }
      this._lightNodesHash = "lights-" + hash3.join(",");
    }
    return this._lightNodesHash;
  }
  analyze(builder) {
    const properties = builder.getDataFromNode(this);
    for (const node of properties.nodes) {
      node.build(builder);
    }
  }
  setupLightsNode(builder) {
    const lightNodes = [];
    const previousLightNodes = this._lightNodes;
    const lights3 = sortLights(this._lights);
    const nodeLibrary = builder.renderer.library;
    for (const light of lights3) {
      if (light.isNode) {
        lightNodes.push(nodeObject(light));
      } else {
        let lightNode = null;
        if (previousLightNodes !== null) {
          lightNode = getLightNodeById(light.id, previousLightNodes);
        }
        if (lightNode === null) {
          const lightNodeClass = nodeLibrary.getLightNodeClass(light.constructor);
          if (lightNodeClass === null) {
            console.warn(`LightsNode.setupNodeLights: Light node not found for ${light.constructor.name}`);
            continue;
          }
          let lightNode2 = null;
          if (!_lightsNodeRef.has(light)) {
            lightNode2 = nodeObject(new lightNodeClass(light));
            _lightsNodeRef.set(light, lightNode2);
          } else {
            lightNode2 = _lightsNodeRef.get(light);
          }
          lightNodes.push(lightNode2);
        }
      }
    }
    this._lightNodes = lightNodes;
  }
  setupLights(builder, lightNodes) {
    for (const lightNode of lightNodes) {
      lightNode.build(builder);
    }
  }
  setup(builder) {
    if (this._lightNodes === null) this.setupLightsNode(builder);
    const context3 = builder.context;
    const lightingModel = context3.lightingModel;
    let outgoingLightNode = this.outgoingLightNode;
    if (lightingModel) {
      const { _lightNodes, totalDiffuseNode, totalSpecularNode } = this;
      context3.outgoingLight = outgoingLightNode;
      const stack3 = builder.addStack();
      const properties = builder.getDataFromNode(this);
      properties.nodes = stack3.nodes;
      lightingModel.start(context3, stack3, builder);
      this.setupLights(builder, _lightNodes);
      lightingModel.indirect(context3, stack3, builder);
      const { backdrop, backdropAlpha } = context3;
      const { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context3.reflectedLight;
      let totalDiffuse = directDiffuse.add(indirectDiffuse);
      if (backdrop !== null) {
        if (backdropAlpha !== null) {
          totalDiffuse = vec3(backdropAlpha.mix(totalDiffuse, backdrop));
        } else {
          totalDiffuse = vec3(backdrop);
        }
        context3.material.transparent = true;
      }
      totalDiffuseNode.assign(totalDiffuse);
      totalSpecularNode.assign(directSpecular.add(indirectSpecular));
      outgoingLightNode.assign(totalDiffuseNode.add(totalSpecularNode));
      lightingModel.finish(context3, stack3, builder);
      outgoingLightNode = outgoingLightNode.bypass(builder.removeStack());
    }
    return outgoingLightNode;
  }
  setLights(lights3) {
    this._lights = lights3;
    this._lightNodes = null;
    this._lightNodesHash = null;
    return this;
  }
  getLights() {
    return this._lights;
  }
  get hasLights() {
    return this._lights.length > 0;
  }
};
var lights = (lights3 = []) => nodeObject(new LightsNode()).setLights(lights3);
var shadowMaterialLib = /* @__PURE__ */ new WeakMap();
var shadowWorldPosition = vec3().toVar("shadowWorldPosition");
var linearDistance = Fn(([position, cameraNear3, cameraFar3]) => {
  let dist = positionWorld.sub(position).length();
  dist = dist.sub(cameraNear3).div(cameraFar3.sub(cameraNear3));
  dist = dist.saturate();
  return dist;
});
var linearShadowDistance = (light) => {
  const camera = light.shadow.camera;
  const nearDistance = reference("near", "float", camera).setGroup(renderGroup);
  const farDistance = reference("far", "float", camera).setGroup(renderGroup);
  const referencePosition = objectPosition(light);
  return linearDistance(referencePosition, nearDistance, farDistance);
};
var getShadowMaterial = (light) => {
  let material = shadowMaterialLib.get(light);
  if (material === void 0) {
    const depthNode = light.isPointLight ? linearShadowDistance(light) : null;
    material = new NodeMaterial();
    material.colorNode = vec4(0, 0, 0, 1);
    material.depthNode = depthNode;
    material.isShadowNodeMaterial = true;
    material.blending = NoBlending;
    material.name = "ShadowMaterial";
    shadowMaterialLib.set(light, material);
  }
  return material;
};
var BasicShadowFilter = Fn(({ depthTexture, shadowCoord }) => {
  return texture(depthTexture, shadowCoord.xy).compare(shadowCoord.z);
});
var PCFShadowFilter = Fn(({ depthTexture, shadowCoord, shadow: shadow3 }) => {
  const depthCompare = (uv3, compare) => texture(depthTexture, uv3).compare(compare);
  const mapSize = reference("mapSize", "vec2", shadow3).setGroup(renderGroup);
  const radius = reference("radius", "float", shadow3).setGroup(renderGroup);
  const texelSize = vec2(1).div(mapSize);
  const dx0 = texelSize.x.negate().mul(radius);
  const dy0 = texelSize.y.negate().mul(radius);
  const dx1 = texelSize.x.mul(radius);
  const dy1 = texelSize.y.mul(radius);
  const dx2 = dx0.div(2);
  const dy2 = dy0.div(2);
  const dx3 = dx1.div(2);
  const dy3 = dy1.div(2);
  return add(
    depthCompare(shadowCoord.xy.add(vec2(dx0, dy0)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(0, dy0)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx1, dy0)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx2, dy2)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(0, dy2)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx3, dy2)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx0, 0)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx2, 0)), shadowCoord.z),
    depthCompare(shadowCoord.xy, shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx3, 0)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx1, 0)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx2, dy3)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(0, dy3)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx3, dy3)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx0, dy1)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(0, dy1)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx1, dy1)), shadowCoord.z)
  ).mul(1 / 17);
});
var PCFSoftShadowFilter = Fn(({ depthTexture, shadowCoord, shadow: shadow3 }) => {
  const depthCompare = (uv4, compare) => texture(depthTexture, uv4).compare(compare);
  const mapSize = reference("mapSize", "vec2", shadow3).setGroup(renderGroup);
  const texelSize = vec2(1).div(mapSize);
  const dx = texelSize.x;
  const dy = texelSize.y;
  const uv3 = shadowCoord.xy;
  const f = fract(uv3.mul(mapSize).add(0.5));
  uv3.subAssign(f.mul(texelSize));
  return add(
    depthCompare(uv3, shadowCoord.z),
    depthCompare(uv3.add(vec2(dx, 0)), shadowCoord.z),
    depthCompare(uv3.add(vec2(0, dy)), shadowCoord.z),
    depthCompare(uv3.add(texelSize), shadowCoord.z),
    mix(
      depthCompare(uv3.add(vec2(dx.negate(), 0)), shadowCoord.z),
      depthCompare(uv3.add(vec2(dx.mul(2), 0)), shadowCoord.z),
      f.x
    ),
    mix(
      depthCompare(uv3.add(vec2(dx.negate(), dy)), shadowCoord.z),
      depthCompare(uv3.add(vec2(dx.mul(2), dy)), shadowCoord.z),
      f.x
    ),
    mix(
      depthCompare(uv3.add(vec2(0, dy.negate())), shadowCoord.z),
      depthCompare(uv3.add(vec2(0, dy.mul(2))), shadowCoord.z),
      f.y
    ),
    mix(
      depthCompare(uv3.add(vec2(dx, dy.negate())), shadowCoord.z),
      depthCompare(uv3.add(vec2(dx, dy.mul(2))), shadowCoord.z),
      f.y
    ),
    mix(
      mix(
        depthCompare(uv3.add(vec2(dx.negate(), dy.negate())), shadowCoord.z),
        depthCompare(uv3.add(vec2(dx.mul(2), dy.negate())), shadowCoord.z),
        f.x
      ),
      mix(
        depthCompare(uv3.add(vec2(dx.negate(), dy.mul(2))), shadowCoord.z),
        depthCompare(uv3.add(vec2(dx.mul(2), dy.mul(2))), shadowCoord.z),
        f.x
      ),
      f.y
    )
  ).mul(1 / 9);
});
var VSMShadowFilter = Fn(({ depthTexture, shadowCoord }) => {
  const occlusion = float(1).toVar();
  const distribution = texture(depthTexture).uv(shadowCoord.xy).rg;
  const hardShadow = step(shadowCoord.z, distribution.x);
  If(hardShadow.notEqual(float(1)), () => {
    const distance3 = shadowCoord.z.sub(distribution.x);
    const variance = max$1(0, distribution.y.mul(distribution.y));
    let softnessProbability = variance.div(variance.add(distance3.mul(distance3)));
    softnessProbability = clamp(sub(softnessProbability, 0.3).div(0.95 - 0.3));
    occlusion.assign(clamp(max$1(hardShadow, softnessProbability)));
  });
  return occlusion;
});
var VSMPassVertical = Fn(({ samples, radius, size, shadowPass }) => {
  const mean = float(0).toVar();
  const squaredMean = float(0).toVar();
  const uvStride = samples.lessThanEqual(float(1)).select(float(0), float(2).div(samples.sub(1)));
  const uvStart = samples.lessThanEqual(float(1)).select(float(0), float(-1));
  Loop({ start: int(0), end: int(samples), type: "int", condition: "<" }, ({ i }) => {
    const uvOffset = uvStart.add(float(i).mul(uvStride));
    const depth3 = shadowPass.uv(add(screenCoordinate.xy, vec2(0, uvOffset).mul(radius)).div(size)).x;
    mean.addAssign(depth3);
    squaredMean.addAssign(depth3.mul(depth3));
  });
  mean.divAssign(samples);
  squaredMean.divAssign(samples);
  const std_dev = sqrt(squaredMean.sub(mean.mul(mean)));
  return vec2(mean, std_dev);
});
var VSMPassHorizontal = Fn(({ samples, radius, size, shadowPass }) => {
  const mean = float(0).toVar();
  const squaredMean = float(0).toVar();
  const uvStride = samples.lessThanEqual(float(1)).select(float(0), float(2).div(samples.sub(1)));
  const uvStart = samples.lessThanEqual(float(1)).select(float(0), float(-1));
  Loop({ start: int(0), end: int(samples), type: "int", condition: "<" }, ({ i }) => {
    const uvOffset = uvStart.add(float(i).mul(uvStride));
    const distribution = shadowPass.uv(add(screenCoordinate.xy, vec2(uvOffset, 0).mul(radius)).div(size));
    mean.addAssign(distribution.x);
    squaredMean.addAssign(add(distribution.y.mul(distribution.y), distribution.x.mul(distribution.x)));
  });
  mean.divAssign(samples);
  squaredMean.divAssign(samples);
  const std_dev = sqrt(squaredMean.sub(mean.mul(mean)));
  return vec2(mean, std_dev);
});
var _shadowFilterLib = [BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter];
var _quadMesh$1 = new QuadMesh();
var ShadowNode = class extends Node {
  static get type() {
    return "ShadowNode";
  }
  constructor(light, shadow3 = null) {
    super();
    this.light = light;
    this.shadow = shadow3 || light.shadow;
    this.shadowMap = null;
    this.vsmShadowMapVertical = null;
    this.vsmShadowMapHorizontal = null;
    this.vsmMaterialVertical = null;
    this.vsmMaterialHorizontal = null;
    this.updateBeforeType = NodeUpdateType.RENDER;
    this._node = null;
    this.isShadowNode = true;
  }
  setupShadowFilter(builder, { filterFn, depthTexture, shadowCoord, shadow: shadow3 }) {
    const frustumTest = shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1));
    const shadowNode = filterFn({ depthTexture, shadowCoord, shadow: shadow3 });
    return frustumTest.select(shadowNode, float(1));
  }
  setupShadowCoord(builder, shadowPosition) {
    const { shadow: shadow3 } = this;
    const { renderer } = builder;
    const bias = reference("bias", "float", shadow3).setGroup(renderGroup);
    let shadowCoord = shadowPosition;
    let coordZ;
    if (shadow3.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true) {
      shadowCoord = shadowCoord.xyz.div(shadowCoord.w);
      coordZ = shadowCoord.z;
      if (renderer.coordinateSystem === WebGPUCoordinateSystem) {
        coordZ = coordZ.mul(2).sub(1);
      }
    } else {
      const w = shadowCoord.w;
      shadowCoord = shadowCoord.xy.div(w);
      const cameraNearLocal = reference("near", "float", shadow3.camera).setGroup(renderGroup);
      const cameraFarLocal = reference("far", "float", shadow3.camera).setGroup(renderGroup);
      coordZ = viewZToLogarithmicDepth(w.negate(), cameraNearLocal, cameraFarLocal);
    }
    shadowCoord = vec3(
      shadowCoord.x,
      shadowCoord.y.oneMinus(),
      // follow webgpu standards
      coordZ.add(bias)
    );
    return shadowCoord;
  }
  getShadowFilterFn(type) {
    return _shadowFilterLib[type];
  }
  setupShadow(builder) {
    const { renderer } = builder;
    const { light, shadow: shadow3 } = this;
    const shadowMapType = renderer.shadowMap.type;
    const depthTexture = new DepthTexture(shadow3.mapSize.width, shadow3.mapSize.height);
    depthTexture.compareFunction = LessCompare;
    const shadowMap = builder.createRenderTarget(shadow3.mapSize.width, shadow3.mapSize.height);
    shadowMap.depthTexture = depthTexture;
    shadow3.camera.updateProjectionMatrix();
    if (shadowMapType === VSMShadowMap) {
      depthTexture.compareFunction = null;
      this.vsmShadowMapVertical = builder.createRenderTarget(shadow3.mapSize.width, shadow3.mapSize.height, { format: RGFormat, type: HalfFloatType });
      this.vsmShadowMapHorizontal = builder.createRenderTarget(shadow3.mapSize.width, shadow3.mapSize.height, { format: RGFormat, type: HalfFloatType });
      const shadowPassVertical = texture(depthTexture);
      const shadowPassHorizontal = texture(this.vsmShadowMapVertical.texture);
      const samples = reference("blurSamples", "float", shadow3).setGroup(renderGroup);
      const radius = reference("radius", "float", shadow3).setGroup(renderGroup);
      const size = reference("mapSize", "vec2", shadow3).setGroup(renderGroup);
      let material = this.vsmMaterialVertical || (this.vsmMaterialVertical = new NodeMaterial());
      material.fragmentNode = VSMPassVertical({ samples, radius, size, shadowPass: shadowPassVertical }).context(builder.getSharedContext());
      material.name = "VSMVertical";
      material = this.vsmMaterialHorizontal || (this.vsmMaterialHorizontal = new NodeMaterial());
      material.fragmentNode = VSMPassHorizontal({ samples, radius, size, shadowPass: shadowPassHorizontal }).context(builder.getSharedContext());
      material.name = "VSMHorizontal";
    }
    const shadowIntensity = reference("intensity", "float", shadow3).setGroup(renderGroup);
    const normalBias = reference("normalBias", "float", shadow3).setGroup(renderGroup);
    const shadowPosition = lightShadowMatrix(light).mul(shadowWorldPosition.add(transformedNormalWorld.mul(normalBias)));
    const shadowCoord = this.setupShadowCoord(builder, shadowPosition);
    const filterFn = shadow3.filterNode || this.getShadowFilterFn(renderer.shadowMap.type) || null;
    if (filterFn === null) {
      throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");
    }
    const shadowDepthTexture = shadowMapType === VSMShadowMap ? this.vsmShadowMapHorizontal.texture : depthTexture;
    const shadowNode = this.setupShadowFilter(builder, { filterFn, shadowTexture: shadowMap.texture, depthTexture: shadowDepthTexture, shadowCoord, shadow: shadow3 });
    const shadowColor = texture(shadowMap.texture, shadowCoord);
    const shadowOutput = mix(1, shadowNode.rgb.mix(shadowColor, 1), shadowIntensity.mul(shadowColor.a)).toVar();
    this.shadowMap = shadowMap;
    this.shadow.map = shadowMap;
    return shadowOutput;
  }
  setup(builder) {
    if (builder.renderer.shadowMap.enabled === false) return;
    return Fn(({ material }) => {
      shadowWorldPosition.assign(material.shadowPositionNode || positionWorld);
      let node = this._node;
      if (node === null) {
        this._node = node = this.setupShadow(builder);
      }
      if (builder.material.shadowNode) {
        console.warn('THREE.NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.');
      }
      if (builder.material.receivedShadowNode) {
        node = builder.material.receivedShadowNode(node);
      }
      return node;
    })();
  }
  renderShadow(frame) {
    const { shadow: shadow3, shadowMap } = this;
    const { renderer, scene } = frame;
    shadowMap.setSize(shadow3.mapSize.width, shadow3.mapSize.height);
    renderer.render(scene, shadow3.camera);
  }
  updateShadow(frame) {
    const { shadowMap, light, shadow: shadow3 } = this;
    const { renderer, scene, camera } = frame;
    const shadowType = renderer.shadowMap.type;
    const depthVersion = shadowMap.depthTexture.version;
    this._depthVersionCached = depthVersion;
    const currentOverrideMaterial = scene.overrideMaterial;
    scene.overrideMaterial = getShadowMaterial(light);
    shadow3.camera.layers.mask = camera.layers.mask;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentRenderObjectFunction = renderer.getRenderObjectFunction();
    const currentMRT = renderer.getMRT();
    renderer.setMRT(null);
    renderer.setRenderObjectFunction((object, ...params) => {
      if (object.castShadow === true || object.receiveShadow && shadowType === VSMShadowMap) {
        renderer.renderObject(object, ...params);
      }
    });
    renderer.setRenderTarget(shadowMap);
    this.renderShadow(frame);
    renderer.setRenderObjectFunction(currentRenderObjectFunction);
    if (light.isPointLight !== true && shadowType === VSMShadowMap) {
      this.vsmPass(renderer);
    }
    renderer.setRenderTarget(currentRenderTarget);
    renderer.setMRT(currentMRT);
    scene.overrideMaterial = currentOverrideMaterial;
  }
  vsmPass(renderer) {
    const { shadow: shadow3 } = this;
    this.vsmShadowMapVertical.setSize(shadow3.mapSize.width, shadow3.mapSize.height);
    this.vsmShadowMapHorizontal.setSize(shadow3.mapSize.width, shadow3.mapSize.height);
    renderer.setRenderTarget(this.vsmShadowMapVertical);
    _quadMesh$1.material = this.vsmMaterialVertical;
    _quadMesh$1.render(renderer);
    renderer.setRenderTarget(this.vsmShadowMapHorizontal);
    _quadMesh$1.material = this.vsmMaterialHorizontal;
    _quadMesh$1.render(renderer);
  }
  dispose() {
    this.shadowMap.dispose();
    this.shadowMap = null;
    if (this.vsmShadowMapVertical !== null) {
      this.vsmShadowMapVertical.dispose();
      this.vsmShadowMapVertical = null;
      this.vsmMaterialVertical.dispose();
      this.vsmMaterialVertical = null;
    }
    if (this.vsmShadowMapHorizontal !== null) {
      this.vsmShadowMapHorizontal.dispose();
      this.vsmShadowMapHorizontal = null;
      this.vsmMaterialHorizontal.dispose();
      this.vsmMaterialHorizontal = null;
    }
    this.updateBeforeType = NodeUpdateType.NONE;
  }
  updateBefore(frame) {
    const { shadow: shadow3 } = this;
    const needsUpdate = shadow3.needsUpdate || shadow3.autoUpdate;
    if (needsUpdate) {
      this.updateShadow(frame);
      if (this.shadowMap.depthTexture.version === this._depthVersionCached) {
        shadow3.needsUpdate = false;
      }
    }
  }
};
var shadow = (light, shadow3) => nodeObject(new ShadowNode(light, shadow3));
var getDistanceAttenuation = Fn((inputs) => {
  const { lightDistance, cutoffDistance, decayExponent } = inputs;
  const distanceFalloff = lightDistance.pow(decayExponent).max(0.01).reciprocal();
  return cutoffDistance.greaterThan(0).select(
    distanceFalloff.mul(lightDistance.div(cutoffDistance).pow4().oneMinus().clamp().pow2()),
    distanceFalloff
  );
});
var _clearColor$2 = new Color();
var cubeToUV = Fn(([pos, texelSizeY]) => {
  const v = pos.toVar();
  const absV = abs(v);
  const scaleToCube = div(1, max$1(absV.x, max$1(absV.y, absV.z)));
  absV.mulAssign(scaleToCube);
  v.mulAssign(scaleToCube.mul(texelSizeY.mul(2).oneMinus()));
  const planar = vec2(v.xy).toVar();
  const almostATexel = texelSizeY.mul(1.5);
  const almostOne = almostATexel.oneMinus();
  If(absV.z.greaterThanEqual(almostOne), () => {
    If(v.z.greaterThan(0), () => {
      planar.x.assign(sub(4, v.x));
    });
  }).ElseIf(absV.x.greaterThanEqual(almostOne), () => {
    const signX = sign(v.x);
    planar.x.assign(v.z.mul(signX).add(signX.mul(2)));
  }).ElseIf(absV.y.greaterThanEqual(almostOne), () => {
    const signY = sign(v.y);
    planar.x.assign(v.x.add(signY.mul(2)).add(2));
    planar.y.assign(v.z.mul(signY).sub(2));
  });
  return vec2(0.125, 0.25).mul(planar).add(vec2(0.375, 0.75)).flipY();
}).setLayout({
  name: "cubeToUV",
  type: "vec2",
  inputs: [
    { name: "pos", type: "vec3" },
    { name: "texelSizeY", type: "float" }
  ]
});
var BasicPointShadowFilter = Fn(({ depthTexture, bd3D, dp, texelSize }) => {
  return texture(depthTexture, cubeToUV(bd3D, texelSize.y)).compare(dp);
});
var PointShadowFilter = Fn(({ depthTexture, bd3D, dp, texelSize, shadow: shadow3 }) => {
  const radius = reference("radius", "float", shadow3).setGroup(renderGroup);
  const offset = vec2(-1, 1).mul(radius).mul(texelSize.y);
  return texture(depthTexture, cubeToUV(bd3D.add(offset.xyy), texelSize.y)).compare(dp).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yyy), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.xyx), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yyx), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D, texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.xxy), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yxy), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.xxx), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yxx), texelSize.y)).compare(dp)).mul(1 / 9);
});
var pointShadowFilter = Fn(({ filterFn, depthTexture, shadowCoord, shadow: shadow3 }) => {
  const lightToPosition = shadowCoord.xyz.toVar();
  const lightToPositionLength = lightToPosition.length();
  const cameraNearLocal = uniform("float").setGroup(renderGroup).onRenderUpdate(() => shadow3.camera.near);
  const cameraFarLocal = uniform("float").setGroup(renderGroup).onRenderUpdate(() => shadow3.camera.far);
  const bias = reference("bias", "float", shadow3).setGroup(renderGroup);
  const mapSize = uniform(shadow3.mapSize).setGroup(renderGroup);
  const result = float(1).toVar();
  If(lightToPositionLength.sub(cameraFarLocal).lessThanEqual(0).and(lightToPositionLength.sub(cameraNearLocal).greaterThanEqual(0)), () => {
    const dp = lightToPositionLength.sub(cameraNearLocal).div(cameraFarLocal.sub(cameraNearLocal)).toVar();
    dp.addAssign(bias);
    const bd3D = lightToPosition.normalize();
    const texelSize = vec2(1).div(mapSize.mul(vec2(4, 2)));
    result.assign(filterFn({ depthTexture, bd3D, dp, texelSize, shadow: shadow3 }));
  });
  return result;
});
var _viewport = new Vector4();
var _viewportSize = new Vector2();
var _shadowMapSize = new Vector2();
var directPointLight = Fn(({ color: color3, lightViewPosition: lightViewPosition3, cutoffDistance, decayExponent }, builder) => {
  const lightingModel = builder.context.lightingModel;
  const lVector = lightViewPosition3.sub(positionView);
  const lightDirection = lVector.normalize();
  const lightDistance = lVector.length();
  const lightAttenuation = getDistanceAttenuation({
    lightDistance,
    cutoffDistance,
    decayExponent
  });
  const lightColor = color3.mul(lightAttenuation);
  const reflectedLight = builder.context.reflectedLight;
  lightingModel.direct({
    lightDirection,
    lightColor,
    reflectedLight
  }, builder.stack, builder);
});
var checker = Fn(([coord = uv()]) => {
  const uv3 = coord.mul(2);
  const cx = uv3.x.floor();
  const cy = uv3.y.floor();
  const result = cx.add(cy).mod(2);
  return result.sign();
});
var mx_select = Fn(([b_immutable, t_immutable, f_immutable]) => {
  const f = float(f_immutable).toVar();
  const t = float(t_immutable).toVar();
  const b = bool(b_immutable).toVar();
  return select(b, t, f);
}).setLayout({
  name: "mx_select",
  type: "float",
  inputs: [
    { name: "b", type: "bool" },
    { name: "t", type: "float" },
    { name: "f", type: "float" }
  ]
});
var mx_negate_if = Fn(([val_immutable, b_immutable]) => {
  const b = bool(b_immutable).toVar();
  const val = float(val_immutable).toVar();
  return select(b, val.negate(), val);
}).setLayout({
  name: "mx_negate_if",
  type: "float",
  inputs: [
    { name: "val", type: "float" },
    { name: "b", type: "bool" }
  ]
});
var mx_floor = Fn(([x_immutable]) => {
  const x = float(x_immutable).toVar();
  return int(floor(x));
}).setLayout({
  name: "mx_floor",
  type: "int",
  inputs: [
    { name: "x", type: "float" }
  ]
});
var mx_floorfrac = Fn(([x_immutable, i]) => {
  const x = float(x_immutable).toVar();
  i.assign(mx_floor(x));
  return x.sub(float(i));
});
var mx_bilerp_0 = Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v3 = float(v3_immutable).toVar();
  const v2 = float(v2_immutable).toVar();
  const v1 = float(v1_immutable).toVar();
  const v0 = float(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  return sub(1, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));
}).setLayout({
  name: "mx_bilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" }
  ]
});
var mx_bilerp_1 = Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v3 = vec3(v3_immutable).toVar();
  const v2 = vec3(v2_immutable).toVar();
  const v1 = vec3(v1_immutable).toVar();
  const v0 = vec3(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  return sub(1, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));
}).setLayout({
  name: "mx_bilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" }
  ]
});
var mx_bilerp = overloadingFn([mx_bilerp_0, mx_bilerp_1]);
var mx_trilerp_0 = Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {
  const r = float(r_immutable).toVar();
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v7 = float(v7_immutable).toVar();
  const v6 = float(v6_immutable).toVar();
  const v5 = float(v5_immutable).toVar();
  const v4 = float(v4_immutable).toVar();
  const v3 = float(v3_immutable).toVar();
  const v2 = float(v2_immutable).toVar();
  const v1 = float(v1_immutable).toVar();
  const v0 = float(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  const t1 = float(sub(1, t)).toVar();
  const r1 = float(sub(1, r)).toVar();
  return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));
}).setLayout({
  name: "mx_trilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "v4", type: "float" },
    { name: "v5", type: "float" },
    { name: "v6", type: "float" },
    { name: "v7", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" }
  ]
});
var mx_trilerp_1 = Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {
  const r = float(r_immutable).toVar();
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v7 = vec3(v7_immutable).toVar();
  const v6 = vec3(v6_immutable).toVar();
  const v5 = vec3(v5_immutable).toVar();
  const v4 = vec3(v4_immutable).toVar();
  const v3 = vec3(v3_immutable).toVar();
  const v2 = vec3(v2_immutable).toVar();
  const v1 = vec3(v1_immutable).toVar();
  const v0 = vec3(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  const t1 = float(sub(1, t)).toVar();
  const r1 = float(sub(1, r)).toVar();
  return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));
}).setLayout({
  name: "mx_trilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "v4", type: "vec3" },
    { name: "v5", type: "vec3" },
    { name: "v6", type: "vec3" },
    { name: "v7", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" }
  ]
});
var mx_trilerp = overloadingFn([mx_trilerp_0, mx_trilerp_1]);
var mx_gradient_float_0 = Fn(([hash_immutable, x_immutable, y_immutable]) => {
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash3 = uint(hash_immutable).toVar();
  const h = uint(hash3.bitAnd(uint(7))).toVar();
  const u = float(mx_select(h.lessThan(uint(4)), x, y)).toVar();
  const v = float(mul(2, mx_select(h.lessThan(uint(4)), y, x))).toVar();
  return mx_negate_if(u, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint(2)))));
}).setLayout({
  name: "mx_gradient_float_0",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" }
  ]
});
var mx_gradient_float_1 = Fn(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
  const z = float(z_immutable).toVar();
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash3 = uint(hash_immutable).toVar();
  const h = uint(hash3.bitAnd(uint(15))).toVar();
  const u = float(mx_select(h.lessThan(uint(8)), x, y)).toVar();
  const v = float(mx_select(h.lessThan(uint(4)), y, mx_select(h.equal(uint(12)).or(h.equal(uint(14))), x, z))).toVar();
  return mx_negate_if(u, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint(2)))));
}).setLayout({
  name: "mx_gradient_float_1",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" }
  ]
});
var mx_gradient_float = overloadingFn([mx_gradient_float_0, mx_gradient_float_1]);
var mx_gradient_vec3_0 = Fn(([hash_immutable, x_immutable, y_immutable]) => {
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash3 = uvec3(hash_immutable).toVar();
  return vec3(mx_gradient_float(hash3.x, x, y), mx_gradient_float(hash3.y, x, y), mx_gradient_float(hash3.z, x, y));
}).setLayout({
  name: "mx_gradient_vec3_0",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" }
  ]
});
var mx_gradient_vec3_1 = Fn(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
  const z = float(z_immutable).toVar();
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash3 = uvec3(hash_immutable).toVar();
  return vec3(mx_gradient_float(hash3.x, x, y, z), mx_gradient_float(hash3.y, x, y, z), mx_gradient_float(hash3.z, x, y, z));
}).setLayout({
  name: "mx_gradient_vec3_1",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" }
  ]
});
var mx_gradient_vec3 = overloadingFn([mx_gradient_vec3_0, mx_gradient_vec3_1]);
var mx_gradient_scale2d_0 = Fn(([v_immutable]) => {
  const v = float(v_immutable).toVar();
  return mul(0.6616, v);
}).setLayout({
  name: "mx_gradient_scale2d_0",
  type: "float",
  inputs: [
    { name: "v", type: "float" }
  ]
});
var mx_gradient_scale3d_0 = Fn(([v_immutable]) => {
  const v = float(v_immutable).toVar();
  return mul(0.982, v);
}).setLayout({
  name: "mx_gradient_scale3d_0",
  type: "float",
  inputs: [
    { name: "v", type: "float" }
  ]
});
var mx_gradient_scale2d_1 = Fn(([v_immutable]) => {
  const v = vec3(v_immutable).toVar();
  return mul(0.6616, v);
}).setLayout({
  name: "mx_gradient_scale2d_1",
  type: "vec3",
  inputs: [
    { name: "v", type: "vec3" }
  ]
});
var mx_gradient_scale2d = overloadingFn([mx_gradient_scale2d_0, mx_gradient_scale2d_1]);
var mx_gradient_scale3d_1 = Fn(([v_immutable]) => {
  const v = vec3(v_immutable).toVar();
  return mul(0.982, v);
}).setLayout({
  name: "mx_gradient_scale3d_1",
  type: "vec3",
  inputs: [
    { name: "v", type: "vec3" }
  ]
});
var mx_gradient_scale3d = overloadingFn([mx_gradient_scale3d_0, mx_gradient_scale3d_1]);
var mx_rotl32 = Fn(([x_immutable, k_immutable]) => {
  const k = int(k_immutable).toVar();
  const x = uint(x_immutable).toVar();
  return x.shiftLeft(k).bitOr(x.shiftRight(int(32).sub(k)));
}).setLayout({
  name: "mx_rotl32",
  type: "uint",
  inputs: [
    { name: "x", type: "uint" },
    { name: "k", type: "int" }
  ]
});
var mx_bjmix = Fn(([a, b, c]) => {
  a.subAssign(c);
  a.bitXorAssign(mx_rotl32(c, int(4)));
  c.addAssign(b);
  b.subAssign(a);
  b.bitXorAssign(mx_rotl32(a, int(6)));
  a.addAssign(c);
  c.subAssign(b);
  c.bitXorAssign(mx_rotl32(b, int(8)));
  b.addAssign(a);
  a.subAssign(c);
  a.bitXorAssign(mx_rotl32(c, int(16)));
  c.addAssign(b);
  b.subAssign(a);
  b.bitXorAssign(mx_rotl32(a, int(19)));
  a.addAssign(c);
  c.subAssign(b);
  c.bitXorAssign(mx_rotl32(b, int(4)));
  b.addAssign(a);
});
var mx_bjfinal = Fn(([a_immutable, b_immutable, c_immutable]) => {
  const c = uint(c_immutable).toVar();
  const b = uint(b_immutable).toVar();
  const a = uint(a_immutable).toVar();
  c.bitXorAssign(b);
  c.subAssign(mx_rotl32(b, int(14)));
  a.bitXorAssign(c);
  a.subAssign(mx_rotl32(c, int(11)));
  b.bitXorAssign(a);
  b.subAssign(mx_rotl32(a, int(25)));
  c.bitXorAssign(b);
  c.subAssign(mx_rotl32(b, int(16)));
  a.bitXorAssign(c);
  a.subAssign(mx_rotl32(c, int(4)));
  b.bitXorAssign(a);
  b.subAssign(mx_rotl32(a, int(14)));
  c.bitXorAssign(b);
  c.subAssign(mx_rotl32(b, int(24)));
  return c;
}).setLayout({
  name: "mx_bjfinal",
  type: "uint",
  inputs: [
    { name: "a", type: "uint" },
    { name: "b", type: "uint" },
    { name: "c", type: "uint" }
  ]
});
var mx_bits_to_01 = Fn(([bits_immutable]) => {
  const bits = uint(bits_immutable).toVar();
  return float(bits).div(float(uint(int(4294967295))));
}).setLayout({
  name: "mx_bits_to_01",
  type: "float",
  inputs: [
    { name: "bits", type: "uint" }
  ]
});
var mx_fade = Fn(([t_immutable]) => {
  const t = float(t_immutable).toVar();
  return t.mul(t).mul(t).mul(t.mul(t.mul(6).sub(15)).add(10));
}).setLayout({
  name: "mx_fade",
  type: "float",
  inputs: [
    { name: "t", type: "float" }
  ]
});
var mx_hash_int_0 = Fn(([x_immutable]) => {
  const x = int(x_immutable).toVar();
  const len = uint(uint(1)).toVar();
  const seed = uint(uint(int(3735928559)).add(len.shiftLeft(uint(2))).add(uint(13))).toVar();
  return mx_bjfinal(seed.add(uint(x)), seed, seed);
}).setLayout({
  name: "mx_hash_int_0",
  type: "uint",
  inputs: [
    { name: "x", type: "int" }
  ]
});
var mx_hash_int_1 = Fn(([x_immutable, y_immutable]) => {
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(2)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
  a.assign(b.assign(c.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2))).add(uint(13)))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  return mx_bjfinal(a, b, c);
}).setLayout({
  name: "mx_hash_int_1",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" }
  ]
});
var mx_hash_int_2 = Fn(([x_immutable, y_immutable, z_immutable]) => {
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(3)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
  a.assign(b.assign(c.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2))).add(uint(13)))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  c.addAssign(uint(z));
  return mx_bjfinal(a, b, c);
}).setLayout({
  name: "mx_hash_int_2",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" }
  ]
});
var mx_hash_int_3 = Fn(([x_immutable, y_immutable, z_immutable, xx_immutable]) => {
  const xx = int(xx_immutable).toVar();
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(4)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
  a.assign(b.assign(c.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2))).add(uint(13)))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  c.addAssign(uint(z));
  mx_bjmix(a, b, c);
  a.addAssign(uint(xx));
  return mx_bjfinal(a, b, c);
}).setLayout({
  name: "mx_hash_int_3",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" }
  ]
});
var mx_hash_int_4 = Fn(([x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable]) => {
  const yy = int(yy_immutable).toVar();
  const xx = int(xx_immutable).toVar();
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(5)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
  a.assign(b.assign(c.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2))).add(uint(13)))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  c.addAssign(uint(z));
  mx_bjmix(a, b, c);
  a.addAssign(uint(xx));
  b.addAssign(uint(yy));
  return mx_bjfinal(a, b, c);
}).setLayout({
  name: "mx_hash_int_4",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" },
    { name: "yy", type: "int" }
  ]
});
var mx_hash_int = overloadingFn([mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4]);
var mx_hash_vec3_0 = Fn(([x_immutable, y_immutable]) => {
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const h = uint(mx_hash_int(x, y)).toVar();
  const result = uvec3().toVar();
  result.x.assign(h.bitAnd(int(255)));
  result.y.assign(h.shiftRight(int(8)).bitAnd(int(255)));
  result.z.assign(h.shiftRight(int(16)).bitAnd(int(255)));
  return result;
}).setLayout({
  name: "mx_hash_vec3_0",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" }
  ]
});
var mx_hash_vec3_1 = Fn(([x_immutable, y_immutable, z_immutable]) => {
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const h = uint(mx_hash_int(x, y, z)).toVar();
  const result = uvec3().toVar();
  result.x.assign(h.bitAnd(int(255)));
  result.y.assign(h.shiftRight(int(8)).bitAnd(int(255)));
  result.z.assign(h.shiftRight(int(16)).bitAnd(int(255)));
  return result;
}).setLayout({
  name: "mx_hash_vec3_1",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" }
  ]
});
var mx_hash_vec3 = overloadingFn([mx_hash_vec3_0, mx_hash_vec3_1]);
var mx_perlin_noise_float_0 = Fn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const u = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const result = float(mx_bilerp(mx_gradient_float(mx_hash_int(X, Y), fx, fy), mx_gradient_float(mx_hash_int(X.add(int(1)), Y), fx.sub(1), fy), mx_gradient_float(mx_hash_int(X, Y.add(int(1))), fx, fy.sub(1)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1))), fx.sub(1), fy.sub(1)), u, v)).toVar();
  return mx_gradient_scale2d(result);
}).setLayout({
  name: "mx_perlin_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
var mx_perlin_noise_float_1 = Fn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const fz = float(mx_floorfrac(p.z, Z)).toVar();
  const u = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const w = float(mx_fade(fz)).toVar();
  const result = float(mx_trilerp(mx_gradient_float(mx_hash_int(X, Y, Z), fx, fy, fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z), fx.sub(1), fy, fz), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z), fx, fy.sub(1), fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1), fy.sub(1), fz), mx_gradient_float(mx_hash_int(X, Y, Z.add(int(1))), fx, fy, fz.sub(1)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1), fy, fz.sub(1)), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1), fz.sub(1)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1), fy.sub(1), fz.sub(1)), u, v, w)).toVar();
  return mx_gradient_scale3d(result);
}).setLayout({
  name: "mx_perlin_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
var mx_perlin_noise_float = overloadingFn([mx_perlin_noise_float_0, mx_perlin_noise_float_1]);
var mx_perlin_noise_vec3_0 = Fn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const u = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const result = vec3(mx_bilerp(mx_gradient_vec3(mx_hash_vec3(X, Y), fx, fy), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y), fx.sub(1), fy), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1))), fx, fy.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1))), fx.sub(1), fy.sub(1)), u, v)).toVar();
  return mx_gradient_scale2d(result);
}).setLayout({
  name: "mx_perlin_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
var mx_perlin_noise_vec3_1 = Fn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const fz = float(mx_floorfrac(p.z, Z)).toVar();
  const u = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const w = float(mx_fade(fz)).toVar();
  const result = vec3(mx_trilerp(mx_gradient_vec3(mx_hash_vec3(X, Y, Z), fx, fy, fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z), fx.sub(1), fy, fz), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z), fx, fy.sub(1), fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1), fy.sub(1), fz), mx_gradient_vec3(mx_hash_vec3(X, Y, Z.add(int(1))), fx, fy, fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1), fy, fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1), fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1), fy.sub(1), fz.sub(1)), u, v, w)).toVar();
  return mx_gradient_scale3d(result);
}).setLayout({
  name: "mx_perlin_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
var mx_perlin_noise_vec3 = overloadingFn([mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1]);
var mx_cell_noise_float_0 = Fn(([p_immutable]) => {
  const p = float(p_immutable).toVar();
  const ix = int(mx_floor(p)).toVar();
  return mx_bits_to_01(mx_hash_int(ix));
}).setLayout({
  name: "mx_cell_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "float" }
  ]
});
var mx_cell_noise_float_1 = Fn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy));
}).setLayout({
  name: "mx_cell_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
var mx_cell_noise_float_2 = Fn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy, iz));
}).setLayout({
  name: "mx_cell_noise_float_2",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
var mx_cell_noise_float_3 = Fn(([p_immutable]) => {
  const p = vec4(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  const iw = int(mx_floor(p.w)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
}).setLayout({
  name: "mx_cell_noise_float_3",
  type: "float",
  inputs: [
    { name: "p", type: "vec4" }
  ]
});
var mx_cell_noise_float$1 = overloadingFn([mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3]);
var mx_cell_noise_vec3_0 = Fn(([p_immutable]) => {
  const p = float(p_immutable).toVar();
  const ix = int(mx_floor(p)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, int(0))), mx_bits_to_01(mx_hash_int(ix, int(1))), mx_bits_to_01(mx_hash_int(ix, int(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "float" }
  ]
});
var mx_cell_noise_vec3_1 = Fn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, int(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
var mx_cell_noise_vec3_2 = Fn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_2",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
var mx_cell_noise_vec3_3 = Fn(([p_immutable]) => {
  const p = vec4(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  const iw = int(mx_floor(p.w)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec4" }
  ]
});
var mx_cell_noise_vec3 = overloadingFn([mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3]);
var mx_fractal_noise_float$1 = Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const result = float(0).toVar();
  const amplitude = float(1).toVar();
  Loop(octaves, () => {
    result.addAssign(amplitude.mul(mx_perlin_noise_float(p)));
    amplitude.mulAssign(diminish);
    p.mulAssign(lacunarity);
  });
  return result;
}).setLayout({
  name: "mx_fractal_noise_float",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
var mx_fractal_noise_vec3$1 = Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const result = vec3(0).toVar();
  const amplitude = float(1).toVar();
  Loop(octaves, () => {
    result.addAssign(amplitude.mul(mx_perlin_noise_vec3(p)));
    amplitude.mulAssign(diminish);
    p.mulAssign(lacunarity);
  });
  return result;
}).setLayout({
  name: "mx_fractal_noise_vec3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
var mx_fractal_noise_vec2$1 = Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  return vec2(mx_fractal_noise_float$1(p, octaves, lacunarity, diminish), mx_fractal_noise_float$1(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish));
}).setLayout({
  name: "mx_fractal_noise_vec2",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
var mx_fractal_noise_vec4$1 = Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const c = vec3(mx_fractal_noise_vec3$1(p, octaves, lacunarity, diminish)).toVar();
  const f = float(mx_fractal_noise_float$1(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish)).toVar();
  return vec4(c, f);
}).setLayout({
  name: "mx_fractal_noise_vec4",
  type: "vec4",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
var mx_worley_distance_0 = Fn(([p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const yoff = int(yoff_immutable).toVar();
  const xoff = int(xoff_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const tmp = vec3(mx_cell_noise_vec3(vec2(x.add(xoff), y.add(yoff)))).toVar();
  const off = vec2(tmp.x, tmp.y).toVar();
  off.subAssign(0.5);
  off.mulAssign(jitter);
  off.addAssign(0.5);
  const cellpos = vec2(vec2(float(x), float(y)).add(off)).toVar();
  const diff = vec2(cellpos.sub(p)).toVar();
  If(metric.equal(int(2)), () => {
    return abs(diff.x).add(abs(diff.y));
  });
  If(metric.equal(int(3)), () => {
    return max$1(abs(diff.x), abs(diff.y));
  });
  return dot(diff, diff);
}).setLayout({
  name: "mx_worley_distance_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_distance_1 = Fn(([p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const zoff = int(zoff_immutable).toVar();
  const yoff = int(yoff_immutable).toVar();
  const xoff = int(xoff_immutable).toVar();
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const off = vec3(mx_cell_noise_vec3(vec3(x.add(xoff), y.add(yoff), z.add(zoff)))).toVar();
  off.subAssign(0.5);
  off.mulAssign(jitter);
  off.addAssign(0.5);
  const cellpos = vec3(vec3(float(x), float(y), float(z)).add(off)).toVar();
  const diff = vec3(cellpos.sub(p)).toVar();
  If(metric.equal(int(2)), () => {
    return abs(diff.x).add(abs(diff.y)).add(abs(diff.z));
  });
  If(metric.equal(int(3)), () => {
    return max$1(max$1(abs(diff.x), abs(diff.y)), abs(diff.z));
  });
  return dot(diff, diff);
}).setLayout({
  name: "mx_worley_distance_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "zoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_distance = overloadingFn([mx_worley_distance_0, mx_worley_distance_1]);
var mx_worley_noise_float_0 = Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
  const sqdist = float(1e6).toVar();
  Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
      sqdist.assign(min$1(sqdist, dist));
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_noise_vec2_0 = Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
  const sqdist = vec2(1e6, 1e6).toVar();
  Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
      If(dist.lessThan(sqdist.x), () => {
        sqdist.y.assign(sqdist.x);
        sqdist.x.assign(dist);
      }).ElseIf(dist.lessThan(sqdist.y), () => {
        sqdist.y.assign(dist);
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_vec2_0",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_noise_vec3_0 = Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
  const sqdist = vec3(1e6, 1e6, 1e6).toVar();
  Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
      If(dist.lessThan(sqdist.x), () => {
        sqdist.z.assign(sqdist.y);
        sqdist.y.assign(sqdist.x);
        sqdist.x.assign(dist);
      }).ElseIf(dist.lessThan(sqdist.y), () => {
        sqdist.z.assign(sqdist.y);
        sqdist.y.assign(dist);
      }).ElseIf(dist.lessThan(sqdist.z), () => {
        sqdist.z.assign(dist);
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_noise_float_1 = Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
  const sqdist = float(1e6).toVar();
  Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      Loop({ start: -1, end: int(1), name: "z", condition: "<=" }, ({ z }) => {
        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
        sqdist.assign(min$1(sqdist, dist));
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_noise_float$1 = overloadingFn([mx_worley_noise_float_0, mx_worley_noise_float_1]);
var mx_worley_noise_vec2_1 = Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
  const sqdist = vec2(1e6, 1e6).toVar();
  Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      Loop({ start: -1, end: int(1), name: "z", condition: "<=" }, ({ z }) => {
        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
        If(dist.lessThan(sqdist.x), () => {
          sqdist.y.assign(sqdist.x);
          sqdist.x.assign(dist);
        }).ElseIf(dist.lessThan(sqdist.y), () => {
          sqdist.y.assign(dist);
        });
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_vec2_1",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_noise_vec2$1 = overloadingFn([mx_worley_noise_vec2_0, mx_worley_noise_vec2_1]);
var mx_worley_noise_vec3_1 = Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
  const sqdist = vec3(1e6, 1e6, 1e6).toVar();
  Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      Loop({ start: -1, end: int(1), name: "z", condition: "<=" }, ({ z }) => {
        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
        If(dist.lessThan(sqdist.x), () => {
          sqdist.z.assign(sqdist.y);
          sqdist.y.assign(sqdist.x);
          sqdist.x.assign(dist);
        }).ElseIf(dist.lessThan(sqdist.y), () => {
          sqdist.z.assign(sqdist.y);
          sqdist.y.assign(dist);
        }).ElseIf(dist.lessThan(sqdist.z), () => {
          sqdist.z.assign(dist);
        });
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_noise_vec3$1 = overloadingFn([mx_worley_noise_vec3_0, mx_worley_noise_vec3_1]);
var mx_hsvtorgb = Fn(([hsv]) => {
  const s = hsv.y;
  const v = hsv.z;
  const result = vec3().toVar();
  If(s.lessThan(1e-4), () => {
    result.assign(vec3(v, v, v));
  }).Else(() => {
    let h = hsv.x;
    h = h.sub(floor(h)).mul(6).toVar();
    const hi = int(trunc(h));
    const f = h.sub(float(hi));
    const p = v.mul(s.oneMinus());
    const q = v.mul(s.mul(f).oneMinus());
    const t = v.mul(s.mul(f.oneMinus()).oneMinus());
    If(hi.equal(int(0)), () => {
      result.assign(vec3(v, t, p));
    }).ElseIf(hi.equal(int(1)), () => {
      result.assign(vec3(q, v, p));
    }).ElseIf(hi.equal(int(2)), () => {
      result.assign(vec3(p, v, t));
    }).ElseIf(hi.equal(int(3)), () => {
      result.assign(vec3(p, q, v));
    }).ElseIf(hi.equal(int(4)), () => {
      result.assign(vec3(t, p, v));
    }).Else(() => {
      result.assign(vec3(v, p, q));
    });
  });
  return result;
}).setLayout({
  name: "mx_hsvtorgb",
  type: "vec3",
  inputs: [
    { name: "hsv", type: "vec3" }
  ]
});
var mx_rgbtohsv = Fn(([c_immutable]) => {
  const c = vec3(c_immutable).toVar();
  const r = float(c.x).toVar();
  const g = float(c.y).toVar();
  const b = float(c.z).toVar();
  const mincomp = float(min$1(r, min$1(g, b))).toVar();
  const maxcomp = float(max$1(r, max$1(g, b))).toVar();
  const delta = float(maxcomp.sub(mincomp)).toVar();
  const h = float().toVar(), s = float().toVar(), v = float().toVar();
  v.assign(maxcomp);
  If(maxcomp.greaterThan(0), () => {
    s.assign(delta.div(maxcomp));
  }).Else(() => {
    s.assign(0);
  });
  If(s.lessThanEqual(0), () => {
    h.assign(0);
  }).Else(() => {
    If(r.greaterThanEqual(maxcomp), () => {
      h.assign(g.sub(b).div(delta));
    }).ElseIf(g.greaterThanEqual(maxcomp), () => {
      h.assign(add(2, b.sub(r).div(delta)));
    }).Else(() => {
      h.assign(add(4, r.sub(g).div(delta)));
    });
    h.mulAssign(1 / 6);
    If(h.lessThan(0), () => {
      h.addAssign(1);
    });
  });
  return vec3(h, s, v);
}).setLayout({
  name: "mx_rgbtohsv",
  type: "vec3",
  inputs: [
    { name: "c", type: "vec3" }
  ]
});
var mx_srgb_texture_to_lin_rec709 = Fn(([color_immutable]) => {
  const color3 = vec3(color_immutable).toVar();
  const isAbove = bvec3(greaterThan(color3, vec3(0.04045))).toVar();
  const linSeg = vec3(color3.div(12.92)).toVar();
  const powSeg = vec3(pow(max$1(color3.add(vec3(0.055)), vec3(0)).div(1.055), vec3(2.4))).toVar();
  return mix(linSeg, powSeg, isAbove);
}).setLayout({
  name: "mx_srgb_texture_to_lin_rec709",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
});
var mx_aastep = (threshold3, value) => {
  threshold3 = float(threshold3);
  value = float(value);
  const afwidth = vec2(value.dFdx(), value.dFdy()).length().mul(0.7071067811865476);
  return smoothstep(threshold3.sub(afwidth), threshold3.add(afwidth), value);
};
var _ramp = (a, b, uv3, p) => mix(a, b, uv3[p].clamp());
var mx_ramplr = (valuel, valuer, texcoord = uv()) => _ramp(valuel, valuer, texcoord, "x");
var mx_ramptb = (valuet, valueb, texcoord = uv()) => _ramp(valuet, valueb, texcoord, "y");
var _split = (a, b, center, uv3, p) => mix(a, b, mx_aastep(center, uv3[p]));
var mx_splitlr = (valuel, valuer, center, texcoord = uv()) => _split(valuel, valuer, center, texcoord, "x");
var mx_splittb = (valuet, valueb, center, texcoord = uv()) => _split(valuet, valueb, center, texcoord, "y");
var mx_transform_uv = (uv_scale = 1, uv_offset = 0, uv_geo = uv()) => uv_geo.mul(uv_scale).add(uv_offset);
var mx_safepower = (in1, in2 = 1) => {
  in1 = float(in1);
  return in1.abs().pow(in2).mul(in1.sign());
};
var mx_contrast = (input, amount = 1, pivot = 0.5) => float(input).sub(pivot).mul(amount).add(pivot);
var mx_noise_float = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_float(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
var mx_noise_vec3 = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_vec3(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
var mx_noise_vec4 = (texcoord = uv(), amplitude = 1, pivot = 0) => {
  texcoord = texcoord.convert("vec2|vec3");
  const noise_vec4 = vec4(mx_perlin_noise_vec3(texcoord), mx_perlin_noise_float(texcoord.add(vec2(19, 73))));
  return noise_vec4.mul(amplitude).add(pivot);
};
var mx_worley_noise_float = (texcoord = uv(), jitter = 1) => mx_worley_noise_float$1(texcoord.convert("vec2|vec3"), jitter, int(1));
var mx_worley_noise_vec2 = (texcoord = uv(), jitter = 1) => mx_worley_noise_vec2$1(texcoord.convert("vec2|vec3"), jitter, int(1));
var mx_worley_noise_vec3 = (texcoord = uv(), jitter = 1) => mx_worley_noise_vec3$1(texcoord.convert("vec2|vec3"), jitter, int(1));
var mx_cell_noise_float = (texcoord = uv()) => mx_cell_noise_float$1(texcoord.convert("vec2|vec3"));
var mx_fractal_noise_float = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_float$1(position, int(octaves), lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec2 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec2$1(position, int(octaves), lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec3 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec3$1(position, int(octaves), lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec4 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec4$1(position, int(octaves), lacunarity, diminish).mul(amplitude);
var getParallaxCorrectNormal = Fn(([normal2, cubeSize, cubePos]) => {
  const nDir = normalize(normal2).toVar("nDir");
  const rbmax = sub(float(0.5).mul(cubeSize.sub(cubePos)), positionWorld).div(nDir).toVar("rbmax");
  const rbmin = sub(float(-0.5).mul(cubeSize.sub(cubePos)), positionWorld).div(nDir).toVar("rbmin");
  const rbminmax = vec3().toVar("rbminmax");
  rbminmax.x = nDir.x.greaterThan(float(0)).select(rbmax.x, rbmin.x);
  rbminmax.y = nDir.y.greaterThan(float(0)).select(rbmax.y, rbmin.y);
  rbminmax.z = nDir.z.greaterThan(float(0)).select(rbmax.z, rbmin.z);
  const correction = min$1(min$1(rbminmax.x, rbminmax.y), rbminmax.z).toVar("correction");
  const boxIntersection = positionWorld.add(nDir.mul(correction)).toVar("boxIntersection");
  return boxIntersection.sub(cubePos);
});
var getShIrradianceAt = Fn(([normal2, shCoefficients]) => {
  const x = normal2.x, y = normal2.y, z = normal2.z;
  let result = shCoefficients.element(0).mul(0.886227);
  result = result.add(shCoefficients.element(1).mul(2 * 0.511664).mul(y));
  result = result.add(shCoefficients.element(2).mul(2 * 0.511664).mul(z));
  result = result.add(shCoefficients.element(3).mul(2 * 0.511664).mul(x));
  result = result.add(shCoefficients.element(4).mul(2 * 0.429043).mul(x).mul(y));
  result = result.add(shCoefficients.element(5).mul(2 * 0.429043).mul(y).mul(z));
  result = result.add(shCoefficients.element(6).mul(z.mul(z).mul(0.743125).sub(0.247708)));
  result = result.add(shCoefficients.element(7).mul(2 * 0.429043).mul(x).mul(z));
  result = result.add(shCoefficients.element(8).mul(0.429043).mul(mul(x, x).sub(mul(y, y))));
  return result;
});
var TSL = Object.freeze({
  __proto__: null,
  BRDF_GGX,
  BRDF_Lambert,
  BasicShadowFilter,
  Break,
  Continue,
  DFGApprox,
  D_GGX,
  Discard,
  EPSILON,
  F_Schlick,
  Fn,
  INFINITY,
  If,
  Loop,
  NodeAccess,
  NodeShaderStage,
  NodeType,
  NodeUpdateType,
  PCFShadowFilter,
  PCFSoftShadowFilter,
  PI,
  PI2,
  Return,
  Schlick_to_F0,
  ScriptableNodeResources,
  ShaderNode,
  TBNViewMatrix,
  VSMShadowFilter,
  V_GGX_SmithCorrelated,
  abs,
  acesFilmicToneMapping,
  acos,
  add,
  addMethodChaining,
  addNodeElement,
  agxToneMapping,
  all,
  alphaT,
  and,
  anisotropy,
  anisotropyB,
  anisotropyT,
  any,
  append,
  arrayBuffer,
  asin,
  assign,
  atan,
  atan2,
  atomicAdd,
  atomicAnd,
  atomicFunc,
  atomicMax,
  atomicMin,
  atomicOr,
  atomicStore,
  atomicSub,
  atomicXor,
  attenuationColor,
  attenuationDistance,
  attribute,
  attributeArray,
  backgroundBlurriness,
  backgroundIntensity,
  backgroundRotation,
  batch,
  billboarding,
  bitAnd,
  bitNot,
  bitOr,
  bitXor,
  bitangentGeometry,
  bitangentLocal,
  bitangentView,
  bitangentWorld,
  bitcast,
  blendBurn,
  blendColor,
  blendDodge,
  blendOverlay,
  blendScreen,
  blur,
  bool,
  buffer,
  bufferAttribute,
  bumpMap,
  burn,
  bvec2,
  bvec3,
  bvec4,
  bypass,
  cache,
  call,
  cameraFar,
  cameraNear,
  cameraNormalMatrix,
  cameraPosition,
  cameraProjectionMatrix,
  cameraProjectionMatrixInverse,
  cameraViewMatrix,
  cameraWorldMatrix,
  cbrt,
  cdl,
  ceil,
  checker,
  cineonToneMapping,
  clamp,
  clearcoat,
  clearcoatRoughness,
  code,
  color,
  colorSpaceToWorking,
  colorToDirection,
  compute,
  cond,
  context,
  convert,
  convertColorSpace,
  convertToTexture,
  cos,
  cross,
  cubeTexture,
  dFdx,
  dFdy,
  dashSize,
  defaultBuildStages,
  defaultShaderStages,
  defined,
  degrees,
  deltaTime,
  densityFog,
  depth,
  depthPass,
  difference,
  diffuseColor,
  directPointLight,
  directionToColor,
  dispersion,
  distance,
  div,
  dodge,
  dot,
  drawIndex,
  dynamicBufferAttribute,
  element,
  emissive,
  equal,
  equals,
  equirectUV,
  exp,
  exp2,
  expression,
  faceDirection,
  faceForward,
  float,
  floor,
  fog,
  fract,
  frameGroup,
  frameId,
  frontFacing,
  fwidth,
  gain,
  gapSize,
  getConstNodeType,
  getCurrentStack,
  getDirection,
  getDistanceAttenuation,
  getGeometryRoughness,
  getNormalFromDepth,
  getParallaxCorrectNormal,
  getRoughness,
  getScreenPosition,
  getShIrradianceAt,
  getTextureIndex,
  getViewPosition,
  glsl,
  glslFn,
  grayscale,
  greaterThan,
  greaterThanEqual,
  hash,
  highPrecisionModelNormalViewMatrix,
  highPrecisionModelViewMatrix,
  hue,
  instance,
  instanceIndex,
  instancedArray,
  instancedBufferAttribute,
  instancedDynamicBufferAttribute,
  instancedMesh,
  int,
  inverseSqrt,
  invocationLocalIndex,
  invocationSubgroupIndex,
  ior,
  iridescence,
  iridescenceIOR,
  iridescenceThickness,
  ivec2,
  ivec3,
  ivec4,
  js,
  label,
  length,
  lengthSq,
  lessThan,
  lessThanEqual,
  lightPosition,
  lightProjectionUV,
  lightShadowMatrix,
  lightTargetDirection,
  lightTargetPosition,
  lightViewPosition,
  lightingContext,
  lights,
  linearDepth,
  linearToneMapping,
  localId,
  log,
  log2,
  logarithmicDepthToViewZ,
  loop,
  luminance,
  mat2,
  mat3,
  mat4,
  matcapUV,
  materialAOMap,
  materialAlphaTest,
  materialAnisotropy,
  materialAnisotropyVector,
  materialAttenuationColor,
  materialAttenuationDistance,
  materialClearcoat,
  materialClearcoatNormal,
  materialClearcoatRoughness,
  materialColor,
  materialDispersion,
  materialEmissive,
  materialIOR,
  materialIridescence,
  materialIridescenceIOR,
  materialIridescenceThickness,
  materialLightMap,
  materialLineDashOffset,
  materialLineDashSize,
  materialLineGapSize,
  materialLineScale,
  materialLineWidth,
  materialMetalness,
  materialNormal,
  materialOpacity,
  materialPointWidth,
  materialReference,
  materialReflectivity,
  materialRefractionRatio,
  materialRotation,
  materialRoughness,
  materialSheen,
  materialSheenRoughness,
  materialShininess,
  materialSpecular,
  materialSpecularColor,
  materialSpecularIntensity,
  materialSpecularStrength,
  materialThickness,
  materialTransmission,
  max: max$1,
  maxMipLevel,
  metalness,
  min: min$1,
  mix,
  mixElement,
  mod,
  modInt,
  modelDirection,
  modelNormalMatrix,
  modelPosition,
  modelScale,
  modelViewMatrix,
  modelViewPosition,
  modelViewProjection,
  modelWorldMatrix,
  modelWorldMatrixInverse,
  morphReference,
  mrt,
  mul,
  mx_aastep,
  mx_cell_noise_float,
  mx_contrast,
  mx_fractal_noise_float,
  mx_fractal_noise_vec2,
  mx_fractal_noise_vec3,
  mx_fractal_noise_vec4,
  mx_hsvtorgb,
  mx_noise_float,
  mx_noise_vec3,
  mx_noise_vec4,
  mx_ramplr,
  mx_ramptb,
  mx_rgbtohsv,
  mx_safepower,
  mx_splitlr,
  mx_splittb,
  mx_srgb_texture_to_lin_rec709,
  mx_transform_uv,
  mx_worley_noise_float,
  mx_worley_noise_vec2,
  mx_worley_noise_vec3,
  negate,
  neutralToneMapping,
  nodeArray,
  nodeImmutable,
  nodeObject,
  nodeObjects,
  nodeProxy,
  normalFlat,
  normalGeometry,
  normalLocal,
  normalMap,
  normalView,
  normalWorld,
  normalize,
  not,
  notEqual,
  numWorkgroups,
  objectDirection,
  objectGroup,
  objectPosition,
  objectScale,
  objectViewPosition,
  objectWorldMatrix,
  oneMinus,
  or,
  orthographicDepthToViewZ,
  oscSawtooth,
  oscSine,
  oscSquare,
  oscTriangle,
  output,
  outputStruct,
  overlay,
  overloadingFn,
  parabola,
  parallaxDirection,
  parallaxUV,
  parameter,
  pass,
  passTexture,
  pcurve,
  perspectiveDepthToViewZ,
  pmremTexture,
  pointUV,
  pointWidth,
  positionGeometry,
  positionLocal,
  positionPrevious,
  positionView,
  positionViewDirection,
  positionWorld,
  positionWorldDirection,
  posterize,
  pow,
  pow2,
  pow3,
  pow4,
  property,
  radians,
  rand,
  range,
  rangeFog,
  reciprocal,
  reference,
  referenceBuffer,
  reflect,
  reflectVector,
  reflectView,
  reflector,
  refract,
  refractVector,
  refractView,
  reinhardToneMapping,
  remainder,
  remap,
  remapClamp,
  renderGroup,
  renderOutput,
  rendererReference,
  rotate,
  rotateUV,
  roughness,
  round,
  rtt,
  sRGBTransferEOTF,
  sRGBTransferOETF,
  sampler,
  saturate,
  saturation,
  screen,
  screenCoordinate,
  screenSize,
  screenUV,
  scriptable,
  scriptableValue,
  select,
  setCurrentStack,
  shaderStages,
  shadow,
  sharedUniformGroup,
  sheen,
  sheenRoughness,
  shiftLeft,
  shiftRight,
  shininess,
  sign,
  sin,
  sinc,
  skinning,
  skinningReference,
  smoothstep,
  smoothstepElement,
  specularColor,
  specularF90,
  spherizeUV,
  split,
  spritesheetUV,
  sqrt,
  stack,
  step,
  storage,
  storageBarrier,
  storageObject,
  storageTexture,
  string,
  sub,
  subgroupIndex,
  subgroupSize,
  tan,
  tangentGeometry,
  tangentLocal,
  tangentView,
  tangentWorld,
  temp,
  texture,
  texture3D,
  textureBarrier,
  textureBicubic,
  textureCubeUV,
  textureLoad,
  textureSize,
  textureStore,
  thickness,
  threshold,
  time,
  timerDelta,
  timerGlobal,
  timerLocal,
  toOutputColorSpace,
  toWorkingColorSpace,
  toneMapping,
  toneMappingExposure,
  toonOutlinePass,
  transformDirection,
  transformNormal,
  transformNormalToView,
  transformedBentNormalView,
  transformedBitangentView,
  transformedBitangentWorld,
  transformedClearcoatNormalView,
  transformedNormalView,
  transformedNormalWorld,
  transformedTangentView,
  transformedTangentWorld,
  transmission,
  transpose,
  tri,
  tri3,
  triNoise3D,
  triplanarTexture,
  triplanarTextures,
  trunc,
  tslFn,
  uint,
  uniform,
  uniformArray,
  uniformGroup,
  uniforms,
  userData,
  uv,
  uvec2,
  uvec3,
  uvec4,
  varying,
  varyingProperty,
  vec2,
  vec3,
  vec4,
  vectorComponents,
  velocity,
  vertexColor,
  vertexIndex,
  vibrance,
  viewZToLogarithmicDepth,
  viewZToOrthographicDepth,
  viewZToPerspectiveDepth,
  viewport,
  viewportBottomLeft,
  viewportCoordinate,
  viewportDepthTexture,
  viewportLinearDepth,
  viewportMipTexture,
  viewportResolution,
  viewportSafeUV,
  viewportSharedTexture,
  viewportSize,
  viewportTexture,
  viewportTopLeft,
  viewportUV,
  wgsl,
  wgslFn,
  workgroupArray,
  workgroupBarrier,
  workgroupId,
  workingToColorSpace,
  xor
});
var _clearColor$1 = new Color4();
var _flatCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var _cubeCamera = new PerspectiveCamera(90, 1);
var _clearColor = new Color();
var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI;
var _axisDirections = [
  new Vector3(-PHI, INV_PHI, 0),
  new Vector3(PHI, INV_PHI, 0),
  new Vector3(-INV_PHI, 0, PHI),
  new Vector3(INV_PHI, 0, PHI),
  new Vector3(0, PHI, -INV_PHI),
  new Vector3(0, PHI, INV_PHI),
  new Vector3(-1, 1, -1),
  new Vector3(1, 1, -1),
  new Vector3(-1, 1, 1),
  new Vector3(1, 1, 1)
];
var direction = getDirection(uv(), attribute("faceIndex")).normalize();
var outputDirection = vec3(direction.x, direction.y.negate(), direction.z);
var NodeFunctionInput = class {
  constructor(type, name, count = null, qualifier = "", isConst = false) {
    this.type = type;
    this.name = name;
    this.count = count;
    this.qualifier = qualifier;
    this.isConst = isConst;
  }
};
NodeFunctionInput.isNodeFunctionInput = true;
var _matrix41 = new Matrix4();
var _matrix42 = new Matrix4();
var NodeFunction = class {
  constructor(type, inputs, name = "", precision = "") {
    this.type = type;
    this.inputs = inputs;
    this.name = name;
    this.precision = precision;
  }
  getCode() {
    console.warn("Abstract function.");
  }
};
NodeFunction.isNodeFunction = true;
var _plane = new Plane();
var _defaultLights = new LightsNode();
var _scene = new Scene();
var _drawingBufferSize = new Vector2();
var _screen = new Vector4();
var _frustum = new Frustum();
var _projScreenMatrix = new Matrix4();
var _vector4 = new Vector4();
var _compareToWebGPU = {
  [NeverCompare]: "never",
  [LessCompare]: "less",
  [EqualCompare]: "equal",
  [LessEqualCompare]: "less-equal",
  [GreaterCompare]: "greater",
  [GreaterEqualCompare]: "greater-equal",
  [AlwaysCompare]: "always",
  [NotEqualCompare]: "not-equal"
};
var GPUShaderStage = typeof self !== "undefined" ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };
var accessNames = {
  [NodeAccess.READ_ONLY]: "read",
  [NodeAccess.WRITE_ONLY]: "write",
  [NodeAccess.READ_WRITE]: "read_write"
};
var wrapNames = {
  [RepeatWrapping]: "repeat",
  [ClampToEdgeWrapping]: "clamp",
  [MirroredRepeatWrapping]: "mirror"
};
var gpuShaderStageLib = {
  "vertex": GPUShaderStage ? GPUShaderStage.VERTEX : 1,
  "fragment": GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,
  "compute": GPUShaderStage ? GPUShaderStage.COMPUTE : 4
};
var wgslPolyfill = {
  tsl_xor: new CodeNode("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),
  mod_float: new CodeNode("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),
  mod_vec2: new CodeNode("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),
  mod_vec3: new CodeNode("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),
  mod_vec4: new CodeNode("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),
  equals_bool: new CodeNode("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),
  equals_bvec2: new CodeNode("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),
  equals_bvec3: new CodeNode("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),
  equals_bvec4: new CodeNode("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),
  repeatWrapping_float: new CodeNode("fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }"),
  mirrorWrapping_float: new CodeNode("fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }"),
  clampWrapping_float: new CodeNode("fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }"),
  biquadraticTexture: new CodeNode(
    /* wgsl */
    `
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {

	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
`
  )
};
var wgslMethods = {
  dFdx: "dpdx",
  dFdy: "- dpdy",
  mod_float: "tsl_mod_float",
  mod_vec2: "tsl_mod_vec2",
  mod_vec3: "tsl_mod_vec3",
  mod_vec4: "tsl_mod_vec4",
  equals_bool: "tsl_equals_bool",
  equals_bvec2: "tsl_equals_bvec2",
  equals_bvec3: "tsl_equals_bvec3",
  equals_bvec4: "tsl_equals_bvec4",
  inversesqrt: "inverseSqrt",
  bitcast: "bitcast<f32>"
};
if (typeof navigator !== "undefined" && /Windows/g.test(navigator.userAgent)) {
  wgslPolyfill.pow_float = new CodeNode("fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }");
  wgslPolyfill.pow_vec2 = new CodeNode("fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }", [wgslPolyfill.pow_float]);
  wgslPolyfill.pow_vec3 = new CodeNode("fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }", [wgslPolyfill.pow_float]);
  wgslPolyfill.pow_vec4 = new CodeNode("fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }", [wgslPolyfill.pow_float]);
  wgslMethods.pow_float = "tsl_pow_float";
  wgslMethods.pow_vec2 = "tsl_pow_vec2";
  wgslMethods.pow_vec3 = "tsl_pow_vec3";
  wgslMethods.pow_vec4 = "tsl_pow_vec4";
}
var diagnostics = "";
if ((typeof navigator !== "undefined" && /Firefox|Deno/g.test(navigator.userAgent)) !== true) {
  diagnostics += "diagnostic( off, derivative_uniformity );\n";
}
var _material = new NodeMaterial();
var _quadMesh = new QuadMesh(_material);
function saveRendererState(renderer, state = {}) {
  state.toneMapping = renderer.toneMapping;
  state.toneMappingExposure = renderer.toneMappingExposure;
  state.outputColorSpace = renderer.outputColorSpace;
  state.renderTarget = renderer.getRenderTarget();
  state.activeCubeFace = renderer.getActiveCubeFace();
  state.activeMipmapLevel = renderer.getActiveMipmapLevel();
  state.renderObjectFunction = renderer.getRenderObjectFunction();
  state.pixelRatio = renderer.getPixelRatio();
  state.mrt = renderer.getMRT();
  state.clearColor = renderer.getClearColor(state.clearColor || new Color());
  state.clearAlpha = renderer.getClearAlpha();
  state.autoClear = renderer.autoClear;
  state.scissorTest = renderer.getScissorTest();
  return state;
}
function resetRendererState(renderer, state) {
  state = saveRendererState(renderer, state);
  renderer.setMRT(null);
  renderer.setRenderObjectFunction(null);
  renderer.setClearColor(0, 1);
  renderer.autoClear = true;
  return state;
}
function restoreRendererState(renderer, state) {
  renderer.toneMapping = state.toneMapping;
  renderer.toneMappingExposure = state.toneMappingExposure;
  renderer.outputColorSpace = state.outputColorSpace;
  renderer.setRenderTarget(state.renderTarget, state.activeCubeFace, state.activeMipmapLevel);
  renderer.setRenderObjectFunction(state.renderObjectFunction);
  renderer.setPixelRatio(state.pixelRatio);
  renderer.setMRT(state.mrt);
  renderer.setClearColor(state.clearColor, state.clearAlpha);
  renderer.autoClear = state.autoClear;
  renderer.setScissorTest(state.scissorTest);
}
function saveRendererAndSceneState(renderer, scene, state = {}) {
  state = saveRendererState(renderer, state);
  state.background = scene.background;
  state.backgroundNode = scene.backgroundNode;
  state.overrideMaterial = scene.overrideMaterial;
  return state;
}
function resetRendererAndSceneState(renderer, scene, state) {
  state = saveRendererAndSceneState(renderer, scene, state);
  scene.background = null;
  scene.backgroundNode = null;
  scene.overrideMaterial = null;
  return state;
}
function restoreRendererAndSceneState(renderer, scene, state) {
  restoreRendererState(renderer, state);
  scene.background = state.background;
  scene.backgroundNode = state.backgroundNode;
  scene.overrideMaterial = state.overrideMaterial;
}
var PostProcessingUtils = Object.freeze({
  __proto__: null,
  resetRendererAndSceneState,
  resetRendererState,
  restoreRendererAndSceneState,
  restoreRendererState,
  saveRendererAndSceneState,
  saveRendererState
});

// node_modules/three/build/three.tsl.js
var BRDF_GGX2 = TSL.BRDF_GGX;
var BRDF_Lambert2 = TSL.BRDF_Lambert;
var BasicShadowFilter2 = TSL.BasicShadowFilter;
var Break2 = TSL.Break;
var Continue2 = TSL.Continue;
var DFGApprox2 = TSL.DFGApprox;
var D_GGX2 = TSL.D_GGX;
var Discard2 = TSL.Discard;
var EPSILON2 = TSL.EPSILON;
var F_Schlick2 = TSL.F_Schlick;
var Fn2 = TSL.Fn;
var INFINITY2 = TSL.INFINITY;
var If2 = TSL.If;
var Loop2 = TSL.Loop;
var NodeShaderStage2 = TSL.NodeShaderStage;
var NodeType2 = TSL.NodeType;
var NodeUpdateType2 = TSL.NodeUpdateType;
var NodeAccess2 = TSL.NodeAccess;
var PCFShadowFilter2 = TSL.PCFShadowFilter;
var PCFSoftShadowFilter2 = TSL.PCFSoftShadowFilter;
var PI3 = TSL.PI;
var PI22 = TSL.PI2;
var Return2 = TSL.Return;
var Schlick_to_F02 = TSL.Schlick_to_F0;
var ScriptableNodeResources2 = TSL.ScriptableNodeResources;
var ShaderNode2 = TSL.ShaderNode;
var TBNViewMatrix2 = TSL.TBNViewMatrix;
var VSMShadowFilter2 = TSL.VSMShadowFilter;
var V_GGX_SmithCorrelated2 = TSL.V_GGX_SmithCorrelated;
var abs2 = TSL.abs;
var acesFilmicToneMapping2 = TSL.acesFilmicToneMapping;
var acos2 = TSL.acos;
var add2 = TSL.add;
var addMethodChaining2 = TSL.addMethodChaining;
var addNodeElement2 = TSL.addNodeElement;
var agxToneMapping2 = TSL.agxToneMapping;
var all2 = TSL.all;
var alphaT2 = TSL.alphaT;
var and2 = TSL.and;
var anisotropy2 = TSL.anisotropy;
var anisotropyB2 = TSL.anisotropyB;
var anisotropyT2 = TSL.anisotropyT;
var any2 = TSL.any;
var append2 = TSL.append;
var arrayBuffer2 = TSL.arrayBuffer;
var asin2 = TSL.asin;
var assign2 = TSL.assign;
var atan3 = TSL.atan;
var atan22 = TSL.atan2;
var atomicAdd2 = TSL.atomicAdd;
var atomicAnd2 = TSL.atomicAnd;
var atomicFunc2 = TSL.atomicFunc;
var atomicMax2 = TSL.atomicMax;
var atomicMin2 = TSL.atomicMin;
var atomicOr2 = TSL.atomicOr;
var atomicStore2 = TSL.atomicStore;
var atomicSub2 = TSL.atomicSub;
var atomicXor2 = TSL.atomicXor;
var attenuationColor2 = TSL.attenuationColor;
var attenuationDistance2 = TSL.attenuationDistance;
var attribute2 = TSL.attribute;
var attributeArray2 = TSL.attributeArray;
var backgroundBlurriness2 = TSL.backgroundBlurriness;
var backgroundIntensity2 = TSL.backgroundIntensity;
var backgroundRotation2 = TSL.backgroundRotation;
var batch2 = TSL.batch;
var billboarding2 = TSL.billboarding;
var bitAnd2 = TSL.bitAnd;
var bitNot2 = TSL.bitNot;
var bitOr2 = TSL.bitOr;
var bitXor2 = TSL.bitXor;
var bitangentGeometry2 = TSL.bitangentGeometry;
var bitangentLocal2 = TSL.bitangentLocal;
var bitangentView2 = TSL.bitangentView;
var bitangentWorld2 = TSL.bitangentWorld;
var bitcast2 = TSL.bitcast;
var blendBurn2 = TSL.blendBurn;
var blendColor2 = TSL.blendColor;
var blendDodge2 = TSL.blendDodge;
var blendOverlay2 = TSL.blendOverlay;
var blendScreen2 = TSL.blendScreen;
var blur2 = TSL.blur;
var bool2 = TSL.bool;
var buffer2 = TSL.buffer;
var bufferAttribute2 = TSL.bufferAttribute;
var bumpMap2 = TSL.bumpMap;
var burn2 = TSL.burn;
var bvec22 = TSL.bvec2;
var bvec32 = TSL.bvec3;
var bvec42 = TSL.bvec4;
var bypass2 = TSL.bypass;
var cache2 = TSL.cache;
var call2 = TSL.call;
var cameraFar2 = TSL.cameraFar;
var cameraNear2 = TSL.cameraNear;
var cameraNormalMatrix2 = TSL.cameraNormalMatrix;
var cameraPosition2 = TSL.cameraPosition;
var cameraProjectionMatrix2 = TSL.cameraProjectionMatrix;
var cameraProjectionMatrixInverse2 = TSL.cameraProjectionMatrixInverse;
var cameraViewMatrix2 = TSL.cameraViewMatrix;
var cameraWorldMatrix2 = TSL.cameraWorldMatrix;
var cbrt2 = TSL.cbrt;
var cdl2 = TSL.cdl;
var ceil2 = TSL.ceil;
var checker2 = TSL.checker;
var cineonToneMapping2 = TSL.cineonToneMapping;
var clamp2 = TSL.clamp;
var clearcoat2 = TSL.clearcoat;
var clearcoatRoughness2 = TSL.clearcoatRoughness;
var code2 = TSL.code;
var color2 = TSL.color;
var colorSpaceToWorking2 = TSL.colorSpaceToWorking;
var colorToDirection2 = TSL.colorToDirection;
var compute2 = TSL.compute;
var cond2 = TSL.cond;
var context2 = TSL.context;
var convert2 = TSL.convert;
var convertColorSpace2 = TSL.convertColorSpace;
var convertToTexture2 = TSL.convertToTexture;
var cos2 = TSL.cos;
var cross2 = TSL.cross;
var cubeTexture2 = TSL.cubeTexture;
var dFdx2 = TSL.dFdx;
var dFdy2 = TSL.dFdy;
var dashSize2 = TSL.dashSize;
var defaultBuildStages2 = TSL.defaultBuildStages;
var defaultShaderStages2 = TSL.defaultShaderStages;
var defined2 = TSL.defined;
var degrees2 = TSL.degrees;
var deltaTime2 = TSL.deltaTime;
var densityFog2 = TSL.densityFog;
var depth2 = TSL.depth;
var depthPass2 = TSL.depthPass;
var difference2 = TSL.difference;
var diffuseColor2 = TSL.diffuseColor;
var directPointLight2 = TSL.directPointLight;
var directionToColor2 = TSL.directionToColor;
var dispersion2 = TSL.dispersion;
var distance2 = TSL.distance;
var div2 = TSL.div;
var dodge2 = TSL.dodge;
var dot2 = TSL.dot;
var drawIndex2 = TSL.drawIndex;
var dynamicBufferAttribute2 = TSL.dynamicBufferAttribute;
var element2 = TSL.element;
var emissive2 = TSL.emissive;
var equal2 = TSL.equal;
var equals2 = TSL.equals;
var equirectUV2 = TSL.equirectUV;
var exp3 = TSL.exp;
var exp22 = TSL.exp2;
var expression2 = TSL.expression;
var faceDirection2 = TSL.faceDirection;
var faceForward2 = TSL.faceForward;
var float2 = TSL.float;
var floor2 = TSL.floor;
var fog2 = TSL.fog;
var fract2 = TSL.fract;
var frameGroup2 = TSL.frameGroup;
var frameId2 = TSL.frameId;
var frontFacing2 = TSL.frontFacing;
var fwidth2 = TSL.fwidth;
var gain2 = TSL.gain;
var gapSize2 = TSL.gapSize;
var getConstNodeType2 = TSL.getConstNodeType;
var getCurrentStack2 = TSL.getCurrentStack;
var getDirection2 = TSL.getDirection;
var getDistanceAttenuation2 = TSL.getDistanceAttenuation;
var getGeometryRoughness2 = TSL.getGeometryRoughness;
var getNormalFromDepth2 = TSL.getNormalFromDepth;
var getParallaxCorrectNormal2 = TSL.getParallaxCorrectNormal;
var getRoughness2 = TSL.getRoughness;
var getScreenPosition2 = TSL.getScreenPosition;
var getShIrradianceAt2 = TSL.getShIrradianceAt;
var getTextureIndex2 = TSL.getTextureIndex;
var getViewPosition2 = TSL.getViewPosition;
var glsl2 = TSL.glsl;
var glslFn2 = TSL.glslFn;
var grayscale2 = TSL.grayscale;
var greaterThan2 = TSL.greaterThan;
var greaterThanEqual2 = TSL.greaterThanEqual;
var hash2 = TSL.hash;
var highPrecisionModelNormalViewMatrix2 = TSL.highPrecisionModelNormalViewMatrix;
var highPrecisionModelViewMatrix2 = TSL.highPrecisionModelViewMatrix;
var hue2 = TSL.hue;
var instance2 = TSL.instance;
var instanceIndex2 = TSL.instanceIndex;
var instancedArray2 = TSL.instancedArray;
var instancedBufferAttribute2 = TSL.instancedBufferAttribute;
var instancedDynamicBufferAttribute2 = TSL.instancedDynamicBufferAttribute;
var instancedMesh2 = TSL.instancedMesh;
var int2 = TSL.int;
var inverseSqrt2 = TSL.inverseSqrt;
var invocationLocalIndex2 = TSL.invocationLocalIndex;
var invocationSubgroupIndex2 = TSL.invocationSubgroupIndex;
var ior2 = TSL.ior;
var iridescence2 = TSL.iridescence;
var iridescenceIOR2 = TSL.iridescenceIOR;
var iridescenceThickness2 = TSL.iridescenceThickness;
var ivec22 = TSL.ivec2;
var ivec32 = TSL.ivec3;
var ivec42 = TSL.ivec4;
var js2 = TSL.js;
var label2 = TSL.label;
var length2 = TSL.length;
var lengthSq2 = TSL.lengthSq;
var lessThan2 = TSL.lessThan;
var lessThanEqual2 = TSL.lessThanEqual;
var lightPosition2 = TSL.lightPosition;
var lightTargetDirection2 = TSL.lightTargetDirection;
var lightTargetPosition2 = TSL.lightTargetPosition;
var lightViewPosition2 = TSL.lightViewPosition;
var lightingContext2 = TSL.lightingContext;
var lights2 = TSL.lights;
var linearDepth2 = TSL.linearDepth;
var linearToneMapping2 = TSL.linearToneMapping;
var localId2 = TSL.localId;
var log3 = TSL.log;
var log22 = TSL.log2;
var logarithmicDepthToViewZ2 = TSL.logarithmicDepthToViewZ;
var loop2 = TSL.loop;
var luminance2 = TSL.luminance;
var mat22 = TSL.mat2;
var mat32 = TSL.mat3;
var mat42 = TSL.mat4;
var matcapUV2 = TSL.matcapUV;
var materialAOMap2 = TSL.materialAOMap;
var materialAlphaTest2 = TSL.materialAlphaTest;
var materialAnisotropy2 = TSL.materialAnisotropy;
var materialAnisotropyVector2 = TSL.materialAnisotropyVector;
var materialAttenuationColor2 = TSL.materialAttenuationColor;
var materialAttenuationDistance2 = TSL.materialAttenuationDistance;
var materialClearcoat2 = TSL.materialClearcoat;
var materialClearcoatNormal2 = TSL.materialClearcoatNormal;
var materialClearcoatRoughness2 = TSL.materialClearcoatRoughness;
var materialColor2 = TSL.materialColor;
var materialDispersion2 = TSL.materialDispersion;
var materialEmissive2 = TSL.materialEmissive;
var materialIOR2 = TSL.materialIOR;
var materialIridescence2 = TSL.materialIridescence;
var materialIridescenceIOR2 = TSL.materialIridescenceIOR;
var materialIridescenceThickness2 = TSL.materialIridescenceThickness;
var materialLightMap2 = TSL.materialLightMap;
var materialLineDashOffset2 = TSL.materialLineDashOffset;
var materialLineDashSize2 = TSL.materialLineDashSize;
var materialLineGapSize2 = TSL.materialLineGapSize;
var materialLineScale2 = TSL.materialLineScale;
var materialLineWidth2 = TSL.materialLineWidth;
var materialMetalness2 = TSL.materialMetalness;
var materialNormal2 = TSL.materialNormal;
var materialOpacity2 = TSL.materialOpacity;
var materialPointWidth2 = TSL.materialPointWidth;
var materialReference2 = TSL.materialReference;
var materialReflectivity2 = TSL.materialReflectivity;
var materialRefractionRatio2 = TSL.materialRefractionRatio;
var materialRotation2 = TSL.materialRotation;
var materialRoughness2 = TSL.materialRoughness;
var materialSheen2 = TSL.materialSheen;
var materialSheenRoughness2 = TSL.materialSheenRoughness;
var materialShininess2 = TSL.materialShininess;
var materialSpecular2 = TSL.materialSpecular;
var materialSpecularColor2 = TSL.materialSpecularColor;
var materialSpecularIntensity2 = TSL.materialSpecularIntensity;
var materialSpecularStrength2 = TSL.materialSpecularStrength;
var materialThickness2 = TSL.materialThickness;
var materialTransmission2 = TSL.materialTransmission;
var max2 = TSL.max;
var maxMipLevel2 = TSL.maxMipLevel;
var metalness2 = TSL.metalness;
var min2 = TSL.min;
var mix2 = TSL.mix;
var mixElement2 = TSL.mixElement;
var mod2 = TSL.mod;
var modInt2 = TSL.modInt;
var modelDirection2 = TSL.modelDirection;
var modelNormalMatrix2 = TSL.modelNormalMatrix;
var modelPosition2 = TSL.modelPosition;
var modelScale2 = TSL.modelScale;
var modelViewMatrix2 = TSL.modelViewMatrix;
var modelViewPosition2 = TSL.modelViewPosition;
var modelViewProjection2 = TSL.modelViewProjection;
var modelWorldMatrix2 = TSL.modelWorldMatrix;
var modelWorldMatrixInverse2 = TSL.modelWorldMatrixInverse;
var morphReference2 = TSL.morphReference;
var mrt2 = TSL.mrt;
var mul2 = TSL.mul;
var mx_aastep2 = TSL.mx_aastep;
var mx_cell_noise_float2 = TSL.mx_cell_noise_float;
var mx_contrast2 = TSL.mx_contrast;
var mx_fractal_noise_float2 = TSL.mx_fractal_noise_float;
var mx_fractal_noise_vec22 = TSL.mx_fractal_noise_vec2;
var mx_fractal_noise_vec32 = TSL.mx_fractal_noise_vec3;
var mx_fractal_noise_vec42 = TSL.mx_fractal_noise_vec4;
var mx_hsvtorgb2 = TSL.mx_hsvtorgb;
var mx_noise_float2 = TSL.mx_noise_float;
var mx_noise_vec32 = TSL.mx_noise_vec3;
var mx_noise_vec42 = TSL.mx_noise_vec4;
var mx_ramplr2 = TSL.mx_ramplr;
var mx_ramptb2 = TSL.mx_ramptb;
var mx_rgbtohsv2 = TSL.mx_rgbtohsv;
var mx_safepower2 = TSL.mx_safepower;
var mx_splitlr2 = TSL.mx_splitlr;
var mx_splittb2 = TSL.mx_splittb;
var mx_srgb_texture_to_lin_rec7092 = TSL.mx_srgb_texture_to_lin_rec709;
var mx_transform_uv2 = TSL.mx_transform_uv;
var mx_worley_noise_float2 = TSL.mx_worley_noise_float;
var mx_worley_noise_vec22 = TSL.mx_worley_noise_vec2;
var mx_worley_noise_vec32 = TSL.mx_worley_noise_vec3;
var negate2 = TSL.negate;
var neutralToneMapping2 = TSL.neutralToneMapping;
var nodeArray2 = TSL.nodeArray;
var nodeImmutable2 = TSL.nodeImmutable;
var nodeObject2 = TSL.nodeObject;
var nodeObjects2 = TSL.nodeObjects;
var nodeProxy2 = TSL.nodeProxy;
var normalFlat2 = TSL.normalFlat;
var normalGeometry2 = TSL.normalGeometry;
var normalLocal2 = TSL.normalLocal;
var normalMap2 = TSL.normalMap;
var normalView2 = TSL.normalView;
var normalWorld2 = TSL.normalWorld;
var normalize2 = TSL.normalize;
var not2 = TSL.not;
var notEqual2 = TSL.notEqual;
var numWorkgroups2 = TSL.numWorkgroups;
var objectDirection2 = TSL.objectDirection;
var objectGroup2 = TSL.objectGroup;
var objectPosition2 = TSL.objectPosition;
var objectScale2 = TSL.objectScale;
var objectViewPosition2 = TSL.objectViewPosition;
var objectWorldMatrix2 = TSL.objectWorldMatrix;
var oneMinus2 = TSL.oneMinus;
var or2 = TSL.or;
var orthographicDepthToViewZ2 = TSL.orthographicDepthToViewZ;
var oscSawtooth2 = TSL.oscSawtooth;
var oscSine2 = TSL.oscSine;
var oscSquare2 = TSL.oscSquare;
var oscTriangle2 = TSL.oscTriangle;
var output2 = TSL.output;
var outputStruct2 = TSL.outputStruct;
var overlay2 = TSL.overlay;
var overloadingFn2 = TSL.overloadingFn;
var parabola2 = TSL.parabola;
var parallaxDirection2 = TSL.parallaxDirection;
var parallaxUV2 = TSL.parallaxUV;
var parameter2 = TSL.parameter;
var pass2 = TSL.pass;
var passTexture2 = TSL.passTexture;
var pcurve2 = TSL.pcurve;
var perspectiveDepthToViewZ2 = TSL.perspectiveDepthToViewZ;
var pmremTexture2 = TSL.pmremTexture;
var pointUV2 = TSL.pointUV;
var pointWidth2 = TSL.pointWidth;
var positionGeometry2 = TSL.positionGeometry;
var positionLocal2 = TSL.positionLocal;
var positionPrevious2 = TSL.positionPrevious;
var positionView2 = TSL.positionView;
var positionViewDirection2 = TSL.positionViewDirection;
var positionWorld2 = TSL.positionWorld;
var positionWorldDirection2 = TSL.positionWorldDirection;
var posterize2 = TSL.posterize;
var pow5 = TSL.pow;
var pow22 = TSL.pow2;
var pow32 = TSL.pow3;
var pow42 = TSL.pow4;
var property2 = TSL.property;
var radians2 = TSL.radians;
var rand2 = TSL.rand;
var range2 = TSL.range;
var rangeFog2 = TSL.rangeFog;
var reciprocal2 = TSL.reciprocal;
var reference2 = TSL.reference;
var referenceBuffer2 = TSL.referenceBuffer;
var reflect2 = TSL.reflect;
var reflectVector2 = TSL.reflectVector;
var reflectView2 = TSL.reflectView;
var reflector2 = TSL.reflector;
var refract2 = TSL.refract;
var refractVector2 = TSL.refractVector;
var refractView2 = TSL.refractView;
var reinhardToneMapping2 = TSL.reinhardToneMapping;
var remainder2 = TSL.remainder;
var remap2 = TSL.remap;
var remapClamp2 = TSL.remapClamp;
var renderGroup2 = TSL.renderGroup;
var renderOutput2 = TSL.renderOutput;
var rendererReference2 = TSL.rendererReference;
var rotate2 = TSL.rotate;
var rotateUV2 = TSL.rotateUV;
var roughness2 = TSL.roughness;
var round2 = TSL.round;
var rtt2 = TSL.rtt;
var sRGBTransferEOTF2 = TSL.sRGBTransferEOTF;
var sRGBTransferOETF2 = TSL.sRGBTransferOETF;
var sampler2 = TSL.sampler;
var saturate2 = TSL.saturate;
var saturation2 = TSL.saturation;
var screen2 = TSL.screen;
var screenCoordinate2 = TSL.screenCoordinate;
var screenSize2 = TSL.screenSize;
var screenUV2 = TSL.screenUV;
var scriptable2 = TSL.scriptable;
var scriptableValue2 = TSL.scriptableValue;
var select2 = TSL.select;
var setCurrentStack2 = TSL.setCurrentStack;
var shaderStages2 = TSL.shaderStages;
var shadow2 = TSL.shadow;
var sharedUniformGroup2 = TSL.sharedUniformGroup;
var sheen2 = TSL.sheen;
var sheenRoughness2 = TSL.sheenRoughness;
var shiftLeft2 = TSL.shiftLeft;
var shiftRight2 = TSL.shiftRight;
var shininess2 = TSL.shininess;
var sign2 = TSL.sign;
var sin2 = TSL.sin;
var sinc2 = TSL.sinc;
var skinning2 = TSL.skinning;
var skinningReference2 = TSL.skinningReference;
var smoothstep2 = TSL.smoothstep;
var smoothstepElement2 = TSL.smoothstepElement;
var specularColor2 = TSL.specularColor;
var specularF902 = TSL.specularF90;
var spherizeUV2 = TSL.spherizeUV;
var split2 = TSL.split;
var spritesheetUV2 = TSL.spritesheetUV;
var sqrt2 = TSL.sqrt;
var stack2 = TSL.stack;
var step2 = TSL.step;
var storage2 = TSL.storage;
var storageBarrier2 = TSL.storageBarrier;
var storageObject2 = TSL.storageObject;
var storageTexture2 = TSL.storageTexture;
var string2 = TSL.string;
var sub2 = TSL.sub;
var subgroupIndex2 = TSL.subgroupIndex;
var subgroupSize2 = TSL.subgroupSize;
var tan2 = TSL.tan;
var tangentGeometry2 = TSL.tangentGeometry;
var tangentLocal2 = TSL.tangentLocal;
var tangentView2 = TSL.tangentView;
var tangentWorld2 = TSL.tangentWorld;
var temp2 = TSL.temp;
var texture2 = TSL.texture;
var texture3D2 = TSL.texture3D;
var textureBarrier2 = TSL.textureBarrier;
var textureBicubic2 = TSL.textureBicubic;
var textureCubeUV2 = TSL.textureCubeUV;
var textureLoad2 = TSL.textureLoad;
var textureSize2 = TSL.textureSize;
var textureStore2 = TSL.textureStore;
var thickness2 = TSL.thickness;
var threshold2 = TSL.threshold;
var time2 = TSL.time;
var timerDelta2 = TSL.timerDelta;
var timerGlobal2 = TSL.timerGlobal;
var timerLocal2 = TSL.timerLocal;
var toOutputColorSpace2 = TSL.toOutputColorSpace;
var toWorkingColorSpace2 = TSL.toWorkingColorSpace;
var toneMapping2 = TSL.toneMapping;
var toneMappingExposure2 = TSL.toneMappingExposure;
var toonOutlinePass2 = TSL.toonOutlinePass;
var transformDirection2 = TSL.transformDirection;
var transformNormal2 = TSL.transformNormal;
var transformNormalToView2 = TSL.transformNormalToView;
var transformedBentNormalView2 = TSL.transformedBentNormalView;
var transformedBitangentView2 = TSL.transformedBitangentView;
var transformedBitangentWorld2 = TSL.transformedBitangentWorld;
var transformedClearcoatNormalView2 = TSL.transformedClearcoatNormalView;
var transformedNormalView2 = TSL.transformedNormalView;
var transformedNormalWorld2 = TSL.transformedNormalWorld;
var transformedTangentView2 = TSL.transformedTangentView;
var transformedTangentWorld2 = TSL.transformedTangentWorld;
var transmission2 = TSL.transmission;
var transpose2 = TSL.transpose;
var tri2 = TSL.tri;
var tri32 = TSL.tri3;
var triNoise3D2 = TSL.triNoise3D;
var triplanarTexture2 = TSL.triplanarTexture;
var triplanarTextures2 = TSL.triplanarTextures;
var trunc2 = TSL.trunc;
var tslFn2 = TSL.tslFn;
var uint2 = TSL.uint;
var uniform2 = TSL.uniform;
var uniformArray2 = TSL.uniformArray;
var uniformGroup2 = TSL.uniformGroup;
var uniforms2 = TSL.uniforms;
var userData2 = TSL.userData;
var uv2 = TSL.uv;
var uvec22 = TSL.uvec2;
var uvec32 = TSL.uvec3;
var uvec42 = TSL.uvec4;
var varying2 = TSL.varying;
var varyingProperty2 = TSL.varyingProperty;
var vec22 = TSL.vec2;
var vec32 = TSL.vec3;
var vec42 = TSL.vec4;
var vectorComponents2 = TSL.vectorComponents;
var velocity2 = TSL.velocity;
var vertexColor2 = TSL.vertexColor;
var vertexIndex2 = TSL.vertexIndex;
var vibrance2 = TSL.vibrance;
var viewZToLogarithmicDepth2 = TSL.viewZToLogarithmicDepth;
var viewZToOrthographicDepth2 = TSL.viewZToOrthographicDepth;
var viewZToPerspectiveDepth2 = TSL.viewZToPerspectiveDepth;
var viewport2 = TSL.viewport;
var viewportBottomLeft2 = TSL.viewportBottomLeft;
var viewportCoordinate2 = TSL.viewportCoordinate;
var viewportDepthTexture2 = TSL.viewportDepthTexture;
var viewportLinearDepth2 = TSL.viewportLinearDepth;
var viewportMipTexture2 = TSL.viewportMipTexture;
var viewportResolution2 = TSL.viewportResolution;
var viewportSafeUV2 = TSL.viewportSafeUV;
var viewportSharedTexture2 = TSL.viewportSharedTexture;
var viewportSize2 = TSL.viewportSize;
var viewportTexture2 = TSL.viewportTexture;
var viewportTopLeft2 = TSL.viewportTopLeft;
var viewportUV2 = TSL.viewportUV;
var wgsl2 = TSL.wgsl;
var wgslFn2 = TSL.wgslFn;
var workgroupArray2 = TSL.workgroupArray;
var workgroupBarrier2 = TSL.workgroupBarrier;
var workgroupId2 = TSL.workgroupId;
var workingToColorSpace2 = TSL.workingToColorSpace;
var xor2 = TSL.xor;
export {
  BRDF_GGX2 as BRDF_GGX,
  BRDF_Lambert2 as BRDF_Lambert,
  BasicShadowFilter2 as BasicShadowFilter,
  Break2 as Break,
  Continue2 as Continue,
  DFGApprox2 as DFGApprox,
  D_GGX2 as D_GGX,
  Discard2 as Discard,
  EPSILON2 as EPSILON,
  F_Schlick2 as F_Schlick,
  Fn2 as Fn,
  INFINITY2 as INFINITY,
  If2 as If,
  Loop2 as Loop,
  NodeAccess2 as NodeAccess,
  NodeShaderStage2 as NodeShaderStage,
  NodeType2 as NodeType,
  NodeUpdateType2 as NodeUpdateType,
  PCFShadowFilter2 as PCFShadowFilter,
  PCFSoftShadowFilter2 as PCFSoftShadowFilter,
  PI3 as PI,
  PI22 as PI2,
  Return2 as Return,
  Schlick_to_F02 as Schlick_to_F0,
  ScriptableNodeResources2 as ScriptableNodeResources,
  ShaderNode2 as ShaderNode,
  TBNViewMatrix2 as TBNViewMatrix,
  VSMShadowFilter2 as VSMShadowFilter,
  V_GGX_SmithCorrelated2 as V_GGX_SmithCorrelated,
  abs2 as abs,
  acesFilmicToneMapping2 as acesFilmicToneMapping,
  acos2 as acos,
  add2 as add,
  addMethodChaining2 as addMethodChaining,
  addNodeElement2 as addNodeElement,
  agxToneMapping2 as agxToneMapping,
  all2 as all,
  alphaT2 as alphaT,
  and2 as and,
  anisotropy2 as anisotropy,
  anisotropyB2 as anisotropyB,
  anisotropyT2 as anisotropyT,
  any2 as any,
  append2 as append,
  arrayBuffer2 as arrayBuffer,
  asin2 as asin,
  assign2 as assign,
  atan3 as atan,
  atan22 as atan2,
  atomicAdd2 as atomicAdd,
  atomicAnd2 as atomicAnd,
  atomicFunc2 as atomicFunc,
  atomicMax2 as atomicMax,
  atomicMin2 as atomicMin,
  atomicOr2 as atomicOr,
  atomicStore2 as atomicStore,
  atomicSub2 as atomicSub,
  atomicXor2 as atomicXor,
  attenuationColor2 as attenuationColor,
  attenuationDistance2 as attenuationDistance,
  attribute2 as attribute,
  attributeArray2 as attributeArray,
  backgroundBlurriness2 as backgroundBlurriness,
  backgroundIntensity2 as backgroundIntensity,
  backgroundRotation2 as backgroundRotation,
  batch2 as batch,
  billboarding2 as billboarding,
  bitAnd2 as bitAnd,
  bitNot2 as bitNot,
  bitOr2 as bitOr,
  bitXor2 as bitXor,
  bitangentGeometry2 as bitangentGeometry,
  bitangentLocal2 as bitangentLocal,
  bitangentView2 as bitangentView,
  bitangentWorld2 as bitangentWorld,
  bitcast2 as bitcast,
  blendBurn2 as blendBurn,
  blendColor2 as blendColor,
  blendDodge2 as blendDodge,
  blendOverlay2 as blendOverlay,
  blendScreen2 as blendScreen,
  blur2 as blur,
  bool2 as bool,
  buffer2 as buffer,
  bufferAttribute2 as bufferAttribute,
  bumpMap2 as bumpMap,
  burn2 as burn,
  bvec22 as bvec2,
  bvec32 as bvec3,
  bvec42 as bvec4,
  bypass2 as bypass,
  cache2 as cache,
  call2 as call,
  cameraFar2 as cameraFar,
  cameraNear2 as cameraNear,
  cameraNormalMatrix2 as cameraNormalMatrix,
  cameraPosition2 as cameraPosition,
  cameraProjectionMatrix2 as cameraProjectionMatrix,
  cameraProjectionMatrixInverse2 as cameraProjectionMatrixInverse,
  cameraViewMatrix2 as cameraViewMatrix,
  cameraWorldMatrix2 as cameraWorldMatrix,
  cbrt2 as cbrt,
  cdl2 as cdl,
  ceil2 as ceil,
  checker2 as checker,
  cineonToneMapping2 as cineonToneMapping,
  clamp2 as clamp,
  clearcoat2 as clearcoat,
  clearcoatRoughness2 as clearcoatRoughness,
  code2 as code,
  color2 as color,
  colorSpaceToWorking2 as colorSpaceToWorking,
  colorToDirection2 as colorToDirection,
  compute2 as compute,
  cond2 as cond,
  context2 as context,
  convert2 as convert,
  convertColorSpace2 as convertColorSpace,
  convertToTexture2 as convertToTexture,
  cos2 as cos,
  cross2 as cross,
  cubeTexture2 as cubeTexture,
  dFdx2 as dFdx,
  dFdy2 as dFdy,
  dashSize2 as dashSize,
  defaultBuildStages2 as defaultBuildStages,
  defaultShaderStages2 as defaultShaderStages,
  defined2 as defined,
  degrees2 as degrees,
  deltaTime2 as deltaTime,
  densityFog2 as densityFog,
  depth2 as depth,
  depthPass2 as depthPass,
  difference2 as difference,
  diffuseColor2 as diffuseColor,
  directPointLight2 as directPointLight,
  directionToColor2 as directionToColor,
  dispersion2 as dispersion,
  distance2 as distance,
  div2 as div,
  dodge2 as dodge,
  dot2 as dot,
  drawIndex2 as drawIndex,
  dynamicBufferAttribute2 as dynamicBufferAttribute,
  element2 as element,
  emissive2 as emissive,
  equal2 as equal,
  equals2 as equals,
  equirectUV2 as equirectUV,
  exp3 as exp,
  exp22 as exp2,
  expression2 as expression,
  faceDirection2 as faceDirection,
  faceForward2 as faceForward,
  float2 as float,
  floor2 as floor,
  fog2 as fog,
  fract2 as fract,
  frameGroup2 as frameGroup,
  frameId2 as frameId,
  frontFacing2 as frontFacing,
  fwidth2 as fwidth,
  gain2 as gain,
  gapSize2 as gapSize,
  getConstNodeType2 as getConstNodeType,
  getCurrentStack2 as getCurrentStack,
  getDirection2 as getDirection,
  getDistanceAttenuation2 as getDistanceAttenuation,
  getGeometryRoughness2 as getGeometryRoughness,
  getNormalFromDepth2 as getNormalFromDepth,
  getParallaxCorrectNormal2 as getParallaxCorrectNormal,
  getRoughness2 as getRoughness,
  getScreenPosition2 as getScreenPosition,
  getShIrradianceAt2 as getShIrradianceAt,
  getTextureIndex2 as getTextureIndex,
  getViewPosition2 as getViewPosition,
  glsl2 as glsl,
  glslFn2 as glslFn,
  grayscale2 as grayscale,
  greaterThan2 as greaterThan,
  greaterThanEqual2 as greaterThanEqual,
  hash2 as hash,
  highPrecisionModelNormalViewMatrix2 as highPrecisionModelNormalViewMatrix,
  highPrecisionModelViewMatrix2 as highPrecisionModelViewMatrix,
  hue2 as hue,
  instance2 as instance,
  instanceIndex2 as instanceIndex,
  instancedArray2 as instancedArray,
  instancedBufferAttribute2 as instancedBufferAttribute,
  instancedDynamicBufferAttribute2 as instancedDynamicBufferAttribute,
  instancedMesh2 as instancedMesh,
  int2 as int,
  inverseSqrt2 as inverseSqrt,
  invocationLocalIndex2 as invocationLocalIndex,
  invocationSubgroupIndex2 as invocationSubgroupIndex,
  ior2 as ior,
  iridescence2 as iridescence,
  iridescenceIOR2 as iridescenceIOR,
  iridescenceThickness2 as iridescenceThickness,
  ivec22 as ivec2,
  ivec32 as ivec3,
  ivec42 as ivec4,
  js2 as js,
  label2 as label,
  length2 as length,
  lengthSq2 as lengthSq,
  lessThan2 as lessThan,
  lessThanEqual2 as lessThanEqual,
  lightPosition2 as lightPosition,
  lightTargetDirection2 as lightTargetDirection,
  lightTargetPosition2 as lightTargetPosition,
  lightViewPosition2 as lightViewPosition,
  lightingContext2 as lightingContext,
  lights2 as lights,
  linearDepth2 as linearDepth,
  linearToneMapping2 as linearToneMapping,
  localId2 as localId,
  log3 as log,
  log22 as log2,
  logarithmicDepthToViewZ2 as logarithmicDepthToViewZ,
  loop2 as loop,
  luminance2 as luminance,
  mat22 as mat2,
  mat32 as mat3,
  mat42 as mat4,
  matcapUV2 as matcapUV,
  materialAOMap2 as materialAOMap,
  materialAlphaTest2 as materialAlphaTest,
  materialAnisotropy2 as materialAnisotropy,
  materialAnisotropyVector2 as materialAnisotropyVector,
  materialAttenuationColor2 as materialAttenuationColor,
  materialAttenuationDistance2 as materialAttenuationDistance,
  materialClearcoat2 as materialClearcoat,
  materialClearcoatNormal2 as materialClearcoatNormal,
  materialClearcoatRoughness2 as materialClearcoatRoughness,
  materialColor2 as materialColor,
  materialDispersion2 as materialDispersion,
  materialEmissive2 as materialEmissive,
  materialIOR2 as materialIOR,
  materialIridescence2 as materialIridescence,
  materialIridescenceIOR2 as materialIridescenceIOR,
  materialIridescenceThickness2 as materialIridescenceThickness,
  materialLightMap2 as materialLightMap,
  materialLineDashOffset2 as materialLineDashOffset,
  materialLineDashSize2 as materialLineDashSize,
  materialLineGapSize2 as materialLineGapSize,
  materialLineScale2 as materialLineScale,
  materialLineWidth2 as materialLineWidth,
  materialMetalness2 as materialMetalness,
  materialNormal2 as materialNormal,
  materialOpacity2 as materialOpacity,
  materialPointWidth2 as materialPointWidth,
  materialReference2 as materialReference,
  materialReflectivity2 as materialReflectivity,
  materialRefractionRatio2 as materialRefractionRatio,
  materialRotation2 as materialRotation,
  materialRoughness2 as materialRoughness,
  materialSheen2 as materialSheen,
  materialSheenRoughness2 as materialSheenRoughness,
  materialShininess2 as materialShininess,
  materialSpecular2 as materialSpecular,
  materialSpecularColor2 as materialSpecularColor,
  materialSpecularIntensity2 as materialSpecularIntensity,
  materialSpecularStrength2 as materialSpecularStrength,
  materialThickness2 as materialThickness,
  materialTransmission2 as materialTransmission,
  max2 as max,
  maxMipLevel2 as maxMipLevel,
  metalness2 as metalness,
  min2 as min,
  mix2 as mix,
  mixElement2 as mixElement,
  mod2 as mod,
  modInt2 as modInt,
  modelDirection2 as modelDirection,
  modelNormalMatrix2 as modelNormalMatrix,
  modelPosition2 as modelPosition,
  modelScale2 as modelScale,
  modelViewMatrix2 as modelViewMatrix,
  modelViewPosition2 as modelViewPosition,
  modelViewProjection2 as modelViewProjection,
  modelWorldMatrix2 as modelWorldMatrix,
  modelWorldMatrixInverse2 as modelWorldMatrixInverse,
  morphReference2 as morphReference,
  mrt2 as mrt,
  mul2 as mul,
  mx_aastep2 as mx_aastep,
  mx_cell_noise_float2 as mx_cell_noise_float,
  mx_contrast2 as mx_contrast,
  mx_fractal_noise_float2 as mx_fractal_noise_float,
  mx_fractal_noise_vec22 as mx_fractal_noise_vec2,
  mx_fractal_noise_vec32 as mx_fractal_noise_vec3,
  mx_fractal_noise_vec42 as mx_fractal_noise_vec4,
  mx_hsvtorgb2 as mx_hsvtorgb,
  mx_noise_float2 as mx_noise_float,
  mx_noise_vec32 as mx_noise_vec3,
  mx_noise_vec42 as mx_noise_vec4,
  mx_ramplr2 as mx_ramplr,
  mx_ramptb2 as mx_ramptb,
  mx_rgbtohsv2 as mx_rgbtohsv,
  mx_safepower2 as mx_safepower,
  mx_splitlr2 as mx_splitlr,
  mx_splittb2 as mx_splittb,
  mx_srgb_texture_to_lin_rec7092 as mx_srgb_texture_to_lin_rec709,
  mx_transform_uv2 as mx_transform_uv,
  mx_worley_noise_float2 as mx_worley_noise_float,
  mx_worley_noise_vec22 as mx_worley_noise_vec2,
  mx_worley_noise_vec32 as mx_worley_noise_vec3,
  negate2 as negate,
  neutralToneMapping2 as neutralToneMapping,
  nodeArray2 as nodeArray,
  nodeImmutable2 as nodeImmutable,
  nodeObject2 as nodeObject,
  nodeObjects2 as nodeObjects,
  nodeProxy2 as nodeProxy,
  normalFlat2 as normalFlat,
  normalGeometry2 as normalGeometry,
  normalLocal2 as normalLocal,
  normalMap2 as normalMap,
  normalView2 as normalView,
  normalWorld2 as normalWorld,
  normalize2 as normalize,
  not2 as not,
  notEqual2 as notEqual,
  numWorkgroups2 as numWorkgroups,
  objectDirection2 as objectDirection,
  objectGroup2 as objectGroup,
  objectPosition2 as objectPosition,
  objectScale2 as objectScale,
  objectViewPosition2 as objectViewPosition,
  objectWorldMatrix2 as objectWorldMatrix,
  oneMinus2 as oneMinus,
  or2 as or,
  orthographicDepthToViewZ2 as orthographicDepthToViewZ,
  oscSawtooth2 as oscSawtooth,
  oscSine2 as oscSine,
  oscSquare2 as oscSquare,
  oscTriangle2 as oscTriangle,
  output2 as output,
  outputStruct2 as outputStruct,
  overlay2 as overlay,
  overloadingFn2 as overloadingFn,
  parabola2 as parabola,
  parallaxDirection2 as parallaxDirection,
  parallaxUV2 as parallaxUV,
  parameter2 as parameter,
  pass2 as pass,
  passTexture2 as passTexture,
  pcurve2 as pcurve,
  perspectiveDepthToViewZ2 as perspectiveDepthToViewZ,
  pmremTexture2 as pmremTexture,
  pointUV2 as pointUV,
  pointWidth2 as pointWidth,
  positionGeometry2 as positionGeometry,
  positionLocal2 as positionLocal,
  positionPrevious2 as positionPrevious,
  positionView2 as positionView,
  positionViewDirection2 as positionViewDirection,
  positionWorld2 as positionWorld,
  positionWorldDirection2 as positionWorldDirection,
  posterize2 as posterize,
  pow5 as pow,
  pow22 as pow2,
  pow32 as pow3,
  pow42 as pow4,
  property2 as property,
  radians2 as radians,
  rand2 as rand,
  range2 as range,
  rangeFog2 as rangeFog,
  reciprocal2 as reciprocal,
  reference2 as reference,
  referenceBuffer2 as referenceBuffer,
  reflect2 as reflect,
  reflectVector2 as reflectVector,
  reflectView2 as reflectView,
  reflector2 as reflector,
  refract2 as refract,
  refractVector2 as refractVector,
  refractView2 as refractView,
  reinhardToneMapping2 as reinhardToneMapping,
  remainder2 as remainder,
  remap2 as remap,
  remapClamp2 as remapClamp,
  renderGroup2 as renderGroup,
  renderOutput2 as renderOutput,
  rendererReference2 as rendererReference,
  rotate2 as rotate,
  rotateUV2 as rotateUV,
  roughness2 as roughness,
  round2 as round,
  rtt2 as rtt,
  sRGBTransferEOTF2 as sRGBTransferEOTF,
  sRGBTransferOETF2 as sRGBTransferOETF,
  sampler2 as sampler,
  saturate2 as saturate,
  saturation2 as saturation,
  screen2 as screen,
  screenCoordinate2 as screenCoordinate,
  screenSize2 as screenSize,
  screenUV2 as screenUV,
  scriptable2 as scriptable,
  scriptableValue2 as scriptableValue,
  select2 as select,
  setCurrentStack2 as setCurrentStack,
  shaderStages2 as shaderStages,
  shadow2 as shadow,
  sharedUniformGroup2 as sharedUniformGroup,
  sheen2 as sheen,
  sheenRoughness2 as sheenRoughness,
  shiftLeft2 as shiftLeft,
  shiftRight2 as shiftRight,
  shininess2 as shininess,
  sign2 as sign,
  sin2 as sin,
  sinc2 as sinc,
  skinning2 as skinning,
  skinningReference2 as skinningReference,
  smoothstep2 as smoothstep,
  smoothstepElement2 as smoothstepElement,
  specularColor2 as specularColor,
  specularF902 as specularF90,
  spherizeUV2 as spherizeUV,
  split2 as split,
  spritesheetUV2 as spritesheetUV,
  sqrt2 as sqrt,
  stack2 as stack,
  step2 as step,
  storage2 as storage,
  storageBarrier2 as storageBarrier,
  storageObject2 as storageObject,
  storageTexture2 as storageTexture,
  string2 as string,
  sub2 as sub,
  subgroupIndex2 as subgroupIndex,
  subgroupSize2 as subgroupSize,
  tan2 as tan,
  tangentGeometry2 as tangentGeometry,
  tangentLocal2 as tangentLocal,
  tangentView2 as tangentView,
  tangentWorld2 as tangentWorld,
  temp2 as temp,
  texture2 as texture,
  texture3D2 as texture3D,
  textureBarrier2 as textureBarrier,
  textureBicubic2 as textureBicubic,
  textureCubeUV2 as textureCubeUV,
  textureLoad2 as textureLoad,
  textureSize2 as textureSize,
  textureStore2 as textureStore,
  thickness2 as thickness,
  threshold2 as threshold,
  time2 as time,
  timerDelta2 as timerDelta,
  timerGlobal2 as timerGlobal,
  timerLocal2 as timerLocal,
  toOutputColorSpace2 as toOutputColorSpace,
  toWorkingColorSpace2 as toWorkingColorSpace,
  toneMapping2 as toneMapping,
  toneMappingExposure2 as toneMappingExposure,
  toonOutlinePass2 as toonOutlinePass,
  transformDirection2 as transformDirection,
  transformNormal2 as transformNormal,
  transformNormalToView2 as transformNormalToView,
  transformedBentNormalView2 as transformedBentNormalView,
  transformedBitangentView2 as transformedBitangentView,
  transformedBitangentWorld2 as transformedBitangentWorld,
  transformedClearcoatNormalView2 as transformedClearcoatNormalView,
  transformedNormalView2 as transformedNormalView,
  transformedNormalWorld2 as transformedNormalWorld,
  transformedTangentView2 as transformedTangentView,
  transformedTangentWorld2 as transformedTangentWorld,
  transmission2 as transmission,
  transpose2 as transpose,
  tri2 as tri,
  tri32 as tri3,
  triNoise3D2 as triNoise3D,
  triplanarTexture2 as triplanarTexture,
  triplanarTextures2 as triplanarTextures,
  trunc2 as trunc,
  tslFn2 as tslFn,
  uint2 as uint,
  uniform2 as uniform,
  uniformArray2 as uniformArray,
  uniformGroup2 as uniformGroup,
  uniforms2 as uniforms,
  userData2 as userData,
  uv2 as uv,
  uvec22 as uvec2,
  uvec32 as uvec3,
  uvec42 as uvec4,
  varying2 as varying,
  varyingProperty2 as varyingProperty,
  vec22 as vec2,
  vec32 as vec3,
  vec42 as vec4,
  vectorComponents2 as vectorComponents,
  velocity2 as velocity,
  vertexColor2 as vertexColor,
  vertexIndex2 as vertexIndex,
  vibrance2 as vibrance,
  viewZToLogarithmicDepth2 as viewZToLogarithmicDepth,
  viewZToOrthographicDepth2 as viewZToOrthographicDepth,
  viewZToPerspectiveDepth2 as viewZToPerspectiveDepth,
  viewport2 as viewport,
  viewportBottomLeft2 as viewportBottomLeft,
  viewportCoordinate2 as viewportCoordinate,
  viewportDepthTexture2 as viewportDepthTexture,
  viewportLinearDepth2 as viewportLinearDepth,
  viewportMipTexture2 as viewportMipTexture,
  viewportResolution2 as viewportResolution,
  viewportSafeUV2 as viewportSafeUV,
  viewportSharedTexture2 as viewportSharedTexture,
  viewportSize2 as viewportSize,
  viewportTexture2 as viewportTexture,
  viewportTopLeft2 as viewportTopLeft,
  viewportUV2 as viewportUV,
  wgsl2 as wgsl,
  wgslFn2 as wgslFn,
  workgroupArray2 as workgroupArray,
  workgroupBarrier2 as workgroupBarrier,
  workgroupId2 as workgroupId,
  workingToColorSpace2 as workingToColorSpace,
  xor2 as xor
};
/*! Bundled license information:

three/build/three.webgpu.js:
  (**
   * @license
   * Copyright 2010-2024 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)

three/build/three.tsl.js:
  (**
   * @license
   * Copyright 2010-2024 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)
*/
//# sourceMappingURL=three_tsl.js.map
